% -*- coding: utf-8 -*-
% Увеличить место под номера разделов в оглавлении начиная с этой главы
\addtocontents{toc}{%
  \setlength{\cftsectionnumwidth}{2.7em}%
  \setlength{\cftsubsectionindent}{4.2em}%
  \setlength{\cftsubsectionnumwidth}{3.6em}%
}
\chapter{Макросы: употребление и~злоупотребление}\label{chapter:macros}

\indexR{абстракция!и~макросы}
\initial{0.25ex}{0.0ex}{П}{\kern0.65ex резираемые,} неверно используемые,
несправедливо осуждаемые, недостаточно оправданные (теоретически) "--- как~бы их
не~клеймили, макросы остаются одним из столпов Лиспа и одной главных из причин
его долголетия. Если функции являются абстракцией вычислений, а объекты "---
абстракцией данных, то макросы абстрагируют структуру программ. В~этой главе мы
познакомимся с~макросами и вызываемыми ими проблемами. Ввиду того, что макросы
являются одной из наименее изученных тем в~Лиспе, существует огромное
разнообразие реализаций макросистем. Среди них сложно выделить канонические
решения, поэтому кода в~этой главе будет весьма умеренное количество, а больше
внимания уделяется изучению эволюции этих своеобразных сущностей "--- макросов.

\bigskip

\indexR{макросы}
\indexR{синтаксис!расширение}
\indexR{язык!расширение}
Изобретение макросов приписывается \cite{sg93} Тимоти~Харту, именно он придумал
их в~1963~году вскоре после выхода руководства по \LISP~1.5; с~тех пор и поныне
они являются неотъемлемой частью диалектов Лиспа. Макросы позволяют
разработчикам проектировать и реализовывать языки, соответствующие решаемым
проблемам. Подобно математике, где обычным делом является введение обозначений
для новых понятий, макросы позволяют расширять язык новыми синтаксическими
конструкциями. Не~поймите превратно: дело не~в~расширении возможностей языка
с~помощью библиотек функций или чего"~то подобного. Лисп с~графической
библиотекой всё ещё остаётся Лиспом и не~более чем Лиспом. Здесь~же речь идёт
об~увеличении выразительной силы языка с~помощью введения новых синтаксических
форм.

\begingroup
\def\={=\nobreak\discretionary{}{\hbox{\ensuremath{=}}}{}}
Расширение языка подразумевает введение новой нотации, которая позволяет,
например, писать $\lim_{x \to x_0} f(x) \= A$, когда имеется в~виду $\forall
\epsilon > 0\colon \exists \delta \= \delta(\epsilon)\colon \forall x\colon
0 < |x - x_0| < \delta \Rightarrow |f(x) - A| < \epsilon$. Естественно,
можно было~бы каждый раз в~деталях расписывать понятие предела, если~бы не~лень.
Но лень "--- двигатель прогресса. Подробные определения являются лишь обузой
для понимания более широких концепций, поэтому со~временем заменяются подобной
краткой и удобной формой записи. Очень многие математические понятия настолько
глубоко проработаны, что ими совершенно невозможно пользоваться в~полностью
развёрнутом виде, не~прибегая к~каким-либо сокращениям. Также ради гибкости
часто вводятся параметры: ведь когда мы пишем $\lim_{x \to x_0} f(x) \= A$, то
на самом деле имеем в~виду параметризованное сокращение $L(f(x), x_0, A)$.
Макросы "--- это отнюдь не~изящный хак, доступный лишь избранным, а невероятно
полезная возможность, позволяющая строить абстракции на уровне программ,
манипулируя их представлением.
\endgroup

\indexC{repeat}
В~большинстве императивных языков набор синтаксических конструкций фиксирован.
Например, в~них наверняка есть цикл \ic{while}, кое"~где есть и~\ic{until}, но
если вам нужен какой"~то особый цикл, то чаще всего вы лишены возможности
записывать его подобно другим циклам. Лисп~же вполне возможно научить понимать
\ic{(repeat :while~\ii{p} :unless~\ii{q} :do \ii{тело}...)} как

\begin{code:lisp}
(let loop ()
  (if |\ii{p}| (begin (if (not |\ii{q}|) (begin |\ii{тело}|...))
               (loop) )) )
\end{code:lisp}

\indexC{loop}
Этот пример намеренно <<расточителен>>: в~нём используются дополнительные
ключевые слова (начинающиеся с~двоеточия), хоть в~Scheme и принято
минимизировать подобный синтаксический шум. \seeEx[macros/ex:repeat] Кроме того,
данный макрос вводит локальную переменную \ic{loop}, которая может скрыть одну
из свободных переменных \ii{p}, \ii{q} или \ii{тела}. Истинным любителям циклов
стоит взглянуть на местный Эверест прогресса "--- макрос \ic{loop}, реализация
которого занимает не~одну сотню строк, а описанию его посвящена целая глава
стандарта: \cite[глава~26]{ste90}.

К~сожалению, как и множество других непростых и хитроумных концепций, макросы
легко могут стать неуправляемыми. Цель данной главы "--- осознать их недостатки
и обнаружить их преимущества. Для этого мы попытаемся логически воссоздать
макросы, чтобы добраться до корня их проблем и причин их разнообразия.


\section{Подготовка}\label{macros/sect:preparation}

\indexR{подготовка программ}
\indexR{исполнение программ}
\indexR{программы!этапы обработки}
Рассмотренные в~предыдущих главах интерпретаторы разделяют обработку программ
на две фазы: \term{подготовку} (в~терминологии {\ISLisp}) и \term{исполнение}.
Таким образом, общая схема вычислений похожа на быстрый интерпретатор
\seePage[chapter:fast]: \ic{(run (prepare \ii{выражение}))}. Нечто подобное
выполняет и компилятор \seePage[chapter:compilation], который сначала
преобразует программы в~деревья промежуточных инструкций и только по ним уже
генерирует байт"~код. Более ранние реализации тоже вполне вписываются в~эту
теорию: достаточно считать подготовку тождеством.

\indexR{макросимволы}
Сама подготовка также может быть многофазной. Например, все считываемые
выражения изначально являются лишь строками символов, и во~многих диалектах
Лиспа существует понятие макросимволов, способных влиять на процесс
синтаксического анализа этих строк и построения соответствующих S"=выражений.
Известным примером такого символа является кавычка: она означает, что следующее
считанное выражение должно быть обёрнуто в~форму \ic{quote}. Можно представить,
что внутри синтаксического анализатора кавычка вызывает выполнение выражения
\ic{(list (quote quote) (read))}.

\indexC{read}
\indexR{компиляция!фронтенд}
Если считывателем Лиспа можно управлять, то функция \ic{read} может
адаптироваться под любые нужды. Например, Bigloo \cite{sw94} при компиляции
исходных файлов, написанных на Caml~Light, просто использует соответствующую
функцию для их чтения; единственное требование к~ней "--- она должна возвращать
корректные S"=выражения. Фактически, данная функция \ic{read} является
фронтендом компилятора Caml~Light \cite{lw93}.

Мы не~будем особо касаться макросимволов, так как они всё~же являются встроенной
возможностью алгоритма чтения S"=выражений, а не~самостоятельной конструкцией.

Фаза подготовки нередко является составной частью фазы компиляции. В~любом
случае, важно чётко отделять эту фазу от следующей за ней фазы исполнения.
Помните: тесным должно быть взаимодействие компонентов, а не~зависимости между
ними. На этой почве возникают два различных варианта понимания подготовки:
\term{многомировой} и~\term{унитарный}.


\subsection{Множественные миры}\label{macros/preparation/ssect:multiple}

\indexR{подготовка программ!во множественных мирах}
\indexR{множественные миры}
\indexR{мир!множественный}
\indexR{загрузчик}
\indexR{компоновка}
В~этом случае результаты подготовки выражений сохраняются в~файлах (обычно
\ic{*.o} или~\ic{*.fasl}). Исполнять такие файлы помогает отдельное приложение
"--- загрузчик, который нередко по совместительству также занимается управлением
связями между независимо подготовленными выражениями, то есть является
компоновщиком. Большинство популярных языков программирования исповедуют именно
такую модель раздельной компиляции. Её преимуществом является возможность
обработки программ по частям, а также более естественное управление
пространствами имён с~помощью разнообразных директив экспорта и~импорта. Мы
говорим о~множественных мирах, так как подготовленные выражения "--- это
единственное средство связи между предобработчиком программ и их исполнителем.
Исходные коды программ и исполняемые программы живут в~отдельных мирах, которые
лишены возможности влиять друг на друга.
%
{\def\expr#1{\text{\ii{выражение}}_#1}%
\def\prep#1{\text{\ii{подготовленное-выражение}}_#1}%
\def\ARR{\xrightarrow{\:\text{\ic{prepare}}\:}}%
\[
    \left.\begin{array}{ccc}
        \expr 0 & \ARR & \prep 0 \\
        \expr 1 & \ARR & \prep 1 \\
        \cdots  & \ARR & \cdots  \\
        \expr n & \ARR & \prep n
    \end{array}\right\}\ic{run}
\]}


\subsection{Единый мир}\label{macros/preparation/ssect:unique}

\indexR{подготовка программ!в~едином мире}
\indexR{единый мир}
\indexR{мир!единый}
\indexR{интерактивная сессия (REPL)}
\indexE{REPL}
\indexR{интерпретатор!командный}
\indexR{командный интерпретатор}
\indexC{compile-file}
\indexC{load}
В~противоположность многомировой гипотезе, адепты секты единого мира считают
центром вселенной интерактивную сессию, поэтому все вычисления, начавшиеся
в~ней, совместно существуют в~общей памяти, где нет никаких преград для общения
посредством глобальных разделяемых ресурсов (переменных, списков свойств
{\itp}). Интерактивная сессия связывает воедино процессы чтения выражений, их
подготовки и~исполнения. Она часто предстаёт в~виде командного интерпретатора,
контролирующего данные процессы. Заметьте, уникальность мира вовсе не~означает
строгую последовательность всех происходящих процессов: вполне возможно отложить
исполнение обработанной программы на потом. Во~многих лисп-системах существует
функция \ic{compile-file}, которая считывает выражения из файла и сохраняет
результат компиляции в~другой файл. Выполнить~же подготовленные к~исполнению
программы можно потом, загрузив их с~помощью функции \ic{load} или чего"~то
подобного. Таким образом, и здесь имеется возможность подготавливать программы
по~частям.

\indexR{программы!как среда исполнения кода}
Идея единого мира отнюдь не~оторвана от реальности. Напротив, она является
взглядом на программы как на среду исполнения кода, подобную операционным
системам вроде \UNIX, где пользователь рассчитывает на некоторое внутреннее
состояние: файловую систему, всевозможные переменные окружения, псевдонимы
команд {\itd}, а управляет всем этим с~помощью командного интерпретатора
вроде \ic{bash} или~\ic{zsh}.

\indexR{подготовка программ!повторяемость}
Как~бы то ни~было, одним из основных требований к~программным системам является
предсказуемость и воспроизводимость результатов. Ожидается, что из одного и
того~же исходного кода при одинаковых условиях получается одинаковый исполнимый
код. Это базовая предпосылка, без которой невозможно нормальное использование
данной системы. Множественные независимые миры без проблем ей удовлетворяют:
достаточно проконтролировать все входные данные, а кроме них ничто больше
не~может повлиять на систему. В~случае единого мира неучтённым остаётся его
внутреннее состояние\footnote{Например, никто не~может сказать загодя, какие
переменные окружения выведет \ic{printenv}, или что написано в~конфигурационных
файлах операционной системы.} вместе со~всевозможными способами его изменения.
Такой компилятор постоянно остаётся в~памяти, понемногу накапливает вносимые
в~него изменения, и мы постепенно теряем над ним контроль.

Подводя итог, подготовка программ обязана быть полностью контролируемым
процессом.


\section{Раскрытие макросов}\label{macros/sect:expand}

\indexC{prepare}
\indexC{macroexpand}
\indexR{макросы!раскрытие}
\indexR{экспандер|see{макроэкспандер}}
\indexR{макроэкспандер}
Итак, обработка сокращений-макросов выполняется во~время подготовки программ,
перед их исполнением. Следовательно, логично будет разделить эту подготовку на
две части: 1)~\emph{раскрытие} макросов, 2)~всё остальное. То~есть выполнять её
как"~то так: \ic{(really-prepare (macroexpand \ii{выражение}))}. Нас интересует
вот эта функция-\term{экспандер} \ic{macroexpand}, отвечающая за обработку
макросов. Как именно задаётся алгоритм, который она реализует? Возможны два
способа её определения: \term{экзогенный} и~\term{эндогенный}.


\subsection{Экзогенный подход}\label{macros/expand/ssect:exo}

\indexR{макросы!раскрытие!экзогенное}
\indexR{макроэкспандер!экзогенный}
Экзогенное раскрытие, как его описывают \cite{qp91b,dps94b}, подразумевает, что
функция \ic{macroexpand} предоставляется \emph{отдельно} от раскрываемого
выражения, например, с~помощью специальных директив.\footnote*{Располагаемых,
к~примеру, в~самом начале файла.} Следовательно, функция \ic{prepare} в~общих
чертах будет выглядеть~так:

\indexCS{prepare}{экзогенная}
\begin{code:lisp}
(define (prepare expression directives)
  (let ((macroexpand (generate-macroexpand directives)))
    (really-prepare (macroexpand expression)) ) )
\end{code:lisp}

Возможны некоторые вариации этой идеи, которые мы разберём на примере
компилятора в~байт"~код. \seePage[compilation/separate/ssect:build] Предположим,
в~нашем распоряжении есть загрузчик по имени \ic{run} и компоновщик
\ic{build-application}. Кроме того, пусть имеется исполнимый файл
\ic{compile.so}, содержащий компилятор, а экспандеры будем называть
\ic{expand.so}.

Раскрытие макросов может происходить каскадом, как показано на верхней части
рисунка~\ref{macros/expand/exo/pic:subj}. В~таком случае вызов <<\ic{compile
file.scm expand.so}>> соответствует следующей командной строке \UNIX-shell:

\begin{lstlisting}
run expand.so < file.scm | run compile.so > file.so
\end{lstlisting}

\phantomlabel{macros/expand/exo/par:compiler}
\indexR{компиляция!специализация}
Также макросы может раскрывать новый, только что синтезированный компилятор
(здесь это \ic{tmp.so}), как на нижней половине
рисунка~\ref{macros/expand/exo/pic:subj}. Тогда команде <<\ic{compile file.scm
expand.so}>> соответствует

\begin{lstlisting}
build-application compile.so expand.so -o tmp.so;
run tmp.so < file.scm > file.so
\end{lstlisting}

\begin{figure}\centering
\input{figures/fig9.1}
\caption{Два варианта экзогенной компиляции. Пятиугольники обозначают исполнимые
бинарные файлы.}%
\label{macros/expand/exo/pic:subj}
\end{figure}

\indexR{подготовка программ!обмен информацией}
Среди нерешённых проблем остаётся ещё протокол обмена информацией между
экспандером и компилятором. Экспандер принимает исходную программу и возвращает
её с~раскрытыми макросами. Он может принимать её буквально как значение, или~же
как имя файла, в~котором она хранится. Аналогично, возвращать результат
экспандер может как в~виде непосредственных S"=выражений, так и записав его
в~файл и вернув имя этого файла. Обмениваться информацией посредством файлов
ничуть не~абсурдно. Компилятор того~же языка~Си в~процессе работы хранит готовые
объектные модули в~файлах. Подобный подход позволяет избежать скрытой передачи
информации, так как любое общение выполняется явно и прозрачно через файлы.
В~случае обмена информацией посредством S"=выражений, для подготовки потребуется
динамически загружать экспандер в~память с~помощью \ic{load} или чего"~то
подобного, потому как обмен информацией между программами выполняется напрямую.

\indexR{макросы!композициональность}
\indexR{композициональность!макросов}
\indexR{макроэкспандер!модульность}
Также экспандер не~обязательно должен быть монолитным, его вполне можно собрать
как конструктор из меньших блоков, обрабатывающих специфичные макросы. Для этого
потребуется расширить язык директив, чтобы он мог оперировать подобными блоками.
Ещё это означает, что макросы должны быть свободно компонуемыми, что в~свою
очередь приводит к~необходимости обеспечения ассоциативности и коммутативности
макроопределений.

\indexR{язык!макроэкспандера}
Итого, экзогенный подход подразумевает использование отдельного независимого
макроэкспандера для обработки программ. В~этом случае мы несомненно обладаем
полным контролем над процессом раскрытия макросов, а также можем быть уверены
в~том, что в~готовых программах не~останется никакого мусора после их раскрытия.
Кстати, полное отделение раскрытия макросов от исполнения программ снимает любые
ограничения на форму и реализацию экспандеров, так как абсолютно не~важно, как
они работают внутри, лишь~бы возвращали корректные S"=выражения. Вполне можно
писать экспандеры на Си++, M4, да хоть на Perl! Тем не~менее, Лисп кажется
наиболее адекватным языком для описания алгоритмов обработки S"=выражений.
Как видим, экзогенный подход не~подразумевает сколь-либо тесной связи между
языком обрабатываемых программ и языком описания макросов. Макроэкспандеру
необходимо только уметь самостоятельно определять в~обрабатываемой программе
местонахождение макросов, требующих раскрытия.


\subsection{Эндогенный подход}\label{macros/expand/ssect:endo}

\indexR{макросы!раскрытие!эндогенное}
\indexR{макроэкспандер!эндогенный}
Эндогенное раскрытие подразумевает, что вся информация, необходимая для
обработки макросов, содержится \emph{в~самой} программе. Другими словами,
подготовка программ выглядит так:

\indexCS{prepare}{эндогенная}
\begin{code:lisp}
(define (prepare expression)
  (really-prepare (macroexpand expression)) )
\end{code:lisp}

\indexC{define-macros}
\indexC{define-syntax}
\indexC{eval}
Фундаментальным отличием эндогенного подхода от экзогенного является
предопределённость алгоритма раскрытия макросов; им можно лишь управлять в~той
или иной мере. Также задача осложняется тем, что при обработке программы
требуется отыскать в~тексте не~только макросы для их раскрытия, но и сами
правила раскрытия. Эти правила обычно задаются специальными S"=выражениями,
чаще всего формами \ic{define-macros} или \ic{define-syntax}. Подобные
определения ещё предстоит превратить в~функции-экспандеры, обрабатывающие
макросы соответствующим образом. Так, стоп, это что"~то знакомое: мы динамически
превращаем исходный текст в~исполнимую программу\textdots\ точно, \ic{eval}!
В~таком подходе определённо есть нечто гениальное: не~изобретать специальный
новый язык, а использовать для описания макросов уже готовый~Лисп!

\indexE{fexpr@\protect\ic{fexpr}}
Конечно, как и любая гениальная идея, она имеет свои подводные камни. В~тёмные
времена одной из сложнейших для освоения дисциплин оккультных компьютерных
искусств была макрология.\trnote*{<<\textsc{Макрология}, \textit{сущ.,~ж.}
(букв.~\textit{многословие} или \textit{макрос} + \textit{учение})
\textbc{1.}~Набор обыкновенно сложных или хитроумных макросов, напр., как
составная часть большой программной системы, написанной на Лиспе, TECO или
(реже) ассемблере. \textbc{2.}~Искусство и~наука постижения смысла макрологий
в~значении~1 (ср.~археология, экология, теология)>> "--- The~Jargon~File.}
Фактически, именно это отождествление языков затрудняет понимание истинной
природы макросов. Долгое время они считались чем"~то вроде особых функций,
имеющих странный протокол вызова, в~соответствии с~которым вычислению подлежали
не~аргументы, а возвращаемое значение. Эта модель, несмотря на всё её удобство
при интерпретации, была отвергнута ввиду сложностей, которые она вызывает для
компиляторов, а также по иным причинам, описанным Кентом~Питманом
в~статье~\cite{pit80}. В~современном понимании, макросы "--- это правила
преобразования определённых сокращений в~соответствующие им полные конструкции
целевого языка.

\indexR{язык!макроэкспандера}
\indexE{Scheme!язык описания экспандеров}
\indexC{define-syntax}
\indexC{syntax-rules}
\indexC{define-abbreviation}
Выбор Лиспа в~качестве языка описания макросов оспаривается апологетами
ограниченного подхода, считающими, что макросы должны уметь лишь манипулировать
заранее написанным кодом, а не~создавать его сами. Именно такие макросы
реализуют \ic{define-syntax}\slash\ic{syntax-rules} из~\RnRS. Конечно, в~таком
случае они обладают несколько меньшей выразительной силой, а некоторые
преобразования не~могут описать в~принципе, но зато простые макросы (коих
большинство) становятся гораздо понятнее. Несмотря на то, что в~данной книге
более мощная форма \ic{define-abbreviation}\footnote{Столь экзотическое имя
выбрано с~целью избежать противоречивых ассоциаций с~конструкцией
\ic{define-macros}, присутствующей во~многих реализациях Лиспа и~Scheme.}
используется чаще, лишь 5~макроопределений из~порядка~50 используют её
возможности, выходящие за рамки \ic{define-syntax}. И~даже из этих пяти только
три макроса "--- фундаментальные определения {\Meroonet}: \ic{define-class},
\ic{define-generic} и~\ic{define-method}), "--- принципиально нельзя реализовать
по"~другому.

Короче говоря, не~важно, задаём~ли мы алгоритм раскрытия явно или параметризуем
готовый, в~обоих случаях Лисп кажется наиболее подходящим языком для описания
этого алгоритма. Но в~отличие от экзогенного, эндогенный экспандер должен
содержать внутри себя вычислитель; это его характерная особенность. Однако
помните, что не~следует смешивать язык описания макросов с~языком обрабатываемой
программы: они связаны, но не~тождественны. В~старых руководствах часто
писалось, что макросы реализуются с~помощью двукратных вычислений; их авторы
грешат упущением того, что эти вычисления проводятся различными вычислителями.

\begin{figure}\centering
\input{figures/fig9.2}
\caption{Экзогенное (слева) и эндогенное (справа) раскрытие макросов.}%
\label{macros/expand/endo/pic:comparison}
\end{figure}


\section{Макровызовы}\label{macros/sect:calling}

\indexR{грамматика!расширяемость}
Макроэкспандер должен отыскать в~обрабатываемой программе все макросы, требующие
раскрытия. Некоторые языки (например, \cite{car93}) имеют тонко настраиваемые
синтаксические анализаторы, позволяющие дополнять грамматику языка новыми
формами напрямую. Добавить макрос там так~же легко, как описать новый оператор:
всего пара строк с~его символом и арностью, информацией о~том, префиксный он,
инфиксный или постфиксный, плюс указание его приоритета.

\indexR{функциональный терм}
\indexR{терм!функциональный}
\indexR{макровызовы}
\indexR{вызов!макроса}
Программы на Лиспе состоят из форм, записываемых S"=выражениями, где основную
смысловую нагрузку несёт их \ic{car} "--- функциональный терм, "--- поэтому
часто применяется следующий подход: список, первый элемент которого является
ключевым словом, считается вызовом одноимённого макроса. У~такого подхода есть
множество преимуществ: он прост, расширяем и согласуется со~всем остальным
синтаксисом. Имя сокращения (макроса) ассоциируется с~функцией (экспандером).
В~итоге получается весьма простой алгоритм раскрытия макросов: рекурсивно
обходим обрабатываемое выражение в~поисках ключевых слов; если натыкаемся на
такое слово, то определяем соответствующий ему экспандер и применяем его
к~S"=выражению, требующему раскрытия. В~\ic{cdr} этого S"=выражения находится
всё, что надо экспандеру для успешной работы.

\indexR{макросимволы}
Также можно вспомнить о~макросимволах, присутствующих, например,
в~{\CommonLisp}. Они связывают вызов экспандера с~одним символом, а не~с~целой
формой. Это позволяет избавиться от излишних скобок, если макрос применяется
к~чему"~то короткому вроде имени переменной.

\indexR{пространства имён}
Таким образом, макрос можно понимать как функцию-экспандер, связанную
с~некоторым именем, приводящим к~её вызову. Похоже, для подобных привязок
потребуется собственное пространство имён. Однако помните, что макрос "--- это
не~привязка, функция или ключевое слово сами по себе, это триединая сущность
внутри макроэкспандера. Кстати, раз это всё~же пространство имён, нелишним будет
иметь возможность определять как глобальные макросы, так и локальные: например,
с~помощью \ic{define-abbreviation} и~\ic{let-abbreviation}.

\indexR{грамматика!для макроэкспандера}
\indexR{макроэкспандер}
\indexR{программы!как данные}
\indexR{значения!как программы}
Задачей функции-экспандера является превращение S"=выражения в~корректную
программу. Следовательно, она ищет макросы в~S"=выражениях, а не~программах.
Конечно, некоторые части S"=выражений действительно являются программами; да и
синтаксис вызова макросов напоминает вызов функции. Но по~сути это лишь
S"=выражения. Ничто не~запрещает экспандеру трактовать некорректную форму
\ic{(foo~.~5)} как сокращение для \ic{(vector-ref foo~5)}!

Проблема здесь в~том, что грамматика S"=выражений гораздо менее ограничена, чем
грамматика программ. Это вызывает некоторые затруднения, касающиеся приоритета
макросов над другими конструкциями. Если \ic{bar} это макрос, а \ic{lambda} нет,
то требует~ли раскрытия форма \ic{(bar~34)} в~выражении \ic{((lambda (bar)
(bar~34)) ...)}? Здесь источником проблем является локальная переменная
\ic{bar}. Должна~ли она скрывать одноимённый макрос \ic{bar}? \RnRS, к~примеру,
считает, что должна. Тот~же вопрос касается цитат: надо~ли раскрывать \ic{bar}
в~выражении \ic{(quote (bar~34))}?

Таким образом, в~алгоритм обхода S"=выражений наверняка потребуется внести
определённые доработки, дабы ограничить места, где допустимо применение
макросов. Например, можно~ли писать \ic{(let (foo) ...)}, где \ic{(foo)} "---
это макровызов, генерирующий список локальных переменных? Или, к~примеру,
\ic{(cond (foo) ...)}, или \ic{(case key (foo) ...)}? В~Лиспе правила хорошего
тона предписывают определять и использовать макросы таким образом, чтобы они
были максимально похожи на функции. Тогда не~особо важно, что именно скрывается
за \ic{(bar~...)} "--- макрос или функция.


\section{Экспандеры}\label{macros/sect:expandes}

\indexR{макроэкспандер!варианты реализации}
А~что насчёт экспандеров? Какой контракт должны соблюдать они? Есть по меньшей
мере два возможных варианта.

\indexR{макроэкспандер!классический подход}
\term{Классический} подход подразумевает, что выражения, возвращаемые
экспандером, всё ещё могут содержать нераскрытые макросы. Поэтому их необходимо
повторно прогонять через другие экспандеры до полного раскрытия. Если функция
\ic{find-expander} возвращает экспандер, соответствующий имени макроса, то
макровызов \ic{(foo~.~\ii{expr})} раскрывается следующим образом:

\indexCS{macroexpand}{классический}
\begin{code:lisp}
(macroexpand '(foo . |\ii{expr}|)) |$\leadsto$|
   |$\leadsto$| (macroexpand ((find-expander 'foo) '(foo . |\ii{expr}|)))
\end{code:lisp}

\indexE{EPS}
\indexR{макроэкспандер!EPS-подход}
Есть и другой, более сложный подход, называемый в~\cite{dfh88} <<\emph{стилем
передачи раскрытий}>> (\english{expansion passing style}, EPS) по аналогии
со~стилем передачи продолжений. Идея в~том, что экспандер обязан вернуть
полностью готовое выражение, лишённое нераскрытых макросов. Таким образом,
рекурсивные вызовы \ic{macroexpand} снаружи переносятся внутрь самих
экспандеров. Для этого, очевидно, экспандеры должны сами вызывать функцию
\ic{macroexpand}, а значит, им необходимо как"~то получить к~ней доступ. Можно
было~бы просто сделать \ic{macroexpand} глобальной, но есть более искусное
решение, которое и является сутью EPS. Можно передавать \ic{macroexpand} как
аргумент экспандерам, что одновременно решает проблему рекурсивных вызовов, а
также значительно облегчает введение локальных макроопределений. В~терминах
Лиспа это выглядит так:

\indexCS{macroexpand}{EPS}
\begin{code:lisp}
(macroexpand '(foo . |\ii{expr}|)) |$\leadsto$|
   |$\leadsto$| ((find-expander 'foo) '(foo . |\ii{expr}|) macroexpand)
\end{code:lisp}

\indexC{macrolet}
\indexC{macroexpand}
\indexR{макросы!локальные}
Эти два подхода к~раскрытию макросов "--- классический и EPS "---
не~эквивалентны. Очевидно, EPS более мощный, так как классическое раскрытие
можно выразить через EPS, но не~наоборот. Существенным отличием между
ними является способ реализации локальных макросов. Допустим, мы хотим
определить макрос, локальный для какого-либо подвыражения. В~EPS достаточно при
обработке этого подвыражения передать экспандеру расширенный вариант
\ic{macroexpand}, учитывающий новые определения. В~языках, реализующих
классический подход (в~{\CommonLisp}, к~примеру) эта задача решается сложнее:
специальный макрос \ic{macrolet} изменяет внутреннюю структуру \ic{macroexpand},
добавляя туда локальные определения, затем он выполняет раскрытие подвыражения,
после чего вновь изменяет структуру \ic{macroexpand}, убирая оттуда введённые
ранее определения. Форма \ic{macrolet} является примитивом в~том смысле, что её
невозможно определить самостоятельно, если её нет в~языке изначально. Более
того, вся система становится гораздо более хрупкой, если не~только \ic{macrolet}
позволено модифицировать \ic{macroexpand}. EPS не~ведомы эти проблемы, так как
вводимые локальные макросы всегда остаются локальными и могут свободно скрывать
и переопределять внешние. Всё зависит только от новой функции, которая будет
передана внутрь вместо \ic{macroexpand}. В~\cite{dfh88} приведено множество
примеров применения данного подхода для реализации каррирующих и трассирующих
макросов.

\indexR{преобразование!в коробочный стиль}
\indexR{коробки!преобразование}
\indexR{преобразование!локальность}
Большая часть макросов действует локально, то~есть выполняет простую замену
одного текста другим. Важным свойством EPS является возможность лёгкой
модификации текущего экспандера, что позволяет выражать некоторые трансформации
проще, чем при классическом подходе. Например, вспомните преобразование программ
в~<<коробочный стиль>>. \seePage[assignment/assignment/ssect:boxes] Это
преобразование легко реализуется с~помощью двойного обхода кода: на первом
проходе составляем список локальных изменяемых переменных, а на втором заменяем
все обращения к~ним соответствующими операции с~коробками. EPS позволяет
записать это легко и просто, буквально используя два разных экспандера: первый
ничего не~раскрывает, а только запоминает информацию для второго, который потом
выполнит всё работу. Классический~же подход и его намертво вшитый экспандер
не~позволяют такой гибкости, так что обход кода приходится реализовывать
вручную, а не~использовать уже готовую инфраструктуру.

\indexC{with-quotations-extracted}
Однако, EPS не~всемогущ; существуют трансформации, которые и ему не~по~силам.
\seePage[assignment/quotation/par:transform] Перенос цитат не~является локальным
действием, так как здесь требуется вместо цитат подставить обращения
к~глобальным переменным. C~заменой выражений проблем"~то нет, но ведь эти
переменные ещё надо создать (вставив глобальные \ic{define} в~подходящем месте),
а это мало похоже на локальные изменения! Правда, здесь можно выкрутиться,
обернув всю программу в~макрос (скажем, \ic{with-quotations-extracted}), который
раскрывается в~определения значений цитат, за которыми следует обработанная
программа.

Существуют и другие макросы, которым необходимо создавать глобальные переменные,
например, макрос \ic{define-class} в~{\Meroonet}. Синтаксис Scheme не~запрещает
его использование внутри \ic{let}-форм, но семантика данного макроса
подразумевает создание глобальной переменной, которая содержит объект,
описывающий определяемый класс. Такие задачи обычно нельзя решить, оставаясь
в~рамках макросистемы, так что \ic{define-class} вынужден быть или специальной
формой, или~же макросом, использующим внутренние (intrinsic) функции реализации
для достижения необходимого эффекта.

Однако, если EPS настолько хорош, то почему он так редко используется?
Во"~первых, его сложнее реализовать, но главная причина не~в~этом. Вспомните, что большая
часть макросов проста по своей сути, а значит, более мощный и сложный механизм
их раскрытия по сути ничего не~даст, кроме замедления работы.
В~действительности, классический подход обладает существенным преимуществом: он
однопроходен. Однажды раскрытые выражения, не~начинающиеся на ключевое слово,
больше никогда не~будут просматриваться, так как гарантированно являются
вызовами функций. EPS~же позволяет экспандерам просматривать обрабатываемое
выражение несколько раз, руководствуясь различными правилами раскрытия, что
приводит к~замедлению работы и усложнению понимания выполняемых ими
трансформаций.


\section{Приемлемость результатов~раскрытия}\label{macros/sect:accept}

\indexR{бесконечный цикл}
Одним из пунктов контракта экспандеров является требование, чтобы возвращаемый
ими результат был корректной программой, готовой для последующей предобработки.
В~программе не~должно быть нераскрытых макросов; иными словами, это должна быть
такая~же программа, как если~бы она была набрана вручную. На пути к~этой светлой
цели нас подстерегают несколько ловушек. Во-первых, раскрытие макросов "--- это
некоторые вычисления, а вычисления иногда могут никогда не~заканчиваться, что,
согласитесь, несколько мешает получению готовых программ. Загнать компилятор
в~бесконечный цикл непросто, но если вам удалось, то понимайте это как плату
за истинно неограниченные выразительные возможности макросистемы.
% доказательство тьюринг-полноты!

Один из лёгких способов попасть в~бесконечный цикл "--- попытаться наивно
определить макрос через самого себя. Как, например, в~следующем определении
макроса~\ic{while}:

\begin{code:lisp}
(define-abbreviation (while condition . body)
  `(if ,condition (begin (begin . ,body)
                         (while ,condition . ,body) )) )
\end{code:lisp}

Помните, что в~конце концов экспандер должен вернуть нормальную программу,
поэтому после первого раскрытия макроса \ic{while} он продолжит раскрывать
макросы в~получившемся коде, а там его ждёт ещё один \ic{while}, а внутри него
"--- ещё один, и~так далее.

В~{\CommonLisp} допустить аналогичную ошибку гораздо проще благодаря ключевому
слову \ic{\&whole}. С~его помощью макрос может получить исходную форму, которая
вызвала его раскрытие, но её недальновидное использование приводит к~печальным
последствиям.

\begin{code:lisp}
(defmacro while (&whole call)    |\dialect{\CommonLisp}|
  (let ((condition (cadr call))
        (body      (cddr call)))
    `(if ,condition (begin (begin . ,body) ,call)) ) )
\end{code:lisp}

\indexR{мемоизация}
\indexR{макросы!раскрытие!мемоизация}
\indexR{циклические структуры данных}
Многие интерпретаторы выполняют раскрытие макросов на лету, сразу~же после
считывания S"=выражений. При этом часто с~целью оптимизации все макровызовы
физически заменяются результатами раскрытия: это позволяет не~дёргать
макроэкспандер при каждом вызове функции, содержащей макросы. В~таком случае
предыдущий макрос \ic{while} сгенерировал~бы циклическое S"=выражение, которое,
в~принципе, будет понятно интерпретаторам, но может вызвать затруднения
у~компиляторов, так как обычно они рассчитаны на работу исключительно
с~направленными ациклическими графами (деревьями, ветви которых могут
сращиваться) \cite{que92a}. После преобразования макрос \ic{while} будет
выглядеть так:

\begin{code:lisp}
(defmacro while (&whole call)    |\dialect{\CommonLisp}|
  (let ((condition (cadr call))
        (body      (cddr call)) )
    (setf (car call) 'if)
    (setf (cdr call) `(,condition (begin (begin . ,body) ,call)))
    call ) )
\end{code:lisp}

Подобные проблемы с~циклами возможны и в~цитатах; они тоже могут вынуждать
некоторые компиляторы надолго задуматься. \seePage[assignment/sect:quotation]

\indexR{внешнее представление}
\indexC{read}
\indexR{цитаты!внешнее представление}
\indexR{макросы!золотое правило}
\indexR{золотое правило макросов}
Ещё одним источником ошибок, часто даже более опасным, чем циклы, могут быть
макросы, содержащие значения, вычисляемые во~время раскрытия. Порядочные
программисты строго соблюдают обет: никогда не~писать макросы, раскрывающиеся
в~код, который невозможно написать вручную. Такое соглашение подразумевает
наличие у~программ некоторой письменной формы. В~Scheme данная форма называется
\term{внешним представлением}; любые цитаты (и~вообще всё, что может прочитать
функция \ic{read}) обязаны записываться во~внешнем представлении.

Давайте взглянем на особо поучительный пример цитирования значения, не~имеющего
внешнего представления. Следующий макрос возвращает процитированное продолжение
собственного раскрытия:

\indexC{incredible}
\begin{code:lisp}
(define-abbreviation (incredible x)
  (call/cc (lambda (k) `(quote (,k ,x)))) )
\end{code:lisp}

\indexR{продолжения (continuations)}
И~что, по-вашему, эта тарабарщина означает? Давайте подумаем логически. Записать
результат раскрытия в~файл нельзя, так как у~продолжений нет внешнего
представления. Активировать это продолжение тоже вряд~ли получится\textdots\
Что вообще должно происходить при активации продолжения, захваченного
\emph{в~другом} процессе? Ведь это то~же самое, что во~время работы приложения
\ic{a.out} начать выполнять нечто, что делалось после вызова компилятора
<<\ic{cc~main.c}>>, результатом работы которого стало данное приложение.
Конечно, в~некотором смысле \ic{call/cc} можно считать машиной времени, но
не~буквально~же! Раз на эти вопросы нельзя дать однозначные ответы, то нам
остаётся лишь воспользоваться своим правом разработчика и объявить подобные
программы ошибочными.

Не~только продолжения приводят к~таким курьёзам. Напрямую нельзя также
записывать примитивы, замыкания, порты ввода-вывода. Всё это следует запретить;
даже если \ic{(',(lambda (y) car) x)}, или \ic{`(',car~x)}, или \ic{(f
',(current-output-port))} не~вызывают никаких проблем у~интерпретаторов.

И~напоследок, золотое правило макросов ещё раз: не~генерировать программы,
которые нельзя написать вручную.


\section{Определение макросов}\label{macros/sect:define}

\indexC{define-syntax}\indexC{let-syntax}\indexC{letrec-syntax}
\indexC{defmacro}\indexC{macrolet}
\indexC{define-abbreviation}\indexC{let-abbreviation}
Существует множество форм, определяющих глобальные и локальные макросы (об~их
области видимости мы поговорим позже, в~разделе \ref{macros/sect:scope}).
В~Scheme это \ic{define-syntax}, \ic{letrec-syntax} и~\ic{let-syntax};
в~{\CommonLisp} "--- \ic{defmacro} и~\ic{macrolet}; в~этой книге "---
\ic{define-abbreviation} и~\ic{let-abbreviation}.

Определить макрос "--- значит создать соответствующий ему экспандер и
зарегистрировать его в~качестве обработчика данного макроса. Код экспандеров
записывается на специальном макроязыке, обычно диалекте Лиспа. Теперь давайте
проанализируем, как различные миры и подходы, рассмотренные ранее, влияют на
процесс определения макросов.


\subsection{Множественные миры}\label{macros/define/ssect:multiple}

Напомним, здесь раскрытие макросов и исполнение результатов раскрытия происходят
в~отдельных, непересекающихся мирах, не~имеющих общей памяти.


\subsubsection{Эндогенный подход}\label{macros/define/multiple/sssect:endogeny}

\indexR{подготовка программ!во множественных мирах}
\indexR{множественные миры}\indexR{мир!множественный}
\indexR{макросы!раскрытие!эндогенное}
\indexR{макроэкспандер!эндогенный}
\indexR{макроопределения!как синтаксические маркеры}
Эндогенный подход подразумевает, что определение макроса (в~нашем случае это
форма \ic{define-abbreviation}) на лету переводится в~исполнимый код экспандера
с~помощью явного вычислителя, реализующего макроязык. Таким образом, ключевое
слово \ic{define-abbreviation} "--- это синтаксический маркер для обработчика,
указывающий местоположение макроопределений. Следующая программа является
наивной иллюстрацией эндогенной стратегии раскрытия макросов:

\indexC{naive-endogenous-macroexpander}
\indexC{install-macro"!}
\indexE{macros@\protect\ic{*macros*}}
\begin{code:lisp}
(define *macros* '())

(define (install-macro! name expander)
  (set! *macros* (cons (cons name expander) *macros*)) )

(define (naive-endogenous-macroexpander exps)
  (define (macro-definition? exp)
    (and (pair? exp)
         (eq? (car exp) 'define-abbreviation) ) )
  (if (pair? exps)
      (if (macro-definition? (car exps))
          (let* ((def       (car exps))
                 (name      (car (cadr def)))
                 (variables (cdr (cadr def)))
                 (body      (cddr def)) )
            (install-macro! name (macro-eval
                                  `(lambda ,variables . ,body) ))
            (naive-endogenous-macroexpander (cdr exps)) )
          (let ((exp (expand-expression (car exps) *macros*)))
            (cons exp (naive-endogenous-macroexpander (cdr exps))) ) )
      '() ) )
\end{code:lisp}

Эта функция принимает список выражений (считанный из подготавливаемого файла) и
последовательно их обрабатывает, глядя в~глобальную переменную \ic{*macros*},
которая хранит текущие объявленные макросы. Собственно раскрытие выполняется
функцией \ic{expand-expression}. Если экспандер в~процессе работы натыкается на
определение макроса, то оно тут~же обрабатывается и помещается в~\ic{*macros*}.
За~создание тела нового экспандера отвечает вычислитель \ic{macro-eval}. Он
может отличаться от обычного \ic{eval}, ведь язык описания макросов
не~обязательно совпадает с~целевым языком экспандера. Макросы и обрабатываемые
ими программы принадлежат различным, абсолютно независимым мирам. Следующий
пример отлично иллюстрирует это утверждение.

\ForLayout{display}{\vskip-0.5\baselineskip}

\indexC{fact}
\begin{code:lisp-framed}[title={\snippet{si/chap9b.scm}},label={src:chap9b.scm}]
(define (fact1 n)
  (if (= n 0) 1
      (* n (fact1 (- n 1))) ) )

(define-abbreviation (factorial n)
  (define (fact2 n)
    (if (= n 0) 1
        (* n (fact2 (- n 1))) ) )
  (if (and (integer? n) (> n 0))
      (fact2 n)
      `(fact1 ,n) ) )

(define (some-facts)
  (list (factorial 5) (factorial (+ 3 2))) )
\end{code:lisp-framed}

При эндогенном задании экспандеров нехорошо путать определения \ic{fact1} и
\ic{fact2}, так как \ic{fact1} для экспандера это всего лишь набор
S"=выражений, а не~функция; такой функции во~время раскрытия макросов вообще
не~существует. Поэтому \ic{factorial} определяет необходимый ему \ic{fact2}
самостоятельно. В~итоге, после раскрытия мы получаем следующее:

\begin{code:lisp-framed}[title={\snippet{si/chap9b.escm}}]
(define (fact1 n)
  (if (= n 0) 1
      (* n (fact1 (- n 1))) ) )

(define (some-facts)
  (list 120 (fact1 (+ 3 2))) )
\end{code:lisp-framed}

Можно было~бы сделать этот пример более запутанным, назвав \ic{fact1} и
\ic{fact2} просто \ic{fact}. Это немного затруднит восприятие кода
\ic{factorial} человеком, но не~вызовет принципиальных проблем у~экспандера, так
как различные упоминания переменной \ic{fact} чётко разделены: в~одном месте
это имя будет означать локальную переменную макроса, существующую только
во~время его раскрытия, а в~другом "--- глобальную переменную \ic{fact},
существующую во~время исполнения программы.

\indexR{макросы!раскрытие!двухпроходное}
Эндогенный подход, конечно, допускает некоторые вариации. Иногда раскрытие
выполняется в~два прохода: сначала из программы извлекаются все
макроопределения, а на~втором проходе уже выполняется раскрытие. Такой вариант
может работать неправильно, если макросам позволяется определять другие макросы,
потому что новые определения, получающиеся при раскрытии, могут быть
проигнорированы. Также здесь возникает возможность использовать макросы до их
определения в~программе, что слегка сбивает с~толку. При последовательной
обработке слева направо подобные затруднения отсутствуют в~принципе.

Другой интересной (и~весьма часто встречающейся) вариацией является реализация
\ic{define-abbreviation} как примитивного макроса.


\subsubsection{Экзогенный подход}\label{macros/define/multiple/sssect:exogeny}

\indexR{подготовка программ!во множественных мирах}
\indexR{множественные миры}\indexR{мир!множественный}
\indexR{макросы!раскрытие!экзогенное}
\indexR{макроэкспандер!экзогенный}
\indexR{макроопределения!как предопределенные макросы}
При экзогенном подходе определения макросов отделены от обрабатываемой
программы. Допустим, они могут быть отделены и друг от друга: то~есть макросы
можно независимо друг от друга определять в~разных модулях, а не~обязательно все
в~одном месте. Один из вариантов реализации такого поведения "--- специальный
макрос, который определяет макросы. Назовём его \ic{define-abbreviation}, вот
его метациклическое определение:

\indexC{define-abbreviation}
\indexC{install-macro"!}
\begin{code:lisp}
(define-abbreviation (define-abbreviation call . body)
  `(install-macro! ',(car call) (lambda ,(cdr call) . ,body)) )
\end{code:lisp}

Задачей этого макроса является установка нового определения в~макросистему.
Пусть для этой цели определена функция \ic{install-macro!}. Такой подход
несколько усложняет раскрытие макросов, так как определяются они в~одном месте,
а используются в~другом. Предположим, у~нас есть следующий модуль:

\ForLayout{display}{\vskip-0.5\baselineskip}

\indexC{fact}
\begin{code:lisp-framed}[title={\snippet{si/chap9c.scm}}]
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )

(define-abbreviation (factorial n)
  (if (and (integer? n) (> n 0))
      (fact n)
      `(fact ,n) ) )
\end{code:lisp-framed}

\noindent
После раскрытия макросов он выглядит так:

\begin{code:lisp-framed}[title={\snippet{si/chap9c.escm}}]
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )

(install-macro! 'factorial
  (lambda (n) (if (and (integer? n) (> n 0))
                  (fact n)
                  `(fact ,n) )) )
\end{code:lisp-framed}

Теперь используем макрос \ic{factorial}, определяемый этим модулем, для
раскрытия макросов в~другом модуле, где определяется функция \ic{some-facts}:

\begin{code:lisp-framed}[title={\snippet{si/chap9d.scm}}]
(define (some-facts)
  (list (factorial 5) (factorial (+ 2 3))) )
\end{code:lisp-framed}

\noindent
Мы получим следующий результат:

\begin{code:lisp-framed}[title={\snippet{si/chap9d.escm}}]
(define (some-facts)
  (list 120 (fact (+ 2 3))) )
\end{code:lisp-framed}

Первая ссылка на \ic{fact} в~макросе \ic{factorial} затруднений не~вызывает, это
очевидный вызов глобальной функции, определяемой в~этом~же модуле
\ic{si/chap9c.scm}. Второе упоминание имени \ic{fact} происходит уже в~модуле
\ic{si/chap9d.escm}. Вот и~первая проблема: переменная \ic{fact}"~то свободна
в~макросе \ic{factorial}: он на неё ссылается, но сам её ни~с~чем не~связывает,
а ведь такой переменной может и вовсе не~быть в~модуле \ic{si/chap9d.escm}!

Простое решение заключается в~подключении к~\ic{si/chap9d.scm} модуля,
содержащего нужное определение. У~нас пока есть только один подходящий модуль
"--- \ic{si/chap9c.scm}. Но если подключить его, то это приведёт к~повторному
определению макроса \ic{factorial}, которому здесь не~место. Более того, это
определение будет ещё и ошибочным, если функция \ic{install-macro!}
в~пользовательском коде означает что"~то другое или вовсе не~существует.

\indexR{библиотека!макросов}
Попробуем улучшить данное решение. Для этого необходимо разобраться
с~зависимостями, возникающими между макросами и различными библиотеками;
особенно, \emph{особенно} с~тем, на каких этапах исполнения программы они
возникают. Макросы сложны отчасти потому, что требуют хорошего понимания
последовательности всех выполняемых действий. Вернёмся к~примеру с~\ic{fact1},
\ic{fact2} и~\ic{factorial}. Во~время раскрытия макроса \ic{factorial}
экспандеру необходима функция \ic{fact2}. Результату~же раскрытия для успешной
работы необходима функция \ic{fact1}. Будем говорить, что функция \ic{fact1}
принадлежит библиотеке \term{времени исполнения} макроса \ic{factorial}, а
\ic{fact2} "--- библиотеке \term{времени раскрытия} \ic{factorial}. Эти
библиотеки полностью независимы. Действительно, библиотека времени раскрытия
нужна только во~время раскрытия, а библиотека времени исполнения "--- только
во~время исполнения кода уже раскрытого макроса.

Итак, решение сводится к~тому, что макросы и их библиотека времени раскрытия
определяются в~одном модуле: \ic{si/libexp}, а все функции библиотеки времени
исполнения "--- в~другом: \ic{si/librun}. \seeEx[macros/ex:study] На~примере
факториала, раз:

\ForLayout{display}{\vskip-0.5\baselineskip}

\begin{code:lisp-framed}[title={\snippet{si/libexp.scm}}]
(define (fact2 n)
  (if (= n 0) 1
      (* n (fact2 (- n 1))) ) )

(define-abbreviation (factorial n)
  (if (and (integer? n) (> n 0))
      (fact2 n)
      `(fact1 ,n) ) )
\end{code:lisp-framed}

\noindent и~два:

\begin{code:lisp-framed}[title={\snippet{si/librun.scm}}]
(define (fact1 n)
  (if (= n 0) 1
      (* n (fact1 (- n 1))) ) )
\end{code:lisp-framed}

Во~время предобработки директивы анализируются, и компилятор делает заметку, что
для раскрытия макроса \ic{factorial} ему потребуется загрузить библиотеку
\ic{si/libexp}, а к~готовому приложению должна быть подключена \ic{si/librun}.
Таким образом, ресурсы используются только тогда, когда они
действительно необходимы (дальнейшее развитие идеи см.~в~\cite{dps94b}). Итог
подведён на рисунке~\ref{macros/define/multiple/exogeny/pic:lib-compile}:
сначала собираются необходимые библиотеки, затем программа компилируется и
связывается с~макробиблиотекой времени исполнения, а библиотека времени
раскрытия выбрасывается за ненадобностью.

\begin{figure}[tb]
\centering
\input{figures/fig9.3}
\caption{Сборка приложения во~множественных мирах.}%
\label{macros/define/multiple/exogeny/pic:lib-compile}
\end{figure}


\subsection{Единый мир}\label{macros/define/ssect:unique}

\indexR{подготовка программ!в~едином мире}
\indexR{единый мир}\indexR{мир!единый}
После предыдущего раздела вам может показаться, что во~всём виновата
множественность миров и достаточно просто их объединить. Как~бы~не~так!

В~едином мире выражения считываются, раскрываются, подготавливаются и
исполняются в~общей памяти. Следовательно, состояние макроэкспандера
переплетается с~состоянием исполнителя кода. Если применяется эндогенный подход,
то макровычислитель (функцию \ic{macro-eval}) логично будет отождествить
с~обычным вычислителем \ic{eval} (естественно, во~всех его вариациях из восьмой
главы). \seePage[chapter:reflection] Так как мир един, то раскрываемые макросы
имеют неограниченный доступ ко~всему его содержимому. Верно и обратное, так что
здесь нет особого различия между библиотеками времени исполнения и раскрытия.
Следующий код в~едином мире ведёт себя именно так, как ожидается:

\indexC{fact}
\begin{code:lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )

(define-abbreviation (factorial n)
  (if (and (integer? n) (> n 0))
      (fact n)
      `(fact ,n) ) )
\end{code:lisp}

\indexE{tree-shaker}
Но есть и ложка дёгтя в~бочке мёда: с~таким подходом гораздо сложнее передавать
(и~продавать) программы, так как трудно, а порой и вовсе невозможно выделить
в~программе необходимые для её работы части. Следовательно, если мы хотим
передать программу кому"~то другому, то вынуждены передавать её целиком
и~полностью, чтобы ничего не~забыть. Конечно, существуют специальные анализаторы
зависимостей, называемые \term{tree-shakers}, которые могут помочь вытрясти из
программ всё ненужное. Но чаще всего, как видно из~множества примеров, доступных
в~Интернете, люди воздерживаются от включения экспортируемых макросов в~готовые
приложения: код предоставляется либо полностью раскрытым, либо~же использует
макросы только локально, внутри себя. В~любом случае конечный пользователь
оказывается лишён всей их выразительной силы.

Если вы не~доверяете алгоритмам определения зависимостей, то ничего не~остаётся,
кроме как самостоятельно выбирать, что включать в~программу, а что нет. Всего
имеется три типа ресурсов: необходимые исключительно для раскрытия макросов,
необходимые только при исполнении программ и (самое сложное) необходимые на
обеих этапах.

\indexC{compile-file}
\indexR{единый мир!разновидности}
\indexR{истинно единый мир}\indexR{мир!истинно единый}
За подготовку программ к~исполнению отвечает функция \ic{compile-file}. Единые
миры по отношению к~ней разделяются на две группы, одну из которых можно назвать
\term{истинно едиными мирами}. Предмет спора: макросы, доступные
\ic{compile-file} во~время предобработки. Кроме того, даже в~истинно едином мире
возможны разногласия, что даёт в~итоге целых три вариации исходной идеи:

\begin{enumerate}
  \item В~истинно едином мире макросы вездесущи, доступны всегда и отовсюду.
        Следовательно, компилируемый на лету модуль вполне может
        пользоваться макросами <<родителя>>. Данная ситуация показана на
        рисунке~\ref{macros/define/unique/pic:uniquely}, где макрос
        \ic{factorial}, определяемый интерактивно, используется при
        компиляции другого модуля. Вопрос: а что с~макросами, которые
        определяются внутри компилируемого модуля?
  \begin{enumerate}
      \item С~ними следует обращаться на общих началах: раз мир един, то
            они должны быть доступны внешнему коду. Создаваемые внутри
            макросы просто добавляются в~глобальное общее пространство
            макросов и остаются там после компиляции подмодуля. Этот случай
            показан на рисунке~\ref{macros/define/unique/pic:unique-endogeny}
            где \ic{(factorial~5)} возвращает~\ic{120}.

      \item \indexR{макросы!глобальные}
            В~другом случае глобальность понимается на уровне отдельных
            модулей: определяемые макросы видны только в~пределах своего
            модуля. Глобальные макросы разделяются на \emph{локально
            глобальные}, определяемые в~этом~же модуле, и
            \emph{сверхглобальные}, определяемые вне его, но видимые
            благодаря иерархической компиляции модулей. Для программы на
            рисунке~\ref{macros/define/unique/pic:unique-endogeny}
            этому случаю соответствует возвращаемая \ic{(factorial~5)}
            ошибка.
  \end{enumerate}
  \item Наконец, если мир не~истинно един, то модуль может пользоваться
        исключено самостоятельно определяемыми макросами. В~этом случае есть
        отдельное пространство макросов для интерактивной сессии и отдельные,
        персональные и изначально пустые пространства для компилируемых
        модулей. Однако, несмотря на то, что пространства макросов отделены
        друг от друга, память остаётся общей и всем макросам во~время
        раскрытия доступны глобальные разделяемые ресурсы. Например, на
        рисунке~\ref{macros/define/unique/pic:unique-endogeny} внутренний
        макрос \ic{factorial} вполне может использовать функцию \ic{fact},
        определённую в~интерактивной сессии.
\end{enumerate}

\begin{figure}\centering
\input{figures/fig9.4}
\caption{Истинно единый мир.}%
\label{macros/define/unique/pic:uniquely}
\end{figure}

\begin{figure}\centering
\input{figures/fig9.5}
\caption{Истинно единый мир с~эндогенной компиляцией.}%
\label{macros/define/unique/pic:unique-endogeny}
\end{figure}

\indexR{интерактивная сессия (REPL)}
\indexE{REPL}
После внимательного изучения рисунков \ref{macros/define/unique/pic:uniquely}
и~\ref{macros/define/unique/pic:unique-endogeny} можно прийти к~выводу, что
в~обоих случаях функция \ic{fact} определяется глобально в~интерактивной сессии,
хотя похоже, что она нужна только для раскрытия макроса \ic{factorial}. Можно
было~бы определить её локально, как это сделано в~\ic{si/chap9b.scm}.
\seePage[src:chap9b.scm]

\indexR{макрораскрытие!и вычисления}
\indexC{eval-in-abbreviation-world}
Но что если \ic{fact} пригодилась~бы не~только этому макросу? Беда в~том, что
макроэкспандер воспринимает только определения макросов. Если для раскрытия
потребуются глобальные переменные, вспомогательные функции или другие вещи, то
он просто не поймёт, о~чём идёт речь. Если во~множественных мирах при экзогенном
подходе с~этим нет вообще никаких проблем, то в~едином мире или при эндогенном
задании макросов придётся немного потрудиться. Вспомните, что сама суть этих
вариаций в~том, что во~время раскрытия макросов происходят некоторые вычисления.
Естественно, выполняемые вычисления вовсе не~обязаны быть прямо связанными
с~раскрытием макросов. В~{\CommonLisp} и некоторых реализациях Scheme существует
соответствующая форма, называемая \ic{eval-when}, способная просто вычислить
что-нибудь, не~подставляя полученный результат в~раскрываемый код. (Как обычно,
чтобы имена не~пересекались, её местный аналог будет называться по-другому:
\ic{eval-in-abbreviation-world}.)

Форма \ic{eval-in-abbreviation-world} позволяет определять вспомогательные
функции, константы, проводить любые необходимые вычисления во~время раскрытия
макросов и исключительно ради него. Фактически, эта форма явно отделяет
некоторые выражения от внешнего мира вычислений. Взгляните на
рисунок~\ref{macros/define/unique/pic:endogeny}: функция \ic{fact}, определяемая
\ic{eval-in-abbreviation-world}, гарантированно может быть использована для
раскрытия \ic{factorial} внутри определения \ic{some-facts}. Возможность
использовать \ic{factorial} \hbox{и/или} \ic{fact} по возвращении
в~интерактивную сессию зависит уже от <<герметичности>> мира макросов.

\begin{figure}\centering
\input{figures/fig9.6}
\caption{Явные эндогенные вычисления.}%
\label{macros/define/unique/pic:endogeny}
\end{figure}

Для реализации такого поведения достаточно научить макроэкспандер реагировать
всего лишь на одно ключевое слово \ic{eval-in-abbreviation-world}, вынуждающее
его отправлять \ic{cdr} этой формы соответствующему вычислителю "--- тому
самому, который в~функции \ic{naive-endogenous-macroexpander} назывался
\ic{macro-eval}.

\indexC{expand-expression}
\begin{code:lisp}
(define (expand-expression exp macroenv)
  (define (evaluation? exp)
    (and (pair? exp)
         (eq? (car exp) 'eval-in-abbreviation-world) ) )

  (define (macro-call? exp)
    (and (pair? exp) (find-expander (car exp) macroenv)) )

  (define (expand exp)
    (cond ((evaluation? exp) (macro-eval `(begin . ,(cdr exp))))
          ((macro-call? exp) (expand-macro-call exp macroenv))
          ((pair? exp)
           (let ((newcar (expand (car exp))))
             (cons newcar (expand (cdr exp))) ) )
          (else exp) ) )

  (expand exp) )
\end{code:lisp}

Функция \ic{macro-eval} "--- это именно тот вычислитель, который реализует
внутренний макроязык. Это может быть и обычная функция \ic{eval}, но
использующая чистое глобальное окружение, отдельное от того, которым пользуется
интерактивная сессия. В~таком случае и~\ic{(factorial~5)}, и~\ic{(fact~5)}
вернут ошибку.

Формы \ic{eval-in-abbreviation-world} понимаются как непосредственно исполнимые
директивы для макроэкспандера, включённые в~программу. Они, естественно,
выполняются во~время раскрытия макросов, поэтому вот так писать нельзя:

\begin{code:lisp}
(let ((x 33))
  (eval-in-abbreviation-world (display x)) )
\end{code:lisp}

\indexC{compiler-let}
\indexCS{eval-in-abbreviation-world}{локальные переменные}
Если в~процессе раскрытия макросов потребуется создавать локальные переменные,
"--- что для формы \ic{eval-in-abbreviation-world} невозможно, так как она
фактически является лишь вызовом \ic{eval} на глобальном уровне, "--- то следует
использовать форму \ic{compiler-let}, присутствующую в~\CommonLisp~I
\cite{ste84} (но не~в~\CommonLisp~II \cite{ste90}). Необходимо лишь научить
\ic{expand-expression} распознавать~её.

Во~время раскрытия макросов ещё нет никакого окружения исполнения программы.
Верно и обратное: во~время исполнения уже нет окружения раскрытия. Поэтому вот
так использовать макросы тоже нельзя:

\begin{code:lisp}
(define-abbreviation (foo ...) ...)
(apply foo ...)
\end{code:lisp}

Форма \ic{eval-in-abbreviation-world} снова позволяет определить
\ic{define-abbreviation} как элементарный макрос:

\indexC{define-abbreviation}
\begin{code:lisp}
(define-abbreviation (define-abbreviation call . body)
  `(eval-in-abbreviation-world
     (install-macro! ',(car call) (lambda ,(cdr call) . ,body))
     #t ) )
\end{code:lisp}

Главной особенностью данного определения является возможность размещать
макроопределения где угодно, а не~только на глобальном уровне. Следовательно,
такая программа вполне допустима:

\begin{code:lisp}
(begin (define-abbreviation (foo x) ...)
       (bar (foo 34)) )
\end{code:lisp}

Хотя, конечно, чересчур сильная зависимость от порядка раскрытия макросов
считается плохим вкусом, равно как и извращения вроде

\begin{code:lisp}
(if (bar) (begin (define-abbreviation (foo x) ...)
                 (hux) )
          (foo 35) )
\end{code:lisp}

\indexR{макроопределения!глобальные}
Большинство макросистем отличают макросы, объявляемые глобально, от других,
подобно тому, как глобальные формы \ic{define} отличаются от внутренних. Также
глобальные макроопределения гарантированно обрабатываются последовательно сверху
вниз. Это позволяет, например, сначала определить класс, а только потом его
наследников.

\indexR{уровни интерпретации}
\indexR{интерпретация!уровневая}
Стоит отметить, что в~предыдущих примерах возможны определённые нестыковки,
касающиеся вычислителей, обрабатывающих выражения. Если эти вычислители
различны, то у~них могут возникнуть проблемы с~ошибочным использованием
структур данных друг друга, подобные тем, которые имеются у~рефлексивных
интерпретаторов. \seePage[chapter:reflection] Форма \ic{install-macro!} из
определения \ic{define-abbreviation} обрабатывается \ic{macro-eval}, она
должна изменить текущий набора макросов, доступных \ic{find-expander}. Но ведь
функция \ic{find-expander} будет вызываться \ic{eval}, а не~\ic{macro-eval}!
Ладно, оставим эти затруднения с~совместимостью на потом.

\bigskip

\phantomlabel{macros/define/unique/par:apply-foo}
\indexR{макросы!применения}
Одной из весьма полезных возможностей \ic{eval-in-abbreviation-world} является
создание глобальных переменных для макроэкспандера. Часто макросы применяются
для того, чтобы абстрагироваться от некоторых особенностей реализации. Например,
в~старых версиях Scheme функция \ic{apply} была бинарной, а не~$n$"~арной, как
сейчас. Легко представить макрос, который~бы раскрывался тем или иным образом,
чтобы скрыть данное различие. Помимо исправления уже существующих недостатков,
макросы можно использовать и для предотвращения новых проблем, заранее выполняя
раскрытие правильным образом. Так часто поступают в~сложных системах вроде
{\Meroon} для обеспечения переносимости. Очевидно, в~обоих случаях необходимо
иметь в~распоряжении этот самый список особенностей реализации, куда можно
подглядывать во~время раскрытия макросов на предмет интересующих деталей.
Например, как"~то так:

\indexC{apply}
\begin{code:lisp}
(define-abbreviation (apply-foo x y z)
  (if (memq 'binary-apply *features*)
      `(apply foo (cons x (cons y z)))
      `(apply foo x y z) ) )
\end{code:lisp}

Переменная \ic{*features*} должна быть доступна экспандеру. Легче всего её
создать с~помощью \ic{eval-in-abbreviation-world}, передав ей соответствующую
форму \ic{define}. Эта форма будет вычислена на глобальном уровне в~мире
макросов, что приведёт к~созданию необходимой переменной. Это может делаться,
например, в~каком-нибудь автоматически загружаемом конфигурационном файле:

\begin{code:lisp}
(eval-in-abbreviation-world
  (define *features* '(31bit-fixnum binary-apply)) )
\end{code:lisp}


\subsection{Совместные вычисления}\label{macros/define/ssect:simult}

\indexR{интерактивная сессия (REPL)}
\indexE{REPL}
\indexR{макроэкспандер!варианты реализации}
Ещё одной часто реализуемой вариацией единого мира является одновременное
выполнение предобработки и вычислений. Выражения считываются, раскрываются и
незамедлительно вычисляются. В~коде это выглядит так:

\indexCS{macroexpand}{параллельный}
\begin{code:lisp}
(define (simultaneous-eval-macroexpander exps)
  (define (macro-definition? exp)
    (and (pair? exp)
         (eq? (car exp) 'define-abbreviation) ) )

  (if (pair? exps)
      (if (macro-definition? (car exps))
          (let* ((def       (car exps))
                 (name      (car (cadr def)))
                 (variables (cdr (cadr def)))
                 (body      (cddr def)) )
            (install-macro!
             name (macro-eval `(lambda ,variables . ,body)) )
            (simultaneous-eval-macroexpander (cdr exp)) )
          (let ((e (expand-expression (car exps) *macros*)))
            (eval e)
            (cons e (simultaneous-eval-macroexpander (cdr exps))) ) )
      '() ) )
\end{code:lisp}

Обратите внимание на вычислители: \ic{eval} отвечает за вычисление готовых
выражений целевого языка, а \ic{macro-eval} за вычисление выражений макроязыка.
Они разделены, так как выполняют различную работу на различных этапах.


\subsection{Переопределение макросов}\label{macros/define/ssect:redefinition}

\indexR{макросы!переопределение}
\indexR{переопределение!макросов}
\indexR{гиперстатическое окружение}
\indexR{глобальное окружение!гиперстатическое}
\indexR{окружение!глобальное!гиперстатическое}
\indexR{ленивые вычисления}
Восклицательный знак в~имени функции \ic{install-macro!} подразумевает
возможность переопределения макросов: если состояние макроэкспандера можно
модифицировать, добавляя новые макросы, то точно таким~же путём можно изменять
определения уже существующих. Это может оказаться полезным, например, при
отладке с~помощью интерпретатора: определяем функцию, тестирующую отлаживаемый
макрос, а затем вызываем её после каждого исправления. Но чтобы такой подход
сработал, интерпретатор должен честно раскрывать макросы в~последний момент,
непосредственно перед вызовом функции. Однако чаще всего макросы раскрываются
лишь один раз в~самом начале, строго разделяя процессы раскрытия и исполнения.
Очевидно, что однажды раскрытый макрос больше не~зависит от своего определения.
Изменив определение, мы повлияем лишь на дальнейшие раскрытия этого макроса.
Таким образом, можно сказать, что определения макросов \emph{гиперстатичны}.
\seePage[lisp1-2-omega/recusion/simple/par:hyperstatic]


\subsection{Итоговое сравнение}\label{macros/define/ssect:comparison}

\indexR{макросы!проблемы}
\indexR{мир!сравнение вариантов}
\indexR{макросы!раскрытие}
Одна из главных проблем с~макросами состоит в~том, что нельзя просто так взять
и изменить макросистему, предоставляемую реализацией. Вероятно, подобное
ограничение на свободу экспериментирования отчасти ответственно за современную
ситуацию с~макросами в~Лиспе и~Scheme.

Системы с~множественными мирами и экзогенными макроопределениями, кажется, более
точно выражают идею, но они довольно слабо распространены. Эндогенный подход
во~множественных мирах есть лишь частный случай экзогенного, где вне
обрабатываемой программы определяются примитивы вроде \ic{define-abbreviation}
{\itd}, с~помощью которых реализуются пользовательские макросы. Наконец, единые
миры являются наиболее распространённым вариантом, хотя и вызывают определённые
затруднения с~передачей готового программного обеспечения. Данное сравнение,
однако, слегка поверхностно, так как не~учитывает двух важных аспектов:
компиляции макросов и определения макросов с~помощью макросов. О~них мы сейчас
и~поговорим.


\subsubsection{Компиляция макросов}%
\label{macros/define/comparison/sssect:compiling}

\indexR{компиляция!специализация}
\indexR{макросы!компиляция}
\indexR{компиляция!макросов}
До сих пор мы неявно предполагали, что раскрытием макросов занимается
интерпретатор. Очевидно, это сказывается на производительности, особенно если
экспандер выполняет сложные вычисления (что редко, но бывает). Множественные
миры и экзогенное определение макросов \seePage[macros/expand/exo/par:compiler]
позволяют на лету сгенерировать специализированный компилятор, понимающий все
необходимые макросы, что должно благотворно сказаться на быстродействии. При
эндогенном подходе к~описанию макросов одним из решений может быть создание
компилирующего аналога функции \ic{macro-eval}. В~едином мире для этого
предназначена пара функций \ic{compile-file} и~\ic{load}. Вся проблема в~том,
как скомпилировать \emph{определения} макросов.

\indexR{макроопределения!как синтаксические маркеры}
\indexR{уровни интерпретации}
\indexR{интерпретация!уровневая}
Это отнюдь не~тривиальная задача! Наши текущие экспандеры просматривают
раскрываемые выражения на предмет форм \ic{define-abbreviation} и определяют
соответствующие макросы на лету. Но теперь, при компиляции, они должны не~только
запомнить определения где"~то у~себя внутри, но и оставить в~программе нечто,
описывающее просмотренные определения. Если \ic{define-abbreviation} является на
самом деле макросом, раскрывающимся в~форму \ic{install-macro!}, то исполняемая
программа сама всё сделает. Если~же \ic{define-abbreviation} и компания "--- это
лишь синтаксические маркеры для экспандера, то всё придётся делать компилятору:
откомпилировать тело макроса в~функцию-экспандер, которая будет динамически
вычислять, загружать и исполнять результаты раскрытия. Однако, при таком подходе
возникают некоторые неоднозначности: к~примеру, как тогда понимать
\ic{(eval-in-abbreviation-world (load~file))}? Очевидно, здесь имеется в~виду,
что \emph{компилятор} должен динамически загрузить файл. Но функция \ic{load}
"--- это~же обёртка над \ic{eval}, что подразумевает динамические вычисления,
вычисления во~время исполнения программы. Та~же самая ситуация возникает и при
явном обращении к~\ic{eval}: \ic{(eval-in-abbreviation-world (eval
'(define-abbreviation ...)))}. В~обоих случаях вместо \ic{eval} должна
вызываться \ic{macro-eval}, чтобы эти выражения имели смысл, так как
\emph{исполняемой программой} сейчас является сам компилятор. Таким образом,
в~макромире действительно используется собственный язык с~собственной \ic{eval},
которая идентична \ic{macro-eval} целевого языка.

\indexR{макроопределения!как предопределенные макросы}
\indexR{макросы!как полноценные объекты}
\indexR{полноценные объекты!макросы}
Всё это наталкивает нас на мысль, что для определения макросов необходимо
использовать другие макросы, а не~просто синтаксические маркеры, на которые
реагирует экспандер-препроцессор. Если макросы требуется сохранять
в~обработанных программах, то они вынуждены будут стать полноценными объектами
целевого языка. В~таком случае анализ определений макросов и установка
обработанных определений в~макроэкспандер тоже должны быть разделены, так как
они принадлежат различным мирам. Чуть позже мы рассмотрим этот вопрос подробнее.
\seePage[macros/sect:eval-and-expand]


\subsubsection{Макросы, определяющие~макросы}%
\label{macros/define/comparison/sssect:defining}

\indexR{макросы!применения}
Время от времени бывает удобным определить макрос, который~бы создавал другие
макросы. \seePage[macros/usage/par:inline] Это не~бред, а вполне естественное
желание максимально полно использовать выразительные возможности,
предоставляемые макросами. Например, пусть мы разрабатываем объектную систему.
Логичным будет дать пользователю возможность создать класс \ic{Point} таким
образом, чтобы его аксессоры \ic{Point-x} и \ic{Point-y} были на самом деле
макросами, а не~функциями. \seePage[objects/def-class/par:accessors] В~таком
случае форма \ic{define-class} вынуждена будет сама создать эти новые макросы.

Рассмотрим для примера макрос \ic{define-alias}, делающий свой первый аргумент
тождественным второму. Вот два эквивалентных варианта его реализации:

\indexC{define-alias}
\begin{code:lisp}
(define-abbreviation (define-alias newname oldname)
  `(define-abbreviation (,newname . parameters)
     `(,',oldname . ,parameters) ) )

(define-abbreviation (define-alias newname oldname)
  `(define-abbreviation (,newname . parameters)
     (cons ',oldname parameters) ) )
\end{code:lisp}

\indexR{макроопределения!как синтаксические маркеры}
\indexR{макроопределения!как предопределенные макросы}
И~снова, если \ic{define-abbreviation} это макрос, то при рекурсивном раскрытии
определения \ic{define-alias} макроэкспандер раскроет и вложенное определение.
А~вот если~бы \ic{define-abbreviation} была синтаксическим маркером, то не~факт:
вдруг макроэкспандер выполняет работу за два прохода и на втором его уже
не~интересуют всякие маркеры, он только раскрывает макросы, а на всё остальное
даже не~смотрит. Таким образом, далее мы будем считать \ic{define-abbreviation}
именно предопределённым макросом; скорее даже примитивным, так как его нельзя
определить, не~будь он изначально встроен в~реализацию.


\section{Область~видимости макросов}\label{macros/sect:scope}

\indexR{область видимости!макроопределений}
\indexE{Meroon@\protect\MeroonMeroonet!типы макросов}
\indexR{макросы!области видимости}
Если область видимости локальных макросов, определяемых формами наподобие
\ic{let-syntax} и~\ic{letrec-syntax}, вполне очевидна, то вот определения
\ic{define-syntax} не~настолько однозначны, потому что глобальные макросы можно
использовать по-разному. Рассмотрим возможные варианты подробнее на примере
{\Meroon} "--- переносимой объектной системы для Scheme, допускающей как
интерпретацию, так и~компиляцию. Ядро {\Meroon} называется {\Meroonet}.
(См.~одиннадцатую главу.) В~этой системе используются три типа макросов:

\begin{enumerate}
  \item \textbf{Случайные макросы.} Такие макросы определяются, тут~же
        используются, а дальше их можно выбросить. В~принципе, для них
        прекрасно подходят формы \ic{let-syntax} или \ic{macrolet}, если,
        конечно, они поддерживаются реализацией. В~качестве примера
        возьмём функцию \ic{make-fix-maker} из {\Meroonet}. Она создаёт
        <<треугольник>> замыканий вида \ic{(lambda (a~b c ...) (vector
        cn a b c~...))}, но её определение записано вручную.
        \seePage[objects/accomp/maker/src:fix-maker]
        А~можно было~бы написать для этого специальный макрос:

\begin{code:lisp}
(define-abbreviation (generate-vector-of-fix-makers n)
  (let* ((numbers (iota 0 n))
         (variables (map (lambda (i) (gensym)) numbers)) )
    `(case size
       ,@(map (lambda (i)
                (let ((vars (list-tail variables (- n i))))
                  `((,i) (lambda ,vars (vector cn . ,vars))) ) )
              numbers )
       (else #f) ) ) )
\end{code:lisp}

        \noindent
        Здесь важно то, что подобные макросы <<одноразовые>>. У~них
        очень ограниченная область видимости: в~любом случае не~шире
        модуля, где они определены.

  \item \textbf{Локальные макросы.} Исходный код {\Meroon} разделён на
        25~небольших файлов. Естественно, внутри этих файлов используется
        некоторое количество макросов для собственных нужд, например,
        \ic{when}. Область видимости этих макросов должна быть ограничена
        исключительно файлами {\Meroon}. Макросы, локальные для объектной
        системы, не~имеют права загрязнять внешний~мир.

  \item \textbf{Экспортируемые макросы.} {\Meroon} экспортирует три~своих
        макроса: \ic{define-class}, \ic{define-generic} и~\ic{define-method}.
        Эти макросы существуют в~первую очередь для пользователей {\Meroon},
        но и для самой системы они тоже могут быть полезны. Очевидно,
        макросы вроде \ic{when} запрещено использовать в~макросах третьего
        типа, так как иначе \ic{when} выйдет за пределы своей
        системно-локальной области видимости. Целевой язык экспортируемых
        макросов "--- это язык пользователя, а не~{\Meroon}.
\end{enumerate}

\indexR{библиотека!макросов}
Существует не~только три~типа макросов, но и три~способа их использования,
показанные на рисунке~\ref{macros/scope/pic:usage}.

\begin{enumerate}
  \item \textbf{Для компиляции \Meroon.} Для этого необходимо раскрыть
        все макросы, присутствующие в~исходном коде системы. Естественно,
        после этого не~остаётся ни~одного макровызова, что снимает все
        проблемы. Но от макросов третьего типа должно оставаться нечто,
        что позволяет их использовать снаружи, ведь они всё~же
        экспортируются.

  \item \textbf{Для компиляции программ, использующих \Meroon.} В~таком
        случае достаточно раскрыть лишь макросы {\Meroon} третьего типа,
        встречающиеся в~пользовательском коде.

        Очевидно, что для этого в~экспандер компилятора необходимо
        установить соответствующие определения. Иными словами, подключить
        библиотеку времени раскрытия макросов {\Meroon} третьего типа.
        Заметьте, что библиотеки для макросов второго и первого типов при
        этом не~нужны.

  \item \textbf{Для создания интерпретатора с~поддержкой \Meroon.}
        Получаемая интерактивная сессия должна быть способна на лету
        раскрывать макросы {\Meroon} третьего типа. Соответственно, эти
        макросы вместе со~своей библиотекой времени раскрытия должны
        быть подключены к~макроэкспандеру самого интерпретатора.
\end{enumerate}

% Жутко кривой хак, чтобы разрешить вылет текста на иллюстрации
% за поля, но чего только не сделаешь ради красивой вёрстки.
\begin{figure}\centering
\hbox{\hskip+1.0em\hbox{\hskip-2.0em\input{figures/fig9.7}}}
\caption{Варианты использования макросов.}
\label{macros/scope/pic:usage}
\end{figure}

\indexR{раскрутка (bootstrapping)}
На~рисунке~\ref{macros/scope/pic:bootstrap} показан один из способов сборки
модулей {\Meroon}, известный как \term{раскрутка} (bootstrapping). Библиотека
раскрытия макросов второго типа собирается исключительно как вспомогательная
при сборке остальной части объектной системы. Всё это напоминает так называемые
T"~диаграммы \cite{es70}, отображающие связи между языками реализации,
реализуемыми языками и целевыми языками применительно к~процессу компиляции.

\begin{figure}\centering
\input{figures/fig9.8}
\caption{Раскрутка \protect\Meroon.}
\label{macros/scope/pic:bootstrap}
\end{figure}

\indexR{множественные миры!как области видимости}
\indexR{область видимости!пакеты}
\indexR{пространства имён}
\indexR{пакеты}
После рассмотрения различных типов макросов и вариантов их использования можно
сделать вывод, что для подобных систем отлично подходит идея множественных
миров, так как в~едином мире обычно отсутствуют ограничения на область
видимости. Одним из способов организации макросов являются \term{пакеты} (как,
например, в~{\CommonLisp} или ILOG~Talk). Внутренние макросы можно просто
собрать в~пакет, получив таким образом для них отдельное пространство имён,
которое не~будет пересекаться с~пользовательскими. В~едином~же мире все три
типа макросов, которые мы так тщательно разделяли, оказываются сваленными в~одну
кучу.

\indexC{define-meroonet-macro}
{\Meroonet}, ядро объектной системы {\Meroon}, рассматривается подробнее
в~одиннадцатой главе. Она определяет всего три макроса, но сама их при этом
не~использует, избегая таким образом вышеупомянутых проблем. Данные макросы
относятся к~третьему типу по нашей классификации и определяются с~помощью
специального макроса \ic{define-meroonet-macro}. Сделано так потому, что
экспортируемые макросы связаны с~пользовательской макросистемой, от~которой
{\Meroonet} следует абстрагироваться. Нельзя ожидать, что ей будет доступна
функция \ic{install-macro!} или что-либо другое, поэтому она вводит интерфейс
в~виде макроса \ic{define-meroonet-macro}, который должен быть реализован
с~помощью примитивов конкретной макросистемы. Допустим, таким примитивом
является \ic{define-abbreviation}. Учитывая требование экспортируемости макросов
"--- возможности использовать их как в~модуле, где они определяются, так и
в~модулях, которые динамически загрузят модуль с~определениями, "---
\ic{define-meroonet-macro} можно реализовать следующим образом:

\begin{code:lisp}
(define-abbreviation (define-meroonet-macro call . body)
  `(begin (define-abbreviation ,call . ,body)
          (eval '(define-abbreviation ,call . ,body)) ) )
\end{code:lisp}


\section{Вычисления и~макрораскрытие}\label{macros/sect:eval-and-expand}

\indexR{интерактивная сессия (REPL)!макрораскрытие}
\indexE{REPL!макрораскрытие}
\indexR{макрораскрытие!в интерактивной сессии}
В~интерактивной сессии раскрытие макросов и вычисление выражений очень тесно
связаны друг с~другом, за раскрытием всегда следует вычисление. В~данном разделе
мы внимательнее присмотримся к~этой неразлучной~паре.

\indexR{язык!чистый (без макросов)}
Макрораскрытие "--- это первый этап подготовки программы к~исполнению. После
подготовки можно вычислять выражения, составляющие программу. Функция \ic{eval}
занимается исключительно вычислениями, она знает только чистый язык, лишённый
всяких макросов. Для динамического вычисления выражений, содержащих макросы, их
необходимо явно пропускать через экспандер перед передачей \ic{eval}.
Соответственно, вполне возможен вариант, когда в~сессии одновременно существуют
два независимых макроэкспандера. Правда, такая практика обладает сомнительной
полезностью; обычно всё~же в~пределах одного языка есть только один вычислитель
и один макроэкспандер, так как иначе возникли~бы определённые трудности
со~стандартными макросами вроде \ic{cond}, \ic{let} или~\ic{case}. Поэтому
обычно \ic{eval} на самом деле является чем"~то вроде \ic{(lambda (e) (pure-eval
(macroexpand e *macros*)))}, где \ic{pure-eval} "--- это настоящий вычислитель
чистого языка, \ic{macroexpand} "--- явная функция-макро\-экспандер, а
\ic{*macros*} "--- текущий список макросов, известных интерпретатору.

\indexR{динамические вычисления!и~макросы}
Сказанное сейчас про \ic{eval} в~равной мере касается и \ic{macro-eval}: у~неё
тоже есть своя переменная \ic{*macros*}, которая хранит макросы, необходимые
во~время подготовки. Вопросов эта пара из вычислителя и экспандера вызывает
немало. Например, вспомним \seePage[reflection/sect:eval-as-spec-form]
о~существовании \ic{eval/ce}, которая позволяет проводить вычисления в~текущем
окружении. Эта специальная форма захватывает всё видимое ей лексическое
окружение. По~идее, \ic{eval/ce} должна уметь обращаться с~выражениями,
содержащими макросы, но значит~ли это, что она захватывает окружающие её
макроопределения? Другими словами, если написать

\begin{code:lisp}
(let-syntax ((foo ...))
  (eval/ce (read)) )
\end{code:lisp}

\noindent
то раскроет~ли \ic{eval/ce} макровызовы \ic{foo} в~считанном выражении? Если да,
то она должна сохранять не~только весь лексический контекст, но также и
макроконтекст "--- полное состояние макроэкспандера; только так \ic{eval/ce}
сможет корректно раскрыть~\ic{foo}. Поскольку подобные приёмы серьёзно нарушает
принцип независимости процессов раскрытия и исполнения, они считаются плохим
стилем. Вообще говоря, \ic{eval} тоже по-хорошему должна быть чистой и
не~вызывать всяческих раскрытий, когда её не~просят, но это неудобно,
непрактично {\itd}, {\itp}

После определения макроса его можно использовать при последующих раскрытиях.
Предположим, ранее мы определили весьма полезный макрос \ic{when}. Будет~ли
работать следующее определение?

\begin{code:lisp}
(define-abbreviation (whenever condition . action)
  (when condition (display '(whenever is called)))
  `(when ,condition . ,action) )
\end{code:lisp}

В~этом макросе \ic{when} используется дважды. Второй раз приходится на результат
раскрытия, так что здесь проблем нет. Но вот в~первый раз \ic{when} используется
во~время раскрытия определения макроса, то~есть когда вычислениями занимается
совершенно другой вычислитель, который может вообще не~знать про \ic{when}: ведь
макросы"~то сейчас раскрываются в~обрабатываемой программе, а
не~в~макроопределениях! Макрос \ic{when}, доступный в~том числе во~время самого
процесса раскрытия, должен определяться вот~так:

\begin{code:lisp}
(eval-in-abbreviation-world
  (define-abbreviation (when condition . body)
    `(if ,condition (begin . ,body)) ) )
\end{code:lisp}

Похожая ситуация возникает и в~выражении

\begin{code:lisp}
(define-abbreviation (foo)
  (define-abbreviation (bar)
    (when ...)
    (wrek) )
  (hux) )
\end{code:lisp}

\indexR{бесконечная регрессия}
\indexR{прагматика}
\noindent
{\def\CPP{Си$+$$+$}%
Здесь внутреннее определение \ic{bar} вводится для расширения макроязыка, а
не~пользовательского. Макрос \ic{bar} определяется, чтобы облегчить запись
определения другого макроса. Однако, даже если семантика данного выражения
сомнений не~вызывает, то его прагматика\trnote{Прагматика "--- понятие лингвистики:
смысл выражения, определяемый его контекстом. Для языков программирования таким
контекстом является компьютер, исполняющий программы. То есть прагматика "---
это принципы реализации языка для конкретных вычислительных машин, тогда как
семантика "--- это просто абстрактный смысл выражений языка.} слегка неясна,
так как здесь образуется своеобразный порочный круг. Ведь различными могут быть
не~только целевой и макроязыки, но и язык для описания описаний макросов может
отличаться от макроязыка, и~так~далее. Другими словами, нельзя быть уверенным
в~том, что форма \ic{when} в~описании внутреннего макроса \ic{bar} будет понята
верно. Если взять действительно различные языки, проблема станет более явной.
Например, макросы в~программах на~{\CPP} раскрываются препроцессором~{\CPP}.
Представьте, что эти макроопределения генерируются программой на~Perl. Очевидно,
что она должна возвращать эти определения именно на~{\CPP}, так как программа
на~Perl для компилятора {\CPP} "--- это одна большая синтаксическая ошибка,
несмотря на то, что в~ней и есть некий подразумеваемый смысл с~точки
зрения~Perl.}

\indexR{уровни интерпретации}
И~что~же делать? Одним из вариантов является строгое следование семантике "---
то~есть поддержка всех используемых языков. К~счастью, их редко когда требуется
больше двух. Но~тогда возникают проблемы многоуровневой интерпретации,
рассмотренные ранее на примере рефлексивных интерпретаторов.
\seePage[reflection/sect:reflective-interpreter]

Ещё одна возможность заключается в~объединении всех языков, используемых
макроэкспандером. То~есть при раскрытии макросов все вычисления выполняются
в~едином мире с~одним"=единственным языком описания макросов. Но тогда все наши
усилия по разделению языков провалятся в~тартарары.

Третьим вариантом "--- именно его использует {\RnRS} "--- будет ограничение
языка описания макросов. Если его выразительные возможности сводятся лишь
к~перестановкам и повторениям уже написанных конструкций целевого языка, то
такие макросы не~смогут создавать другие макросы и исходная проблема
не~возникает в~принципе.

\indexR{продолжения (continuations)}
Короче говоря, снова мы приходим к~тому, что очень важно различать используемые
языки и стараться их не~смешивать. Если используемая реализация Scheme
поддерживает многопоточность и распределённые вычисления, то отсюда вовсе
не~следует, что её макроэкспандер тоже это умеет. Например, если в~макромире
есть продолжения, то они не~обязательно ведут себя так~же, как и в~Scheme.
Не~надо, дорвавшись до них, тут~же бежать показывать своё мастерство с~помощью
чего"~то подобного:

\begin{code:lisp}
(define-abbreviation (foo x)
  (call/cc (lambda (k)
             (set! the-k k)
             x )) )
(define-abbreviation (bar y)
  (the-k y) )
\end{code:lisp}


\section{Применения макросов}\label{macros/sect:usage}

\indexR{макросы!применения}
В~данном разделе рассматриваются типичные варианты использования макросов.
Предназначением макросов является, конечно~же, преобразование программ, но
существует множество причин, по которым эти преобразования выполняются. Среди
них можно выделить следующие:

\begin{itemize}
  \item \emph{Сокращение} объёма набираемого кода (особенно во~время
        интерактивной работы или отладки). Если мы хотим писать \ic{(trace
        foo)}, чтобы получать в~дальнейшем сообщения обо~всех вызовах
        функции \ic{foo}, то здесь потребуется макрос, дабы значение
        \ic{foo} не~вычислялось при подобном вызове.

  \item \emph{Облагораживание} кода для сокрытия некрасивого синтаксиса.
        Например, использование \ic{bind-exit} вместо \ic{call/ep}, чтобы
        не~писать каждый раз эту надоедливую~\ic{lambda}.

  \item \emph{Абстрагирование}, позволяющее скрывать детали реализации,
        "--- главная задача макросов. Не~следует выставлять напоказ то,
        что может в~скором времени измениться, или нечто личное, куда
        не~должны совать свой нос посторонние. Примерами могут быть
        \ic{define-class} {\Meroonet} или \ic{syntax-rules} Scheme.
\end{itemize}

Отдельно стоит упомянуть ещё один важный подвид макросов, использующихся для
обеспечения переносимости. Вроде упомянутого ранее \ic{apply-foo}
\seePage[macros/define/unique/par:apply-foo], который был применён для скрытия
истинной арности \ic{apply}. Или, например, другая проблема: до \RnRS[4] пустой
список \ic{()} не~обязательно имел булево значение~\ic{\#t}. Ожидаемое поведение
можно обеспечить, используя везде специальный макрос, скажем, \ic{meroon-if},
который определяется следующим образом:

\begin{code:lisp}
(define-abbreviation (meroon-if condition consequent . alternant)
  `(if (let ((tmp ,condition))
         (or tmp (null? tmp)) )
      ,consequent . ,alternant ) )
\end{code:lisp}

Естественно, подобных уловок можно избежать, если изначально правильно писать
программы. Но, увы, не~все программы хорошо написаны, а среди <<плохих>> вполне
могут оказаться и весьма полезные. Подобные макросы являются одним из способов
быстрого портирования необходимого программного обеспечения.

\phantomlabel{macros/usage/par:inline}
\indexR{инлайнинг}
\indexR{встраивание}
Ещё одним применением макросов является гарантирование некоторых оптимизаций
независимо от используемого компилятора. Одной из таких оптимизаций является
\term{инлайнинг} "--- прямая подстановка кода функций вместо их вызова.
Некоторые реализации предоставляют специальные директивы для этого, но так как
подобный способ не~является переносимым, а также не~всегда позволяет
использовать подобные функции вне модуля, где они определены, нам остаётся
лишь реализовать всё самостоятельно. Для этого достаточно связать необходимую
функцию с~одноимённым макросом:

\begin{code:lisp}
(define-abbreviation (define-inline call . body)
  (let ((name      (car call))
        (variables (cdr call)) )
    `(begin
       (define-abbreviation (,name . arguments)
         (cons (cons 'lambda (cons ',variables ',body))
               arguments ) )
       (define ,call (,name . ,variables)) ) ) )
\end{code:lisp}

\indexR{функции!встраиваемые!рекурсия}
Правда, этот макрос тоже не~абсолютно переносим, так как в~некоторых диалектах
запрещено одновременно иметь макрос и функцию с~одинаковым именем. Другие
диалекты более снисходительны, но в~них второе определение (функция) полностью
заменит первое (макрос), так что никакого инлайнинга не~будет. Кроме того,
при таком подходе чрезвычайно сложно создать рекурсивную встраиваемую функцию,
не~зациклив при этом макроэкспандер (хотя некоторые с~этим не~согласны,
см.~\cite{bak92b}). Наконец, стоит избегать использования встраиваемых функций
как значений (например, не~передавать их в~\ic{apply}), потому как это позволит
компилятору вообще не~создавать соответствующую полноценную функцию.

Во~множественных мирах данный макрос работает прекрасно. Макроэкспандер
раскрывает все вызовы определённой таким образом функции, являющиеся на самом
деле макровызовами одноимённого макроса. Вместо них экспандер подставляет код
функции (в~том числе в~форме \ic{define}, которая определяет <<настоящую>>
функцию). В~результате, после раскрытия макросов все прямые вызовы функции
оказываются заменены кодом, а остальные упоминания имени являются обычными
ссылками на обычную функцию "--- как раз это нам и~надо.


\subsection{Иные качества}\label{macros/usage/ssect:other}

\indexE{Scheme!качества макросов}
Макросы Scheme стандарта {\RnRS} имеют четыре важных особенности:

\begin{enumerate}
  \item они гигиеничны (подробнее в~разделе~\ref{macros/sect:hygiene});
  \item они определяются с~помощью \term{паттернов};
  \item они раскрываются простыми подстановками;
  \item они не~имеют внутреннего состояния.
\end{enumerate}

\indexE{pattern matching}
\indexR{сопоставление с образцом}
Преимуществом определения синтаксиса макросов в~виде паттернов является
возможность тонкого контроля над требуемой формой макровызовов. Более того,
не~требуется писать ни~одной строчки кода для обеспечения этого контроля.
Например, многие макросы последним аргументом принимают список, являющийся
неявным вызовом \ic{begin}. Им не~требуется проверять, что этот список
является корректным (оканчивается на~\ic{()}, а не~точечную пару) "--- эта
проверка автоматически выполняется макроэкспандером, который расскажет обо~всех
встреченных им синтаксических ошибках, включая и~эту. Для реализации подобных
проверок существуют эффективные алгоритмы сопоставления с~образцом (pattern
matching), например, рассмотренные в~работах \cite{que90b,qg92,wc94}.

\indexR{квазицитирование}
Подстановки также реализуются квазицитированием, но такой подход позволяют
выражать лишь операции над списками и векторами. В~частности, здесь нет даже
четырёх арифметических действий и самих чисел вообще.
\seeEx[macros/ex:arg-sequence]

\indexR{макросы!внутреннее состояние}
Отсутствие у~макросов собственного состояния "--- более серьёзное неудобство.
Макросы в~таком случае являются контекстно"=независимыми, что с~одной стороны,
конечно, удобно, но вызывает некоторые сложности с~определением макросов вроде
\ic{define-class}, которому серьёзно облегчит жизнь поддерживаемая в~адекватном
состоянии иерархия ранее определённых классов. Ведь для создания
классов"=наследников необходимо иметь информацию об~их родителях: к~примеру,
количество и имена их~полей.

Иногда действительно хочется иметь макросы, учитывающие контекст своего
раскрытия. Представьте себе макрос \ic{date}, раскрывающийся в~текущую дату.
Он~бы пригодился, например, в~качестве простой системы управления версиями.


\subsection{Обход кода}\label{macros/usage/ssect:code-walk}

\indexR{обход кода}
\indexR{аксессоры!синтаксис}
Большинство реально используемых макросов принимают выражение, делают немного
замен с~перестановками в~нем и возвращают результат. Этим весьма простым
макросам не~требуется выполнять глубокий анализ своих аргументов. Но вот макрос,
к~примеру, преобразующий арифметические выражения из~инфиксной записи
в~привычную для Лиспа префиксную, однозначно потребует более сложной логики.
Рассмотрим макрос \ic{with-slots} из~CLOS на примере {\Meroonet}. К~полям
объекта "--- для определённости, скажем, к~полям объекта класса \ic{Point} "---
доступ обеспечивают функции-аксессоры вроде \ic{Point-x}. Гораздо удобнее
было~бы обращаться к~полям просто по имени: \ic{x} или~\ic{y}; по~крайней мере,
в~контексте объявления методов, где нужный объект самоочевиден. Тогда можно
будет объявлять методы как в~Smalltalk~\cite{gr83}:

\indexC{define-handy-method}
\begin{code:lisp}
(define-handy-method (double (o Point))
  (set! x (* 2 x))
  (set! y (* 2 y))
  o )
\end{code:lisp}

\noindent
вместо такого ужаса:

\begin{code:lisp}
(define-method (double (o Point))
  (set-Point-x! o (* 2 (Point-x o)))
  (set-Point-y! o (* 2 (Point-y o)))
  o )
\end{code:lisp}

Макрос \ic{define-handy-method}, соответственно, должен пройтись по своему телу
и заменить все ссылки и присваивания переменным, чьи имена совпадают с~именами
полей класса, на корректные обращения к~данным полям. Он мог~бы воспользоваться
более быстрыми вариантами аксессоров, которые не~выполняют всяческих проверок
типов, так как правильный тип аргумента уже гарантирован дискриминантом метода.
Подобный макрос не~только улучшает читабельность, но и немного помогает
компилятору с~оптимизациями.

\indexR{смысл программ!по отношению к синтаксису}
\indexR{программы!смысл}
\indexR{значения!как программы}
Однако перед тем, как раскатывать губу, сначала стоит вспомнить, что тело
метода, передаваемое в~\ic{define-handy-method}, "--- это не~программа, а просто
S"=выражение, в~котором могут быть и другие макросы. Очевидно, что сначала надо
раскрыть их, а для этого потребуется доступ к~макроэкспандеру. Более того, как
вы помните, раскрытие макросов может вызвать создание других макросов,
существуют локальные макросы и~так~далее, так что это должен быть именно текущий
макроэкспандер со~всем своим состоянием. Дабы не~уходить в~дебри реализации,
предположим, что во~время раскрытия макроса мы всегда имеем доступ к~его
экспандеру посредством переменной \ic{macroexpand}.

После раскрытия макросов тело \ic{define-handy-method} уже является нормальной
программой, которую можно анализировать. Это несложно. В~конце концов, всю эту
книгу мы только тем и занимались, что анализировали программы. Сейчас нас
интересуют специальные формы и вызовы функций, где могут встретиться необходимые
переменные. Цитаты можно не~трогать, там переменных нет. Смотреть надо на
локальные связывающие формы, способные ввести новые переменные, которые
скроют наши удобные ссылки на поля объекта; очевидно, такие переменные тоже
не~надо трогать. Реализовать собственно обход программ на Лиспе несложно,
см.~\cite{cur89,wat93}; значительно сложнее будет определить, на какие формы
языка "--- вернее, его реализации "--- следует реагировать, а на какие нет.

\indexR{специальные формы}
\indexR{форма!специальная}
Ядром языка являются специальные формы, но в~их толковании многие реализации
часто допускают определённые вольности, как~то:

\begin{itemize}
  \item стандартные возможности, реализованные в~виде специальных форм
        (чаще всего \ic{let} и~\ic{letrec});

  \item введение нестандартных специальных форм (\ic{define-class},
        например);

  \item реализация некоторых специальных форм как макросов (вроде
        известной вам~\ic{begin}).
\end{itemize}

\indexR{рефлексия!и макросы}
Не~имея рефлексивной информации о~языке, сложно ответить на возникающие
в~процессе обхода вопросы: <<Во~что именно превратились все формы \ic{begin}?
Как найти в~исходном коде условные выражения, если \ic{if} "--- это на самом
деле хитрый макрос, раскрывающийся в~специальную форму \ic{typecase}? Что делать
с~незнакомыми специальными формами вроде \ic{define-class}, чей синтаксис
объявления полей идентичен синтаксису вызова функций? Откуда экспандер узнает,
что \ic{bind-exit} является связывающей формой, которая создаёт локальные
привязки, способные скрывать одноимённые переменные?>>

Хорошо было~бы заморозить набор специальных форм и явно запретить реализациям
изменять его в~большую или меньшую сторону. В~таком случае можно быть уверенным,
что после окончания раскрытия макросов программа имеет чётко определённую
структуру, где не~осталось всяких специальных встроенных макросов или чего"~то
подобного. К~сожалению, в~Scheme нет стандартного способа получить необходимую
рефлексивную информацию о~языке и его реализации, так что написать идеально
переносимую версию \ic{define-handy-method} не~получится.


\section{Непредвиденные захваты}\label{macros/sect:hygiene}

\indexR{макросы!гигиеничные}
\indexR{макрогигиена}
\indexR{гигиеничные макросы}
\indexR{свободные переменные!в~макросах}
Идея \term{гигиены} применительно к~макросам была тщательно рассмотрена
в~работах \cite{kffd86,br88,cr91a}. Проблема, решаемая ею, состоит в~том, что
макросы после раскрытия могут содержать переменные, которые в~некотором
смысле <<свободны>>, то~есть ни~с~чем не~связаны, а значит, являются источником
трудноуловимых ошибок, возникающих из"~за сокрытия как переменных окружающего
кода свободными переменными макросов, так и наоборот. Следующий пример
демонстрирует оба случая:

\indexC{acons}
\begin{code:lisp}
(define-abbreviation (acons key value alist)
  `(let ((f cons)) (f (f ,key ,value) ,alist)) )

(let ((cons list)
      (f #f) )
  (acons 'false f '()) )
\end{code:lisp}

Переменная \ic{cons}, оказавшись в~раскрытом макросе \ic{acons}, будет
ссылаться не~на ту \ic{cons}, к~которой все привыкли, а на локальную переменную
\ic{cons}, введённую формой \ic{let}, внутри которой расположен макровызов
\ic{acons}. И~наоборот, сам макрос \ic{acons} вводит переменную~\ic{f}, которая
помешает аргументу \ic{value} получить ожидаемое значение~\ic{\#f}. Ужас!

Гигиеничные макросы в~принципе лишены подобных проблем. Давайте подумаем, как им
это удаётся.

Вот уже тридцать лет от второй проблемы в~Лиспе избавляются с~помощью простого
переименования переменных. Раз переменная~\ic{f} внутри макроса может пересечься
с~какой"~то внешней лексической переменной, то сделаем так, чтобы этого никогда
не~произошло: возьмём \ic{gensym} и получим для внутренней переменной
неповторимое и гарантированно уникальное в~текущем лексическом окружении имя.
Поражаясь простоте решения, невозмутимо пишем:

\begin{code:lisp}
(define-abbreviation (acons key value alist)
  (let ((f (gensym)))
    `(let ((,f cons)) (,f (,f ,key ,value) ,alist)) ) )
\end{code:lisp}

С~первой проблемой, касающейся ссылки на \ic{cons} в~макросе, разобраться будет
сложнее. В~данном случае хочется иметь какой"~то механизм, с~помощью которого
можно было~бы сказать, что \ic{cons} "--- это ссылка на глобальную переменную
\ic{cons}, а не~на что"~то другое. В~конце концов, именно эта переменная
\ic{cons} была видна с~места определения макроса \ic{acons}. Из этого наблюдения
следует главное правило макрогигиены: в~раскрытом макросе свободные переменные
сохраняют смысл, который они имели при определении этого макроса.

На случай с~\ic{cons} во~многих реализациях Лиспа и Scheme есть механизм доступа
к~глобальным переменным в~любом контексте; обычно это нечто вроде \ic{(global
cons)} или \ic{lisp:cons}. Но иногда необходимо связать локальную переменную
с~переменной в~раскрытом макросе, как в~следующем примере:

\begin{code:lisp}
(let ((results '())
      (compose cons) )
  (let-syntax ((push (syntax-rules ()
                      ((push e) (set! results (compose e results))) )))
    |$\pi$|
    results ) )
\end{code:lisp}

Мы хотим, чтобы во~всём теле~$\pi$ этого выражения можно было использовать
макрос \ic{push}, который присоединяет свой аргумент к~переменной \ic{results}
с~помощью функции \ic{compose}. Для этого необходимо обеспечить гигиеничность
данного макроса "--- сделать так, чтобы ни~одно определение внутри $\pi$ не~смогло
изменить смысл \ic{push}. По~существу, у~нас есть два варианта:

\begin{enumerate}
  \item переименовать все мешающие переменные внутри~$\pi$ так, чтобы
        всегда были видны правильные \ic{results} и~\ic{compose};

  \item аккуратно переименовать сами переменные \ic{results} и \ic{compose},
        чтобы они не~пересекались ни~с~чем из~$\pi$; то~есть, изменить
        \ic{let}-форму, определение \ic{push} и тело~\ic{let-syntax}.
\end{enumerate}

\indexR{привязки (bindings)!захват}
\indexR{символы!захват смысла}
\indexR{захват смысла символов}
Несмотря на то, что мы постоянно говорим о~переменных и привязках, для макросов
таких вещей не~существует. Они не~захватывают привязки подобно замыканиям, так
как никаких привязок вообще ещё нет "--- ведь во~время раскрытия макросов всё
это просто S"=выражения! Более того, {\RnRS} не~вводит никаких зарезервированных
идентификаторов, поэтому ничто не~запрещает создавать макросы-тёзки специальных
форм. Следовательно, внутренние макросы~$\pi$ вполне могут <<переопределить>>
примитив \ic{set!}, очевидно свободный в~макросе \ic{push}. Даже это не~должно
изменить поведения \ic{push}. Гигиеничные макросы захватывают сам \emph{смысл}
символов, а не~значения переменных.

\indexR{макрогигиена!исключения}
\indexC{loop}
Гигиена "--- это замечательная и привлекательная возможность, но её нельзя
принять с~распростёртыми объятиями всюду, так как существуют чрезвычайно
полезные, но не~полностью гигиеничные макросы. Наиболее известный из них "---
это макрос \ic{loop}. Из него обычно можно выйти с~помощью функции \ic{exit}.
Однако, если он будет реализован вот~так:

\indexC{loop}
\begin{code:lisp}
(define-syntax loop
  (syntax-rules ()
    ((loop e1 e2 ...)
     (call/cc (lambda (exit)
                (let loop () e1 e2 ... (loop)) )) ) ) )
\end{code:lisp}

\noindent
то из него нельзя будет выйти таким образом, потому что любое упоминание
\ic{exit} внутри форм~\ic{e1}, \ic{e2}\textdots\ из"~за гигиенических
переименований будет ссылаться не~на тот \ic{exit}, который объявлен внутри
макроса, а на тот, который виден с~места макровызова. Здесь необходимо как"~то
сказать экспандеру, чтобы он не~трогал переменную \ic{exit}, но в~стандарте
{\RnRS} такая возможность не~предусмотрена. Строгая гигиена является хорошим
решением по~умолчанию: в~определении \ic{loop} кажется логичным, что форма
\ic{(loop)} ссылается именно на определяемую там~же локальную переменную;
однако иногда от правил требуется отступать.

\indexC{with-aliases}
В~Интернете можно найти множество вполне неплохих реализаций гигиеничных
макросистем, каждая из них обладает своими особенностями, достойными изучения.
Приводимое здесь решение проблемы гигиены не~ограничивает вычисления,
допускаемые во~время раскрытия макросов, но является довольно низкоуровневым по
сравнению с~другими известными реализациями, например, описанными
в~\cite{kcr98,dhb93}. Идея заключается в~явном перечислении символов, чей смысл
во~время раскрытия должен остаться тем~же, каким он был во~время объявления
макроса, а не~определяться из контекста. Рассмотрим на примере. Форма
\ic{with-aliases} принимает список пар <<имя переменной "--- символ>>; \emph{на
время раскрытия} макросов эта форма связывает переменные с~тем, что означают
соответствующие символы в~текущем окружении. Внутри макросов можно пользоваться
данными переменными, чтобы получить доступ к~необходимым объектам. Остальные
аргументы формы \ic{with-aliases} составляют её тело, лексический блок,
содержащий созданные переменные. Итого, предыдущий пример переписывается
следующим образом:

\begin{code:lisp}
(let ((results '())
      (compose cons) )
  (with-aliases ((s set!) (r results) (c compose))
    (let-abbreviation (((push e)
                        `(,s ,r (,c ,e ,r)) ))
      |$\pi$|
      results ) ) )
\end{code:lisp}

\noindent
А~пример с~\ic{loop} теперь выглядит вот~так:

\begin{code:lisp}
(with-aliases ((cc call/cc) (lam lambda) (ll let))
  (define-abbreviation (loop . body)
    (let ((loop (gensym)))
      `(,cc (,lam (exit)
               (,ll ,loop () ,@body (,loop)) )) ) ) )
\end{code:lisp}

Все символы, чей смысл мы хотим сохранить неизменным при раскрытии макросов,
перечисляются в~\ic{with-aliases}. Она захватывает их, а во~время раскрытия
макросов мы можем воспользоваться новыми именами, чтобы вставить на их место
именно то, что означали эти имена при входе в~форму \ic{with-aliases}, а не~то,
что они означают в~текущем окружении, где раскрывается макрос.

Квазицитирование при такой реализации не~особо удобно ввиду того, что большая
часть выражения не~фиксирована. Также этот механизм довольно низкоуровневый "---
он не~делает макросы автоматически гигиеничными, лишь предоставляет инструмент
для самостоятельного соблюдения гигиены. Следующий раздел посвящён подробному
разбору этой и других частей нашей макросистемы.


\section{Макросистема}\label{macros/sect:macrosystem}

\indexC{define-abbreviation}
\indexC{let-abbreviation}
\indexC{eval-in-abbreviation-world}
\indexC{with-aliases}
В~этом разделе мы рассмотрим реализацию макросистемы, которая предоставляет
следующие возможности:

\begin{itemize}
  \item \ic{define-abbreviation} для определения глобальных макросов;

  \item \ic{let-abbreviation} для определения локальных макросов;

  \item \ic{eval-in-abbreviation-world} для вычислений в~макромире;

  \item \ic{with-aliases} для захвата смысла символов.
\end{itemize}

Чтобы ещё раз подчеркнуть различие между подготовкой и исполнением программ,
результат раскрытия макросов будет на лету преобразовываться в~дерево объектов.
Получаемое промежуточное объектное представление программ можно использовать
по-разному: можно отдать его на непосредственное исполнение быстрому
интерпретатору, как в~шестой главе \seePage[chapter:fast], а можно можно,
подобно компилятору из десятой главы \seePage[chapter:cc], преобразовать дерево
объектов в~код на~Си. В~любом случае макросы раскрываются лишь один раз, после
чего структура программы застывает в~виде объектов.


\subsection{Объектификация}\label{macros/macrosystem/ssect:object}

\indexR{объектификация}
\indexR{реификация}
\indexR{преобразование!объектификация}
\indexR{промежуточное представление}
Отчасти объектификация схожа с~реификацией "--- оба процесса приводят к~некоему
<<осязаемому>> результату. Под объектификацией понимается преобразование
программ в~соответствующие им объекты. Также сюда входит проверка и нормализация
синтаксиса обрабатываемых выражений, дабы нас в~дальнейшем не~тревожили глупые
ошибки. Эта трансформация программ схожа с~той, что выполняется для быстрого
интерпретатора (и~намерения у~них тоже схожи), но в~этот раз она выполняется
исключительно ради получения промежуточного представления как такового. Поэтому
вместо замыканий без аргументов, которые удобно вызывать, но очень сложно
анализировать, мы возьмём нечто более прозрачное "--- объекты, чьи поля будут
содержать всю необходимую для вычислений информацию. Кроме того, объектами
гораздо проще манипулировать, используя обобщённые функции.

Итак, иерархия используемых классов:

\indexC{Program}\indexC{Reference}\indexC{Local-Reference}%
\indexC{Global-Reference}\indexC{Predefined-Reference}%
\indexC{Global-Assignment}\indexC{Local-Assignment}\indexC{Function}%
\indexC{Alternative}\indexC{Sequence}\indexC{Constant}\indexC{Application}%
\indexC{Regular-Application}\indexC{Predefined-Application}\indexC{Fix-Let}%
\indexC{Arguments}\indexC{No-Argument}\indexC{Variable}\indexC{Global-Variable}%
\indexC{Predefined-Variable}\indexC{Local-Variable}
\begin{code:lisp}
(define-class Program                Object ())
(define-class Reference              Program (variable))
(define-class Local-Reference        Reference ())
(define-class Global-Reference       Reference ())
(define-class Predefined-Reference   Reference ())
(define-class Global-Assignment      Program (variable form))
(define-class Local-Assignment       Program (reference form))
(define-class Function               Program (variables body))
(define-class Alternative Program (condition consequent alternant))
(define-class Sequence               Program (first last))
(define-class Constant               Program (value))
(define-class Application            Program ())
(define-class Regular-Application    Application (function arguments))
(define-class Predefined-Application Application (variable arguments))
(define-class Fix-Let                Program (variables arguments body))
(define-class Arguments              Program (first others))
(define-class No-Argument            Program ())
(define-class Variable               Object (name))
(define-class Global-Variable        Variable ())
(define-class Predefined-Variable    Variable (description))
(define-class Local-Variable         Variable (mutable? dotted?))
\end{code:lisp}

В~этом перечне легко заметить влияние предыдущих глав на наши представления
о~внутреннем устройстве языка. Например, вызовы примитивов, приводимых форм
\seePage[fast/fast/ssect:reducible] и~обычных функций выделены в~отдельные
категории. Класс \ic{Program} представляет исключительно вычислимые понятия:
обращения к~переменным, присваивания, вызовы функций. Сами переменные "---
привязки значений к~именам "--- являются объектами класса \ic{Variable}, это
не~программы. Также стоит обратить внимание на деталь, отличающую эту реализацию
от рассмотренных ранее. Большинство определённых классов содержат столько полей,
сколько синтаксических элементов имеют соответствующие формы языка. Однако класс
локальных переменных содержит два дополнительных булевых поля: первое
показывает, обнаружены~ли в~программе присваивания этой переменной, а второе
истинно, если данная переменная "--- это точечный аргумент. Как вы помните,
точечные переменные требуют особого внимания при обработке вызовов функций.

\indexC{read}
Часто предобработчик считывает исходные выражения просто с~помощью \ic{read}
(или эквивалентной функции, возвращающей сырые S"=выражения). Однако более
удобным подходом было~бы использование функции, формирующей четвёрку из
собственно выражения, файла, откуда оно было считано, а также соответствующих
строки и столбца. Тогда мы сможем выводить прекрасно детализированные сообщения
об~ошибках. Более того, в~символы можно добавить дополнительное поле со~ссылкой
на экспандер одноимённого макроса, что ускорит поиск макросов. На этапе
предобработки допустимо расширять поля объектов как угодно, если это поможет
улучшить её скорость \hbox{и/или} качество.

\indexR{ключевые слова}
Итак, считанные S"=выражения анализируются и преобразуются в~объект класса
\ic{Program}, при этом в~нём раскрываются все встреченные макросы. Главная
функция \ic{objectify} принимает два аргумента: S"=выражение и его лексическое
окружение. Если выражение является формой, то \ic{objectify} смотрит на её
функциональный терм и выполняет соответствующую ему обработку. Обработчики
макросов не~разбросаны где попало по коду, а располагаются в~поле \ic{handler}
объектов класса \ic{Magic-Keyword} (терминология~\cite{ss75}), туда~же для
удобства отправлены и специальные формы.

\indexC{Magic-Keyword}
\indexC{objectify}
\begin{code:lisp}[label=macros/macrosystem/object/src:objectify]
(define-class Magic-Keyword Object (name handler))

(define (objectify e r)
  (if (atom? e)
      (cond ((Magic-Keyword? e) e)
            ((Program? e)       e)
            ((symbol? e)        (objectify-symbol e r))
            (else               (objectify-quotation e r)) )
      (let ((m (objectify (car e) r)))
        (if (Magic-Keyword? m)
            ((Magic-Keyword-handler m) e r)
            (objectify-application m (cdr e) r) ) ) ) )
\end{code:lisp}

Теперь остаётся лишь разобрать всевозможные специализированные подфункции,
выполняющие преобразования. Большинство из них просто заполняют поля объектов
результатами рекурсивной объектификации элементов соответствующих S"=выражений.
И~правда, сложно придумать какой"~то другой способ для
\ic{objectify-alternative} и \ic{objectify-sequence}. Помимо этого функция
\ic{objectify-sequence} нормализует последовательности форм, превращая их
в~набор одинаковых по структуре бинарных последовательностей, подобных
\ic{cons}"~парам.

\indexC{objectify-quotation}
\indexC{objectify-alternative}
\indexC{objectify-sequence}
\begin{code:lisp}
(define (objectify-quotation value r)
  (make-Constant value) )

(define (objectify-alternative ec et ef r)
  (make-Alternative (objectify ec r)
                    (objectify et r)
                    (objectify ef r) ) )

(define (objectify-sequence e* r)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (let ((a (objectify (car e*) r)))
            (make-Sequence a (objectify-sequence (cdr e*) r)) )
          (objectify (car e*) r) )
      (make-Constant 42) ) )
\end{code:lisp}

Обработка вызовов функций немного сложнее, так как необходимо проанализировать
выражение и категоризовать его как приводимую форму, вызов примитива или вызов
обычной функции. Анализ выполняется на основе первого терма формы. Единственная
возможная тут неясность была упомянута ранее
\seePage[fast/fast/ssect:integrating]: доступна~ли нам информация об~арности
предопределённых функций и как её использовать для более эффективной компиляции.
Класс \ic{Functional-Description} подробно рассматривается чуть позже
(в~разделе~\ref{cc/gen/ssect:predef-env}) вместе с~механизмом наполнения
начального окружения.

\indexC{objectify-application}
\indexC{process-closed-application}
\begin{code:lisp}
(define (objectify-application ff e* r)
  (let ((ee* (convert2arguments (map (lambda (e)
                                       (objectify e r) ) e*))))
    (cond ((Function? ff)
           (process-closed-application ff ee*) )
          ((Predefined-Reference? ff)
           (let* ((fvf  (Predefined-Reference-variable ff))
                  (desc (Predefined-Variable-description fvf)) )
             (if (Functional-Description? desc)
                 (if ((Functional-Description-comparator desc)
                      (length e*) (Functional-Description-arity desc) )
                     (make-Predefined-Application fvf ee*)
                     (objectify-error
                      "Incorrect predefined arity" ff e* ) )
                 (make-Regular-Application ff ee*) ) ) )
          (else (make-Regular-Application ff ee*)) ) ) )

(define (process-closed-application f e*)
  (let ((v* (Function-variables f))
        (b  (Function-body f)) )
    (if (and (pair? v*) (Local-Variable-dotted? (car (last-pair v*))))
        (process-nary-closed-application f e*)
        (if (= (number-of e*) (length v*))
            (make-Fix-Let v* e* b)
            (objectify-error "Incorrect regular arity" f e*) ) ) ) )
\end{code:lisp}

Список аргументов вызова функции тоже преобразуется в~объект (экземпляр класса
\ic{Arguments}); заканчивается этот список на специальный объект класса
\ic{No-Argument}. Количество аргументов можно определить с~помощью обобщённой
функции \ic{number-of}.

\indexC{convert2arguments}
\indexC{number-of}
\begin{code:lisp}
(define (convert2arguments e*)
  (if (pair? e*)
      (make-Arguments (car e*) (convert2arguments (cdr e*)))
      (make-No-Argument) ) )

(define-generic (number-of (o)))

(define-method (number-of (o Arguments))
  (+ 1 (number-of (Arguments-others o))) )

(define-method (number-of (o No-Argument)) 0)
\end{code:lisp}

Как обычно, редкий и громоздкий случай $n$"~арных приводимых форм обрабатывается
отдельно. Дополнительные аргументы собираются в~список, а соответствующая
точечная переменная заменяется обычной.
\seePage[fast/fast/ssect:reducible]

\indexC{process-nary-closed-application}
\begin{code:lisp}
(define (process-nary-closed-application f e*)
  (let* ((v* (Function-variables f))
         (b  (Function-body f))
         (o (make-Fix-Let
             v*
             (let gather ((e* e*) (v* v*))
               (if (Local-Variable-dotted? (car v*))
                   (make-Arguments
                    (let pack ((e* e*))
                      (if (Arguments? e*)
                          (make-Predefined-Application
                           (find-variable? 'cons g.predef)
                           (make-Arguments
                            (Arguments-first e*)
                            (make-Arguments
                             (pack (Arguments-others e*))
                             (make-No-Argument) ) ) )
                          (make-Constant '()) ) )
                    (make-No-Argument) )
                   (if (Arguments? e*)
                       (make-Arguments (Arguments-first e*)
                                       (gather (Arguments-others e*)
                                               (cdr v*) ) )
                       (objectify-error
                        "Incorrect dotted arity" f e* ) ) ) )
             b )) )
    (set-Local-Variable-dotted?! (car (last-pair v*)) #f)
    o ) )
\end{code:lisp}

Абстракции анализируются и объектифицируются функцией \ic{objectify-function}.
Она использует \ic{objectify-variables-list} для обработки списка аргументов,
которыми расширяется окружение создаваемого замыкания.

\indexC{objectify-function}
\indexC{objectify-variables-list}
\begin{code:lisp}
(define (objectify-function names body r)
  (let* ((vars (objectify-variables-list names))
         (b    (objectify-sequence body (r-extend* r vars))) )
    (make-Function vars b) ) )

(define (objectify-variables-list names)
  (if (pair? names)
      (cons (make-Local-Variable (car names) #f #f)
            (objectify-variables-list (cdr names)) )
      (if (symbol? names)
          (list (make-Local-Variable names #f #t))
          '() ) ) )
\end{code:lisp}

Наконец, \ic{objectify-symbol} отвечает за обработку переменных. Сначала она
пытается найти их в~текущем едином статическом лексическом окружении "---
\ic{r}. Если переменная там не~обнаружена, то она добавляется в~глобальное
окружение функцией \ic{objectify-free-global-reference}. Верно, здесь мы решили
создавать новые переменные автоматически при их первом упоминании.

\indexC{objectify-symbol}
\indexC{objectify-free-global-reference}
\begin{code:lisp}
(define (objectify-symbol variable r)
  (let ((v (find-variable? variable r)))
    (cond ((Magic-Keyword? v)       v)
          ((Local-Variable? v)      (make-Local-Reference v))
          ((Global-Variable? v)     (make-Global-Reference v))
          ((Predefined-Variable? v) (make-Predefined-Reference v))
          (else (objectify-free-global-reference variable r)) ) ) )

(define (objectify-free-global-reference name r)
  (let ((v (make-Global-Variable name)))
    (insert-global! v r)
    (make-Global-Reference v) ) )
\end{code:lisp}

Окружение~\ic{r} является, в~принципе, списком локальных переменных, за которым
следует список всех глобальных переменных, а в~конце располагается список
предопределённых переменных. Так как это статическое окружение, то в~нём
отсутствуют значения переменных "--- они определяются динамически, во~время
исполнения программы. Различные окружения представляются списками объектов
класса \ic{Environment}. Их можно расширять как локальными, так и глобальными
переменными. Новые глобальные переменные физически добавляются в~общую
глобальную часть, до которой можно добраться с~помощью функции
\ic{find-global-environment}.

\indexC{Environment}
\indexC{Full-Environment}
\indexC{r-extend*}
\indexC{find-variable"?}
\indexC{insert-global"!}
\indexC{mark-global-preparation-environment}
\indexC{find-global-environment}
\begin{code:lisp}
(define-class Environment      Object (next))
(define-class Full-Environment Environment (variable))

(define (r-extend* r vars)
  (if (pair? vars) (r-extend (r-extend* r (cdr vars)) (car vars))
                   r ) )

(define (r-extend r var)
  (make-Full-Environment r var) )

(define (find-variable? name r)
  (if (Full-Environment? r)
      (let ((var (Full-Environment-variable r)))
        (if (eq? name (cond ((Variable? var)
                             (Variable-name var))
                            ((Magic-Keyword? var)
                             (Magic-Keyword-name var) ) ) )
            var
            (find-variable? name (Full-Environment-next r)) ) )
      (if (Environment? r)
          (find-variable? name (Environment-next r))
          #f ) ) )

(define (insert-global! variable r)
  (let ((r (find-global-environment r)))
    (set-Environment-next!
     r (make-Full-Environment (Environment-next r) variable) ) ) )

(define (mark-global-preparation-environment g)
  (make-Environment g) )

(define (find-global-environment r)
  (if (Full-Environment? r)
      (find-global-environment (Full-Environment-next r))
      r ) )
\end{code:lisp}

\indexC{mutable"?}
Обработка присваиваний позволяет собрать информацию об~изменяемости локальных
переменных: именно здесь у~них устанавливается флаг \ic{mutable?}. Эта
информация впоследствии будет использована для проведения оптимизаций в~десятой
главе. \seePage[chapter:cc]

\indexC{objectify-assignment}
\begin{code:lisp}
(define (objectify-assignment variable e r)
  (let ((ov (objectify variable r))
        (of (objectify e r)) )
    (cond ((Local-Reference? ov)
           (set-Local-Variable-mutable?!
            (Local-Reference-variable ov) #t )
           (make-Local-Assignment ov of) )
          ((Global-Reference? ov)
           (make-Global-Assignment (Global-Reference-variable ov) of) )
          (else
           (objectify-error "Illegal assignment" variable) ) ) ) )
\end{code:lisp}

Для программ, представленных деревьями подобных объектов, очень легко написать
интерпретатор, проверяющий правильность выполнения преобразования. Результат
будет сильно напоминать объектный интерпретатор из третьей~главы и быстрый
интерпретатором из~шестой.

\indexC{g.predef}
\indexC{sg.predef}
Рассмотрим общую структуру этого интерпретатора, чтобы вы не~терялись
в~последующих фрагментах кода. Вычисления выполняет функция \ic{evaluate}. Она
принимает два аргумента: экземпляр \ic{Program} и экземпляр \ic{Environment}
(теперь уже A"~список пар из имён переменных и значений). Вначале окружение
содержит только предопределённые переменные. Его статическая часть представлена
переменной \ic{g.predef}, а динамическая "--- \ic{sg.predef}. Динамическая часть
связывает экземпляры \ic{RunTime-Primitive} с~предопределёнными функциями.
Расширяется динамическое окружение с~помощью функции \ic{sr-extend}.


\subsection{Специальные формы}\label{macros/macrosystem/ssect:special}

\indexR{специальные формы}
\indexR{форма!специальная}
\indexR{ключевые слова}
В~данный момент объектификатор не~распознаёт специальные формы, так что для
каждой из них надо определить персональную процедуру преобразования
в~соответствующий объект класса \ic{Program}. Они определяются как ключевые
слова со~специальными обработчиками. Эти обработчики будут просто вызывать
функции, рассмотренные в~предыдущем разделе.

\indexC{special-if}
\indexC{special-begin}
\indexC{special-quote}
\indexC{special-set"!}
\indexC{special-lambda}
\begin{code:lisp}
(define special-if
  (make-Magic-Keyword 'if
    (lambda (e r)
      (objectify-alternative (cadr e) (caddr e) (cadddr e) r) ) ) )

(define special-begin
  (make-Magic-Keyword 'begin
    (lambda (e r)
      (objectify-sequence (cdr e) r) ) ) )

(define special-quote
  (make-Magic-Keyword 'quote
    (lambda (e r)
      (objectify-quotation (cadr e) r) ) ) )

(define special-set!
  (make-Magic-Keyword 'set!
    (lambda (e r)
      (objectify-assignment (cadr e) (caddr e) r) ) ) )

(define special-lambda
  (make-Magic-Keyword 'lambda
    (lambda (e r)
      (objectify-function (cadr e) (cddr e) r) ) ) )
\end{code:lisp}

\indexC*{special-form-keywords}{*special-form-keywords*}
Естественно, точно таким~же образом можно определить столько дополнительных
специальных форм, сколько необходимо. Чтобы ничего потом не~напутать, запишем
их все в~список \ic{*special-form-keywords*}:

\begin{code:lisp}
(define *special-form-keywords*
  (list special-quote
        special-if
        special-begin
        special-set!
        special-lambda
        ;; \ic{cond}, \ic{letrec} {\itd}
        special-let
        ) )
\end{code:lisp}


\subsection{Уровни интерпретации}\label{macros/macrosystem/ssect:eval-level}

\indexR{уровни интерпретации}
\indexR{интерпретация!уровневая}
Как вы знаете, эндогенное раскрытие макросов подразумевает наличие внутри
специального вычислителя. Но не~забывайте, что эндогенный подход не~требует
единства мира: результат объектификации не~обязательно исполняется в~том~же
окружении, где он создавался. Компилятор в~Си из десятой~главы
\seePage[chapter:cc] служит этому хорошим примером. Нам~бы не~хотелось
запутаться во~всех этих вычислителях, так что давайте введём понятие
\term{уровня интерпретации} (или вычислений) и примем наиболее строгий постулат:
язык, макроязык, макроязык макроязыка и~так~далее "--- все они отделены друг от
друга, соответствующие вычисления производятся в~различных глобальных
окружениях. Данные вычислители представляются объектами класса \ic{Evaluator},
описывающего их важнейшие свойства:

\indexC{Evaluator}
\begin{code:lisp}
(define-class Evaluator Object
  ( mother
    Preparation-Environment
    RunTime-Environment
    eval
    expand
    ) )
\end{code:lisp}

Взаимодействие вычислителей весьма запутанно.
Рисунок~\ref{macros/macrosystem/eval-level/pic:tower} иллюстрирует цепочку
вызовов, возникающую в~процессе раскрытия макросов. Экспандер одного уровня
использует вычислитель следующего, который в~свою очередь тоже предварительно
раскрывает макросы в~получаемом выражении, используя вычислитель следующего
уровня, и~так~далее. Цепочка прерывается, как только получаемое выражение
оказывается лишённым макросов; в~таком случае следующий уровень не~нужен. Обычно
бывает достаточно всего двух-трёх уровней. Каждый уровень интерпретации имеет
своё окружение времени подготовки (для~\ic{expand}) и окружение времени
исполнения (для~\ic{eval}), кроме разве что самого нижнего уровня, где в~цепочке
может участвовать один лишь экспандер.

\begin{figure}\centering
\input{figures/fig9.9}
\ForLayout{display}{\vskip-\medskipamount}
\caption{Цепочка вычислителей.}%
\label{macros/macrosystem/eval-level/pic:tower}
\ForLayout{display}{\vskip-\medskipamount}
\end{figure}

\indexC{enrich-with-new-global-variables"!}
Функция \ic{create-evaluator} используется для создания новых уровней
интерпретации. Она строит новый уровень над тем, который получает через
аргумент. Также она определяет пару функций \ic{eval} и \ic{expand}, а также
соответствующие им окружения подготовки и исполнения. Перед началом вычислений
\ic{eval} раскрывает в~полученном выражении макросы, затем выполняет собственно
вычисления с~помощью функции \ic{evaluate}. Этому чистому вычислителю кроме
выражения необходимо лишь окружение времени исполнения, хранимое в~поле
\ic{RunTime-Environment} текущего экземпляра \ic{Evaluator}. При необходимости
вычислитель может физически изменять данное окружение. Функция \ic{expand}
объектифицирует получаемое выражение с~помощью \ic{objectify}
в~окружении времени подготовки, хранимом в~соответствующем поле
\ic{Preparation-Environment}. Для простоты все глобальные переменные,
создаваемые во~время вложенных вычислений, помещаются в~персональное
глобальное окружение текущего вычислителя с~помощью функции
\ic{enrich-with-new-global-variables!}. Функция \ic{eval} рефлексивным
образом устанавливается в~своё собственное окружение времени исполнения как
предопределённый примитив. Таким образом, различные уровни пользуются
различными функциями \ic{eval}. Далее, перед началом работы окружение
времени подготовки расширяется специальными формами, хранимыми в~переменной
\ic{*special-form-keywords*}. Эта переменная должна быть видима на всех уровнях.
Кроме того, окружение времени подготовки расширяется предопределёнными
макросами, возвращаемыми вызовом \ic{(make-macro-environment level)}, который
мы рассмотрим чуть позже.

\ForLayout{display}{\vskip-\smallskipamount}

\indexC{create-evaluator}
\begin{code:lisp}
(define (create-evaluator old-level)
  (let ((level 'wait)
        (g     g.predef)
        (sg    sg.predef))
    (define (expand e)
      (let ((prg (objectify
                  e (Evaluator-Preparation-Environment level) )))
        (enrich-with-new-global-variables! level)
        prg ) )
    (define (eval e)
      (let ((prg (expand e)))
        (evaluate prg (Evaluator-RunTime-Environment level)) ) )

  ;; Создаём вычислитель
    (set! level (make-Evaluator old-level 'wait 'wait eval expand))

  ;; Наполняем глобальное окружение
    (set! g (r-extend* g *special-form-keywords*))
    (set! g (r-extend* g (make-macro-environment level)))
    (let ((eval-var (make-Predefined-Variable
                     'eval (make-Functional-Description = 1 "") ))
          (eval-fn (make-RunTime-Primitive eval = 1)) )
      (set! g (r-extend g eval-var))
      (set! sg (sr-extend sg eval-var eval-fn)) )

  ;; Устанавливаем окружения в~вычислитель
    (set-Evaluator-Preparation-Environment!
     level (mark-global-preparation-environment g) )
    (set-Evaluator-RunTime-Environment!
     level (mark-global-runtime-environment sg) )

    level ) )
\end{code:lisp}

Если программе потребуется явный экспандер или вычислитель, то достаточно
создать новый уровень интерпретации с~помощью \ic{create-evaluator} и достать
оттуда необходимую функцию \ic{expand} или \ic{eval}. Ос\-то\-рожно: вопреки
ожиданиям, \ic{expand} возвращает экземпляры \ic{Program}, а~не~выражения
Scheme. Если нужны именно такие выражения, то несложно написать соответствующую
функцию"=преобразователь. \seeEx[macros/ex:decompile]


\subsection{Макросы}\label{macros/macrosystem/ssect:macros}

\indexR{бесконечная регрессия}
\indexR{ленивые вычисления}
\indexR{обещания}
По~нашей задумке, в~начальном окружении времени подготовки должны изначально
присутствовать предопределённые макросы, создаваемые функцией
\ic{make-macro-environment}. Вот эта четвёрка: \ic{eval-in-abbreviation-world},
\ic{define-abbreviation}, \ic{let-abbreviation} и~\ic{with-aliases}. Все они
предполагают существование следующего уровня интерпретации, который должен быть
построен той~же функцией \ic{make-macro-environment}. Однако, если попытаться
создать этот уровень сразу~же, то мы погрязнем в~бесконечном цикле, так как на
новом уровне тоже должна быть своя четвёрка предопределённых макросов. Эта
проблема известна в~философии как \emph{бесконечная регрессия}. Новый уровень
интерпретации необходим только в~том случае, если какой"~то из данных макросов
действительно используется на текущем уровне. \seeEx[macros/ex:unique] Поэтому
мы просто пообещаем создать этот уровень, когда он кому"~то понадобится. Если
это так, то новый уровень останется и продолжит накапливать в~себе определения,
иначе~же он просто никогда не~будет создан.

\ForLayout{display}{\clearpage}

\indexC{make-macro-environment}
\begin{code:lisp}
(define (make-macro-environment current-level)
  (let ((metalevel (delay (create-evaluator current-level))))
    (list (make-Magic-Keyword 'eval-in-abbreviation-world
           (special-eval-in-abbreviation-world metalevel) )
          (make-Magic-Keyword 'define-abbreviation
           (special-define-abbreviation metalevel) )
          (make-Magic-Keyword 'let-abbreviation
           (special-let-abbreviation metalevel) )
          (make-Magic-Keyword 'with-aliases
           (special-with-aliases metalevel) ) ) ) )
\end{code:lisp}

Макрос \ic{eval-in-abbreviation-world} является наиболее простым, так как его
работа сводится лишь к~вычислению выражения с~помощью вычислителя следующего
уровня. Вот здесь как раз и придётся потребовать создать для нас данный уровень.
Возвращаемым значением \ic{eval-in-abbreviation-world} должен быть объект,
получаемый вызовом объектификатора в~текущем окружении. Это правило общее для
всех обитателей мира макросов.

\indexC{special-eval-in-abbreviation-world}
\begin{code:lisp}
(define (special-eval-in-abbreviation-world level)
  (lambda (e r)
    (let ((body (cdr e)))
      (objectify ((Evaluator-eval (force level))
                  `(,special-begin . ,body) ) r) ) ) )
\end{code:lisp}

\indexR{замыкания (closures)}
Макрос \ic{define-abbreviation} создаёт и переопределяет глобальные макросы. Он
конструирует соответствующий экспандер и вычисляет полученную абстракцию на
следующем уровне, затем на текущем уровне в~глобальном окружении предобработки
создаётся новое ключевое слово, чьим обработчиком назначается полученный ранее
экспандер. Функция \ic{invoke} в~данном случае более удобна для вычислений,
нежели \ic{evaluate}. Когда создаваемый макрос вызовет экспандер с~помощью
\ic{invoke}, он будет проводить вычисления в~том окружении времени исполнения,
где был создан, то~есть в~окружении следующего уровня, которое замкнуто
в~экспандере. Возвращает~же макрос \ic{define-abbreviation} просто~\ic{\#t}.
Можно было~бы возвращать символ с~именем созданного макроса, но мы сэкономим
немного памяти на~этом.

\indexC{special-define-abbreviation}
\begin{code:lisp}
(define (special-define-abbreviation level)
  (lambda (e r)
    (let* ((call      (cadr e))
           (body      (cddr e))
           (name      (car call))
           (variables (cdr call)) )
      (let ((expander ((Evaluator-eval (force level))
                       `(,special-lambda ,variables . ,body) )))
        (define (handler e r)
          (objectify (invoke expander (cdr e)) r) )
        (insert-global! (make-Magic-Keyword name handler) r)
        (objectify #t r) ) ) ) )
\end{code:lisp}

Локальные макросы создаются похожим образом. Разница только в~том, что
новые ключевые слова помещаются в~начало текущего окружения "--- туда, где
расположены локальные определения.

\indexC{special-let-abbreviation}
\begin{code:lisp}
(define (special-let-abbreviation level)
  (lambda (e r)
    (let ((level  (force level))
          (macros (cadr e))
          (body   (cddr e)) )
      (define (make-macro def)
        (let* ((call      (car def))
               (body      (cdr def))
               (name      (car call))
               (variables (cdr call)) )
          (let ((expander ((Evaluator-eval level)
                           `(,special-lambda ,variables . ,body) )))
            (define (handler e r)
              (objectify (invoke expander (cdr e)) r) )
            (make-Magic-Keyword name handler) ) ) )
      (objectify `(,special-begin . ,body)
                 (r-extend* r (map make-macro macros)) ) ) ) )
\end{code:lisp}

Самым сложным из всей четвёрки является макрос \ic{with-aliases}, так как его
работа затрагивает сразу несколько уровней. Он должен захватить смысл символов
на текущем уровне, передать его на следующий, там связать эти значения с~новыми
переменными, причём сделать всё это исключительно на время выполнения раскрытия
своего тела. Именно хореография областей видимости, уровней интерпретации
и~времени жизни делает этот макрос столь сложным.

\indexC{special-with-aliases}
\begin{code:lisp}
(define (special-with-aliases level)
  (lambda (e current-r)
    (let* ((level   (force level))
           (old-r   (Evaluator-Preparation-Environment level))
           (old-sr  (Evaluator-RunTime-Environment level))
           (aliases (cadr e))
           (body    (cddr e)) )
      (let bind ((aliases aliases)
                 (r  old-r)
                 (sr old-sr) )
        (if (pair? aliases)
            (let* ((variable (car (car aliases)))
                   (keyword  (cadr (car aliases)))
                   (var      (make-Local-Variable variable #f #f)) )
              (bind (cdr aliases)
                    (r-extend r var)
                    (sr-extend sr var
                               (objectify keyword current-r) ) ) )
            (let ((result 'wait))
              (set-Evaluator-Preparation-Environment! level r)
              (set-Evaluator-RunTime-Environment! level sr)
              (set! result (objectify `(,special-begin . ,body)
                                      current-r ))
              (set-Evaluator-Preparation-Environment! level old-r)
              (set-Evaluator-RunTime-Environment! level old-sr)
              result ) ) ) ) ) )
\end{code:lisp}

\indexR{динамическое связывание}
\indexR{связывание!динамическое}
Для временной модификации окружения следующего уровня интерпретации прекрасно
подошёл~бы механизм динамического связывания, гарантирующий восстановление
старого окружения после завершения раскрытия формы \ic{with-aliases}.

Переменные, создаваемые \ic{with-aliases}, связываются со~значениями, которые
ранее вернула функция \ic{objectify}, то~есть с~объектами класса \ic{Program}
или \ic{Magic-Keyword}. Так как подобные объекты вполне могут быть возвращены
обратно из \ic{with-aliases} в~результате раскрытия макросов, то \ic{objectify}
должна уметь с~ними обращаться. Именно поэтому она вначале проверяет,
не~является~ли полученное выражение уже объектифицированной программой или
ключевым словом. \seePage[macros/macrosystem/object/src:objectify]


\subsection{Ограничения}\label{macros/macrosystem/ssect:limits}

\indexR{гигиеничные макросы}
\indexR{макрогигиена}
\indexR{макросы!гигиеничные}
Механизм гигиеничного переименования позволяет жонглировать переменными и
привязками, даёт возможность захватывать значение символа в~одном месте, а
использовать его в~совершенно другом "--- там, откуда до данной переменной
нельзя добраться иным способом; и~даже там, где она вовсе не~существует.
Например:

\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}

\begin{code:lisp}
(let ((count 0))
  (with-aliases ((c count))
    (define-abbreviation (tick) c) )
  (tick) )
(let ((count 1) (c 2))
  (tick) )
\end{code:lisp}

\indexR{захват смысла символов}
Глобальный макрос \ic{tick} ссылается на локальную переменную \ic{count},
которая не~видна из второй формы \ic{let}. Действительно, необдуманный захват
смысла символов может вызывать ошибки нового типа: обращения к~несуществующим
переменным. Несмотря на то, что в~локальном окружении есть переменная с~именем
\ic{count}, это \emph{не~та} \ic{count}, которую ищет \ic{tick}! Причина ошибки
видна яснее в~следующем <<деобъектифицированном>> представлении исходного
фрагмента:

\begin{code:lisp}
((LAMBDA (COUNT501)
   (BEGIN #T ;; \ic{(tick)} $\leadsto$ \ic{COUNT501}
          COUNT501 ) ) 0)
((LAMBDA (COUNT502 C503) COUNT501) 1 2)
\end{code:lisp}

\ForLayout{display}{\endgroup}

Расположение формы \ic{with-aliases} необходимо тщательно выбирать, так как это
нечто вроде \ic{let}, только для следующего уровня интерпретации. Если написать

\begin{code:lisp}
(define-abbreviation (loop . body)
  (with-aliases ((cc call/cc) (lam lambda) (ll let))
    (let ((loop (gensym)))
      `(,cc (,lam (exit) (,ll ,loop () ,@body (,loop)))) ) ) )
\end{code:lisp}

\noindent
то форма \ic{with-aliases} захватит смысл символов на уровне макроопределений,
так что использовать их можно только на этом или более высоком уровне. Здесь
\ic{with-aliases} содержится внутри \ic{define-abbreviation}, поэтому в~момент
раскрытия макроса \ic{loop} смысл \ic{call/cc} захватывается в~мире макросов,
привязывается к~переменной \ic{cc} и\textdots\ мы получаем ошибку \ic{"cc:
unknown value"}, так \ic{call/cc} из мира макросов недоступна раскрытому коду,
находящемуся в~мире программ.

\indexR{полноценные объекты!окружения}
\indexC{import}
\indexC{export}
Если не~брать в~расчёт специальные формы и другие ключевые слова вроде \ic{else}
и~\ic{=>}, то смысл локальных и глобальных переменных вполне успешно
захватывался с~помощью полноценных окружений и форм \ic{import}\slash\ic{export}.
\seePage[reflection/reify-env/ssect:import] Однако механизм, показанный в~данной
главе, несомненно является более мощным, так как, во"~первых, он позволяет
захватывать специальные формы в~том числе, а во"~вторых, он выполняет это
статически, а не динамически.

Также рассмотренная макросистема позволяет создание предопределённых макросов,
чьё написание невозможно для конечного пользователя; например, можно определить
макрос, создающий глобальные переменные прямым вызовом функции
\ic{insert-global!}.

Несмотря на это, она имеет и недостатки. Если пользователь захочет посмотреть,
во~что именно раскрываются макросы, то он столкнётся как минимум с~двумя
затруднениями. Во"~первых, ему недоступна функция \ic{expand}. Очевидно, это
можно исправить, сделав так, чтобы переменная \ic{expand} текущего уровня
интерпретации ссылалась на функцию \ic{expand} следующего. Вторая проблема
заключается в~том, что результатом раскрытия является объект класса
\ic{Program}, чья структура неизвестна пользователю. Но и это тоже поправимо:
\seeEx[macros/ex:decompile].

Одной из задач данной макросистемы было продемонстрировать тесную связь между
макросами и компиляцией "--- оба понятия имеют поразительно много общего. Если
из~приведённой реализации убрать код, ответственный за собственно вычисления и
объектификацию, то о~макросах в~нём будет напоминать только небольшая часть
функций \ic{objectify} и \ic{objectify-symbol}, а также четыре обработчика
предопределённых макросов. Суммарно это чуть меньше сотни строк кода "--- очень
мало.

Серьёзная макросистема, конечно~же, должна включать в~себя гораздо больше
полезных вещей:

\begin{enumerate}
  \item встроенные синтаксические возможности вроде \ic{or}, \ic{letrec},
        вложенных \ic{define} {\itd};

  \item квазицитирование, органично объединённое с~объектификацией
        и~раскрытием макросов;

  \item пользовательские макросимволы, позволяющие удобное написание
        программ в~стиле \ic{define-handy-method}.
        \seePage[macros/usage/ssect:code-walk]
\end{enumerate}

Тем не~менее, одной из изначальных целей "--- ознакомиться с~идеей захвата
смысла символов "--- мы всё~же достигли.


\section{Заключение}\label{macros/sect:conclusions}

Все проблемы, связанные с~макросами, можно обобщить двумя словами: необходимость
и несовместимость. Макросы регулярно используются на практике в~том или ином
виде, но при этом существует огромное число несовместимых друг с~другом
реализаций макросистем, предоставляющих различные возможности. В~этой главе
мы попробовали охватить максимально широкий ассортимент решений. Немногие
руководства по реализациям Лиспа и Scheme точно описывают используемую модель
макросов, однако в~их защиту можно сказать, что данная глава, вероятно, является
одной из первых попыток описать и классифицировать безмерное множество вариантов
поведения макросистем.


\section{Упражнения}\label{macros/sect:exercises}

\begin{exercise}\label{macros/ex:repeat}
Определите макрос \ic{repeat}, который был описан в~начале этой главы. Сделайте
его гигиеничным.
\end{exercise}

\begin{exercise}\label{macros/ex:arg-sequence}
С~помощью \ic{define-syntax} определите макрос, принимающий последовательность
выражений и печатающий их по~порядку рядом с~их номерами. Например, макровызов
\ic{(enumerate $\pi_0$ $\pi_1$~... $\pi_n$)} должен раскрыться в~нечто, что при
выполнении напечатает~\ic{0}, затем значение~$\pi_0$, потом~\ic{1}, а за ней
значение~$\pi_1$, и~так~далее.
\end{exercise}

\begin{exercise}\label{macros/ex:unique}
Перенесите макросистему из данной главы в~истинно единый мир.
\end{exercise}

\begin{exercise}\label{macros/ex:decompile}
Напишите функцию, преобразующую объекты \ic{Program} обратно в~эквивалентные
S"=выражения.
\end{exercise}

\begin{exercise}\label{macros/ex:study}
Изучите реализацию {\Meroonet} \seePage[chapter:objects] и определите, что
оттуда относится к~библиотеке времени раскрытия, что к~библиотеке времени
исполнения, а~что к~обеим.
\end{exercise}


\section*{Рекомендуемая литература}\label{macros/sect:recommended-reading}

Весьма интересные мысли в~защиту макросов приведены в~книге \cite{gra93}. Есть
также и работы больше теоретического характера, вроде \cite{qp90}. О~проблемах
гигиеничного макрораскрытия можно почитать в~\cite{kffd86,dfh88,cr91a,qp91b}.
Наконец, стоит обратить внимание на многообещающую модель раскрытия,
рассмотренную в~работе~\cite{dm95}.
