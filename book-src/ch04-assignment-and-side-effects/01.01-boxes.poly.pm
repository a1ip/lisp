#lang pollen

◊; TODO: я уже где-то писал, но может всё же не "коробки"?
◊; тем не менее, это хорошая метафора, так что может не стоит плодить англицизмы
◊; единственный вариант, который приходит на ум -- это "обёртка", так как вроде именно так это зовётся в Java
◊; но boxed types в Java -- это немного другое всё же
◊; ячейки чтоле?
◊subsection[#:label "assignment/assignment/ssect:boxes"]{Коробки}

◊indexR{коробки} ◊; TODO: ◊indexE{boxes}
◊indexR{ячейки}  ◊; TODO: ◊indexE{cells}
Чтобы сделать идею привязок более понятной, рассмотрим аналогию с~А-списками.
В~предыдущих интерпретаторах для представления окружений использовались А-списки,
которые хранили для нас множество пар ◊nobr{«переменная — значение»}.
(если~быть точным, ◊emph{список} точечных~пар).
При~обращении к~переменной мы ищем соответствующую точечную пару,
а~присваивание переменной присваивает новое значение ◊ic{cdr} найденной точечной~пары.
В~данном случае точечные пары являются реализацей привязок — одним из способов реализации.
Возможны и~другие варианты реализации:
например, с~помощью ◊term{коробок}~(◊english{boxes}), которые иногда также называют ◊term{ячейками}~(◊english{cells}).
Новый уровень абстракции имеет большое значение,
так~как мы полностью избавляемся от присваивания переменным,
заменяя его побочными эффектами операций над~привязками.

Значение упаковывается в~коробку функцией ◊ic{make-box}.
Используя ◊ic{box-ref} можно взглянуть на текущее содержимое коробки и положить в~неё что-то другое с~помощью ◊ic{box-set!}.
Набросаем реализацию коробок в~стиле передачи~сообщений:

◊indexC{make-box}
◊indexC{box-ref}
◊indexC{box-set!}
◊code:lisp{
(define (make-box value)
  (lambda (msg)
    (case msg
      ((get) value)
      ((set) (lambda (new-value) (set! value new-value))) ) ) )

(define (box-ref box)
  (box 'get) )

(define (box-set! box new-value)
  ((box 'set) new-value) )
}

◊noindent
Можно было~бы реализовать их и без замыкания, используя точечные пары напрямую:

◊code:lisp{
(define (other-make-box value)
  (cons 'box value) )

(define (other-box-ref box)
  (cdr box) )

(define (other-box-set! box new-value)
  (set-cdr! box new-value) )
}

◊noindent
Или вообще создать класс:

◊code:lisp{
(define-class box Object (content))
}

◊indexR{коробки!и изменяемость переменных}
Во~всех трёх случаях (даже четырёх, если считать упражнение~◊ref{escape/ex:crazy-cc})
возвращаемое значение ◊ic{set-box!} не~определено —
эта функция используется исключительно ради побочного эффекта.
Каждую переменную, значение которой изменяется в~процессе вычислений, можно представить как абстрактную коробку,
сосредотачивая таким образом все побочные эффекты в~реализации этих коробок.
Заодно становится очень просто определить, изменяема~ли переменная:
достаточно посмотреть на соответствующую связывающую форму и убедиться, что переменная упакована в~коробку.
(Благодаря свойствам лексических окружений мы можем чётко определить область видимости любой переменной.)

◊indexR{преобразование!в коробочный стиль}
◊indexR{коробки!преобразование}
В~следующей таблице собраны правила перевода программ в~«коробочный~стиль».
Запись~◊box{◊${\pi}} означает, что переменная~◊${v} в~программе~◊${\pi} помещается в~коробку.

◊; TODO: вёрстка таблицы
◊; например, красивая стрелка $\Rightarrow$
◊; и красивые эпсилоны (здесь и везде где я забыл)
◊; и "если ... то ... иначе" чтобы красиво читалось
◊; и пунктуацию проверь (запятая перед "то" точно необходима?)
◊table[#:label "assignment/assignment/boxes/p:boxing"]{
  ◊tr{
    ◊td{◊box{◊ic{◊${x}}}}
    ◊td{◊ic{◊(is)}}
    ◊td{если ◊${x = v}, то ◊ic{(box-ref ◊${v})}, иначе ◊${x}}
  }
  ◊tr{
    ◊td{◊box{◊ic{(quote ◊${\epsilon})}}}
    ◊td{◊ic{◊(is)}}
    ◊td{◊ic{(quote ◊${\epsilon})}}
  }
  ◊tr{
    ◊td{◊box{◊ic{(if ◊${\pi_c} ◊${\pi_t} ◊${\pi_f})}}}
    ◊td{◊ic{◊(is)}}
    ◊td{◊ic{(if ◊box{◊${\pi_c}} ◊box{◊${\pi_t}} ◊box{◊${\pi_f}})}}
  }
  ◊tr{
    ◊td{◊box{◊ic{(begin ◊${\pi_1} ... ◊${\pi_n})}}}
    ◊td{◊ic{◊(is)}}
    ◊td{◊ic{(begin ◊box{◊${\pi_1}} ... ◊box{◊${\pi_n}})}}
  }
  ◊tr{
    ◊td{◊box{◊ic{(set! ◊${x} ◊${\pi})}}}
    ◊td{◊ic{◊(is)}}
    ◊td{если ◊${x = v},◊(br)
        тогда ◊ic{(box-set! ◊${v} ◊box{◊${\pi}})},◊(br)
        иначе ◊ic{(set! ◊${x} ◊box{◊${\pi}})}}
  }
  ◊tr{
    ◊td{◊box{◊ic{(lambda (... ◊${x} ...) ◊${\pi})}}}
    ◊td{◊ic{◊(is)}}
    ◊td{если ◊${v \in {\dots x \dots}},◊(br)
        тогда ◊ic{(lambda (... ◊${x} ...) ◊${\pi})},◊(br)
        иначе ◊ic{(lambda (... ◊${x} ...) ◊box{◊${\pi}})}}
  }
  ◊tr{
    ◊td{◊box{◊ic{(◊${\pi_0} ◊${\pi_1} ... ◊${\pi_n})}}}
    ◊td{◊ic{◊(is)}}
    ◊td{◊ic{(◊box{◊${\pi_0}} ◊box{◊${\pi_1}} ... ◊box{◊${\pi_n}})}}
  }
}

Как обычно, за~именами переменных важно тщательно следить.
Когда новая локальная переменная скрывает ту, которую мы заворачиваем в~коробку,
то~замену производить не~нужно.

Остаётся ввести ещё одно правило, которое определяет, какие именно переменные необходимо раскладывать по~коробкам.
Нас интересуют все переменные, которым может быть присвоено новое значение — все изменяемые переменные.

◊; TODO: формула чтобы не выглядела как говно
◊; и согласуй с таблицей выше
◊code:lisp{
(lambda (... ◊${x} ...) ◊${\pi}) ◊${\land} (set! ◊${x} ...) ◊${{} \in \pi}
◊(is) (lambda (... ◊${x} ...) (let ((◊${x} (make-box ◊${x}))) ◊box[#:var ◊${x}]{◊${\pi}}))
}

В~результате, предыдущий пример переписывается следующим образом:

◊code:lisp{
(let ((name (make-box "Nemo")))
  (set! winner (lambda () (box-ref name)))
  (set! set-winner! (lambda (new-name) (box-set! name new-name)
                                       (box-ref name) ))
  (set-winner! "Me") (winner) )
}

◊indexR{коробки!аналогии}
◊indexR{присваивание!семантика коробок}
◊indexR{коробки!недостатки}
◊indexR{ссылочная прозрачность}
В~функциональных языках программирования вместо изменяемых переменных (и~присваивания)
часто используются именно коробки — или ◊term{изменяемые ссылки}, как их называет~ML.
Коробки убирают из языка присваивания переменным и сопутствующий вопрос их изменяемости.
Значения переменных не~меняются, они всегда связаны либо с~каким-то конкретным объектом.
Конечно, содержимое коробок может изменяться, поэтому ссылочная прозрачность всё~так~же теряется,
но~с~другой стороны, для коробок гораздо проще ввести систему типов.
Однако, помимо преимуществ, использование коробок вызывает и~свои специфичные проблемы.

◊indexR{привязки (bindings)!как полноценные объекты}
◊indexR{полноценные объекты!привязки}
Во-первых, привязки теперь становятся полноценными объектами языка,
а~значит, их можно передавать не~только в~◊ic{box-ref} и ◊ic{box-set!}.
Например, несколько переменных могут ссылаться на одну и~ту~же коробку,
что порой оказыается полезным, например, для реализации модулей.

Во-вторых, использование коробок в~общем случае невозможно контролировать.
Если ссылки на коробку могут оказаться в~произвольных структурах данных,
то~из-за кошмарного дальнодействия побочных эффектов значение коробки может измениться когда~угодно.
С~лексическим присваиванием такой трюк не~работает:
для~изменения значения переменной необходимо указать её~имя,
область видимости которого строго ограничена кодом связывающей формы.
Если компилятор знает, что изменяемая переменная не~захватывается никаким замыканием и не~отдаётся кому попало —
как переменные ◊ic{min} и~◊ic{max} в~примере с~◊ic{min-max} —
в~таких случаях можно генерировать гораздо более эффективный машинный~код.

Также не~стоит забывать, что в~физическом компьютере значения переменных хранятся в~памяти, по~определённым адресам.
При присваивании изменяется не~сама переменная (не~её~адрес), а~именно расположенное в~памяти значение.
