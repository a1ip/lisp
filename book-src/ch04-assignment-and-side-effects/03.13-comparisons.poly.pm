#lang pollen

◊subsection[#:label "assignment/implementation/ssect:comparisons"]{Функции сравнения}

Одной из задач интерпретатора в~этой главе является иллюстрация предикатов эквивалентности,
вроде~◊ic{eqv?}, который проверяет являются~ли два объекта взаимозаменимыми.
Сначала ◊ic{eqv?} сравнивает типы объектов — если~они совпадают, то~проводится собственно сравнение.
Символы должны иметь одинаковое имя.
Логические значения и числа должны быть равными.
Точечные пары и функции должны иметь совпадающие адреса.

◊indexC{eqv?!реализация}
◊code:lisp{
(defprimitive eqv?
  (lambda (v* s k)
    (k (create-boolean
        (if (eq? ((car v*) 'type) ((cadr v*) 'type))
            (case ((car v*) 'type)
              ((null) #t)
              ((boolean)
               (((car v*) 'boolify)
                (((cadr v*) 'boolify) #t #f)
                (((cadr v*) 'boolify) #f #t) ) )
              ((pair)
               (and (= ((car v*) 'car) ((cadr v*) 'car))
                    (= ((car v*) 'cdr) ((cadr v*) 'cdr)) ) )
              ((symbol)
               (eq? ((car v*) 'name) ((cadr v*) 'name)) )
              ((number)
               (= ((car v*) 'value) ((cadr v*) 'value)) )
              ((function)
               (= ((car v*) 'tag) ((cadr v*) 'tag)) )
              (else #f) )
            #f ) )
       s ) )
  2 )
}

Собственно, единственная причина, по которой мы сохраняем адреса функций (а~точнее,~замыканий) внутри объектов —
это сравнение функций с~помощью ◊ic{eqv?}.
Таким образом, вместо решения сложной проблемы эквивалентности функций
достаточно ответить на простой вопрос о~равенстве адресов, которые суть просто числа.
Заметьте, что при сравнении точечных пар мы тоже сравниваем лишь адреса компонент,
а~не~их~содержимое.
Итого, ◊ic{eqv?} выполняется за предсказуемое постоянное время, в~отличие от~◊ic{equal?}.

Функция ◊ic{eqv?} похожа на обобщённую, только она содержит все методы внутри себя,
а~в~остальном — всё та~же диспетчеризация по~типу аргумента.
Благодаря выбранному представлению данных мы можем быстро провести проверку на согласованность типов
и перейти непосредственно к~сравнению адресов или значений,
которое чаще всего также выполняется быстро
(за~исключением случая длинной арифметики).
