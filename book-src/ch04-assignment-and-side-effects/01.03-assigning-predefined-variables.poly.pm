#lang pollen

◊subsection[#:label "assignment/assignment/ssect:predefined"]{Присваивание предопределённым~переменным}

◊indexR{переменные!предопределённые}
◊indexR{предопределённые переменные}
◊indexR{присваивание!предопределённым переменным}
Среди свободных переменных в~программах на~Scheme можно выделить предопределённые переменные вроде ◊ic{car} и~◊ic{read}.
Естественно, программы обладают неотчуждаемым правом присваивать переменным значения,
но~какой именно смысл несёт присваивание для предопределённых переменных?
Интерпретаторы часто полагаются на неявные предположения о~программах, чтобы исполнять их быстрее.
Например, в~Лиспе почти никогда не~требуется переопределять ◊ic{car} и~◊ic{cdr},
поэтому они практически всегда реализуются как инлайн-функции и подставляются напрямую в~код, как своеобразные макросы.
Переопределение подобных функций сломает эту стройную систему,
ведь обращения к~◊ic{car} должны будут использовать новое значение, а~не~встроенное.

Гиперстатическое окружение не~видит проблемы в~переопределении:
предыдущие ссылки используют предыдущие значение, новые определения работают с~новым значением.
Однако в~динамическом глобальном окружении нам придётся отыскать все вхождения ◊ic{car} и~заменить~их.
Далее, по-видимому, потребуется переопределить ещё и~◊ic{cadr}, которая является композицией ◊ic{car} и~◊ic{cdr}.
Как-то слишком много работы выходит, не~правда~ли?
Пользователи вряд~ли ожидают, что одно-единственное присваивание вызовёт столько беспорядка.

◊indexE{Scheme!неизменяемость примитивов}
◊indexR{примитивы!неизменяемость}
Между прочим, Scheme запрещает изменять значения и~поведение глобальных примитивных функций.
То~есть определить свою глобальную переменную~◊ic{car} нам-то ничто не~помешает,
но~она никак не~повлияет на~◊ic{cadr}.
Аналогично, функция ◊ic{map} является встроенной, поэтому новая~◊ic{car} не~изменит её~поведения,
однако, возможно, это затронет какую-нибудь ◊ic{mapc}, которая не~входит в~стандартную библиотеку.

Глобальные переменные чаще всего переопределяют, чтобы подменить функцию отладочным вариантом,
а~затем исправить обнаруженные ошибки на~месте, в~интерактивной сессии.
Тем не~менее, я~дам вам дружеский совет:
горе тому человеку, через которого соблазн приходит.

Подводя итог, гиперстатическое окружение ведёт себя просто, понятно и~логично,
но~для отладки более удобным оказывается окружение динамическое.
