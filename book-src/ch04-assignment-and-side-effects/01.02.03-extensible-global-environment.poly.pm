#lang pollen

◊subsubsection*[#:label "assignment/assignment/free-vars/sssect:auto-extended"]{Автоматически~расширяемое глобальное~окружение}

◊indexR{глобальное окружение!автоматически расширяемое}
◊indexR{окружение!глобальное!автоматически расширяемое}
◊indexR{автоматически расширяемое окружение}
Если вы реализуете REPL, то~вам необходима возможность динамического добавления переменных в~глобальное окружение.
В~предыдущем разделе мы использовали для этого специальную форму ◊ic{define},
но~можно~ли обойтись лишь одним присваиванием?
Если переменная не~существует — первое присваивание определяет~её.
В~таком случае можно было~бы писать просто:

◊code:lisp{
(let ((name "Nemo"))
  (set! winner (lambda () name))
  (set! set-winner! (lambda (new-name) (set! name new-name)
                                       name )) )
}

В~предыдущих случаях нам~бы пришлось перед этим написать два бессмысленных утверждения вроде

◊code:lisp{
(define winner      ◊ic{'варкалось})
(define set-winner! ◊ic{'хливкие-шорьки})
}

◊indexC{static}
Таким образом мы определяем две~переменные, инициализируем~их чем~попало, а~затем сразу~же присваиваем новые, правильные значения.
Очевидно, теперь все глобальные переменные обязаны быть изменяемыми?
В~ранних версиях~Scheme ◊seeCite{ss78b} существовала специальная форма ◊ic{static},
позволяющая выкрутиться
◊footnote{
  Локальная форма~◊ic{define} обрабатывает ◊ic{static} специальным образом, позволяя определять глобальные переменные локально.
  То~есть,~◊nobr{◊ic{(static ◊ii{переменная})}} — это ссылка на~соответствующую глобальную переменную,
  а~не~вызов унарной~функции~◊ic{static}.
}
из~ситуации следующим~образом:

◊code:lisp{
(let ((name "Nemo"))
  (define (static winner) (lambda () name))
  (define (static set-winner!)
    (lambda (new-name) (set! name new-name)
                       name ) ) )
}

Так без~использования присваивания определяются глобальные переменные, имеющие доступ к~общему локальному окружению.

Несомненно, создавать глобальные переменные простым присваиванием удобно.
С~другой стороны, теперь оказывается очень легко случайно загрязнить глобальное окружение ненужными переменными.
Как вариант, можно ограничить область видимости таких локально определяемых глобальных переменных,
например, соответствующей формой~◊ic{let}, или~ближайшей формой~◊ic{prog}.
◊seeCite{nor72}
◊footnote{
  Например, так~сделано в~◊|TeX|: определения, создаваемые~◊ic{\def}, автоматически отменяются при выходе из текущей~группы.
}
К~сожалению, подобные идеи всегда нарушают ссылочную прозрачность,
а~также вызывают известные сложности для взаимно рекурсивных определений.
