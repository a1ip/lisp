#lang pollen

◊subsection[#:label "assignment/implementation/ssect:condition"]{Ветвление}

Условный оператор использует вспомогательное продолжение для выполнения ветвления после вычисления условия.

◊indexC{evaluate-if}
◊code:lisp{
(define (evaluate-if ec et ef r s k)
  (evaluate ec r s
    (lambda (v ss)
      (evaluate ((v 'boolify) et ef) r ss k) ) ) )
}

Вспомогательное продолжение принимает не~только вычисленное условие~◊ic{v},
но~и~новое состояние памяти после вычисления.
Следовательно, мы допускаем побочные эффекты при вычислении условия:

◊code:lisp{
(if (begin (set-car! pair 'foo)
           (cdr pair) )
    (car pair) 2 )
}

◊indexR{поиск с возвратом}
Любые изменения памяти, выполненные в~условии, видны в~обеих ветках программы.
Однако можно поступить иначе:

◊indexC{evaluate-if!поиск с возвратом}
◊code:lisp{
(define (evaluate-amnesic-if ec et ef r s k)
  (evaluate ec r s
    (lambda (v ss)
      (evaluate ((v 'boolify) et ef) r s     ; s ≠ ss!
                k) ) ) )
}

В~этом случае после вычисления условия используется старое состояние памяти.
Подобный подход очень упрощает реализацию поиска с~возвратом как в~Прологе.
◊seeEx{assignment/ex:form-or}

◊indexE{boolify@◊ic{'boolify}}
◊indexR{комбинаторы!T@◊${◊comb{T}}}
◊indexR{комбинаторы!F@◊${◊comb{F}}}
Значения в~нашем языке представляются замыканиями,
поэтому нам нельзя использовать ◊ic{#t} и~◊ic{#f} в~качестве логических значений —
это значения языка реализации, а~не~нашего нового~Лиспа.
В~Scheme любой объект может служить логическим значением,
поэтому мы используем следующий подход в~духе ◊${\lambda}-исчисления.
Все~объекты отвечают на сообщение ◊ic{boolify}, возвращая своё каноническое логическое значение:
комбинатор ◊nobr{◊ic{(lambda (x y) x)}} или ◊nobr{◊ic{(lambda (x y) y)}}.
