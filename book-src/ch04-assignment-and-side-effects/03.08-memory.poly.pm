#lang pollen

◊subsection[#:label "assignment/implementation/ssect:memory"]{Память}

◊indexR{сборка мусора}
Память представляется функцией, принимающей адреса и возвращающей значения.
Кроме этого требуется возможность выделять в~памяти новые адреса,
гарантированно свободные для использования;
этим будет заниматься функция~◊ic{allocate}.
Она принимает три аргумента:
необходимое количество адресов, память и~продолжение,
которому ◊ic{allocate} передаст список выделенных адресов и новое состояние памяти,
где по соответствующим адресам хранятся значения «не~инициализировано».
Именно на эту функцию возложена вся работа по управлению памятью.
В~частности, сборка мусора — отдельная сложная тема,
◊trnote{
  Достаточно неплохое введение в~сборку мусора есть в~первом томе «Искусства программирования» Дональда~Кнута.
  ◊; TODO: а ещё есть обалденная Garbage Collection Handbook, которую можно порекомендовать
}
которую мы здесь разбирать не~будем и просто предположим,
что память у~нас бесконечная —
то~есть мы всегда можем найти необходимое количество свободных адресов.

◊indexC{allocate}
◊code:lisp{
(define (allocate n s k)
  (if (> n 0)
      (let ((a (new-location s)))
        (allocate (- n 1)
                  (expand-store a s)
                  (lambda (a* ss)
                    (k (cons a a*) ss) ) ) )
      (k '() s) ) )
}

Функция ◊ic{new-location} ищет первый свободный адрес в~памяти.
Это~чистая функция — в~смысле, без побочных эффектов,
поэтому ◊nobr{◊ic{(eqv? (new-location s) (new-location s))}} всегда возвращает истину.
Если выделять ячейки в~памяти последовательно,
то~достаточно хранить последний выделенный адрес для определения следующего свободного.
Резервируется ячейка памяти с~помощью функции ◊ic{expand-store}.

◊indexC{expand-store}
◊indexC{new-location}
◊code:lisp{
(define (expand-store high-location s)
  (update s 0 high-location) )

(define (new-location s)
  (+ 1 (s 0) ) )
}

Как~видим, адрес последней выделенной ячейки хранится в~памяти по~адресу~0.
Память фактически отзывается на~два типа сообщений:
запрос адреса свободной ячейки (при~передаче~нуля)
и~запрос значения по адресу (при~передаче иных~адресов) —
просто и удобно для реализации.
Естественно, также необходимо определить изначальное состояние памяти,
где не~выделено ни~одной~ячейки:

◊indexC{s.init}
◊code:lisp{
(define s.init
  (expand-store 0 (lambda (a) (wrong "No such address" a))) )
}
