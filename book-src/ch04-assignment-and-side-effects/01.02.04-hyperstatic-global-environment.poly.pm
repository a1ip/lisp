#lang pollen

◊subsubsection[#:label "assignment/assignment/free-vars/sssect:hyperstatic"]{Гиперстатическое глобальное~окружение}

◊indexR{глобальное окружение!гиперстатическое}
◊indexR{окружение!глобальное!гиперстатическое}
◊indexR{гиперстатическое окружение}
Возможен ещё один вариант глобального окружения:
здесь с~одним именем может быть связано несколько переменных,
однако~новые определения видны только последующим формам.
Вернёмся к~нашему любимому примеру:

◊; TODO: вот тут особенно внимательно с выравниванием колоночек
◊code:lisp{
g                           ; ошибка: неизвестная переменная ◊ic{g}
(define (P m) (* m g))      ; ошибка: неизвестная переменная ◊ic{g}
(define g 10)
(define (P m) (* m g))
(P 10)           ◊(is) 100
(define g 9.81)
(P 10)           ◊(is) 100     ; ◊ic{P} использует старое значение ◊ic{g}
(define (P m) (* m g))
(P 10)           ◊(is) 98.1
(set! e 2.78)               ; ошибка: неизвестная переменная ◊ic{e}
}

◊indexR{замыкания (closures)}
Здесь фраза «замыкание сохраняет свободные переменные из окружения своего определения» понимается буквально.
При первом определении~◊ic{P} в~окружении ◊nobr{нет~переменной~◊ic{g} — ошибка}.
Можно было~бы разрешить такое определение, а~сигнализировать об~ошибке только при фактическим вызове~◊ic{P}.
Однако так делать не~стоит, потому что ◊ic{g} — это не~динамическая переменная:
если ◊ic{g}~не~существовала при создании замыкания, то~она не~появится и при~вызове.
Незачем откладывать на~потом сообщение об~очевидно ошибочном определении.

Второе определение~◊ic{P} запоминает, что ◊ic{g} равна~10 в~текущем окружении.
В~замыкании сохраняется именно этот факт: «свободная переменная~◊ic{g} имеет значение~◊ic{10}».
Если мы захотим уточнить определение~◊ic{g}, нам потребуется переопределить и~◊ic{P}, чтобы она захватила новое значение.
Глобальное окружение подчиняется лексическим правилам определения области видимости.
Именно такое ◊term{гиперстатическое} окружение использует~ML.
Запишем его свойства в~виде привычной таблицы:

◊envtable{
  ◊tr{◊td{Ссылка}      ◊td{◊ii{x}, но~◊ii{x} должна существовать}                       }
  ◊tr{◊td{Значение}    ◊td{◊ii{x}, но~◊ii{x} должна существовать}                       }
  ◊tr{◊td{Изменение}   ◊td{◊nobr{◊ic{(set! ◊ii{x} ...)}}, но~◊ii{x} должна существовать}}
  ◊tr{◊td{Расширение}  ◊td{◊ic{define}}                                                 }
  ◊tr{◊td{Определение} ◊td{запрещено}                                                   }
}

◊indexR{рекурсия!взаимная}
Однако теперь у~нас возникают проблемы с~рекурсивными определениями,
как~простых рекурсивных функций, так~и взаимно рекурсивных групп.
ML~решает это затруднение с~помощью ключевого слова ◊ic{rec} для простой рекурсии,
комбинируя его с~◊ic{and} для одновременных определений.
В~Scheme присутствуют аналогичные формы ◊ic{let} и ◊ic{letrec}.
Гиперстатическое окружение в~принципе эквивалентно вложенным связывающим~формам:

◊code:lisp{
g                                ; ошибка: неизвестная переменная ◊ic{g}
(let ((P (lambda (m) (* m g))))  ; ошибка: неизвестная переменная ◊ic{g}
  (let ((g 10))
    (let ((P (lambda (m) (* m g))))
      (P 10)
      (let ((g 9.81))
        ... ) ) ) )
}

Для полноты картины рассмотрим пример со~взаимной рекурсией.
Следующая программа на~ML:

◊code:ml{
let rec odd n = if n = 0 then false else even (n - 1)
    and even n = if n = 0 then true else odd (n - 1)
}

◊noindent
чуть~ли не~слово в~слово повторяется на~Scheme:

◊code:lisp{
(letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
         (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
  ... )
}

Гиперстатическое окружение обладает очевидным преимуществом:
обращения к~неопределённым переменным обнаруживаются статически.
Кроме~того, становится очень легко обнаружить фактически неизменяемые переменные,
что позволяет применять различные оптимизации, основанные на подстановке значений переменных.
Тем не~менее, у~гиперстатического окружения есть и~недостатки:
например, необходимость повторять все затронутые определения после исправления~ошибки в~одном из~предыдущих.
