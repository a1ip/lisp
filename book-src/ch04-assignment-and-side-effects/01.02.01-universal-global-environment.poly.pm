#lang pollen

◊subsubsection*[#:label "assignment/assignment/free-vars/sssect:universal"]{Всеобъемлющее глобальное~окружение}

◊indexR{глобальное окружение!всеобъемлющее}
◊indexR{окружение!глобальное!всеобъемлющее}
◊indexR{всеобъемлющее окружение}
Глобальное окружение можно определить так, что все возможные переменные уже предварительно объявлены.
При упоминании новой переменной реализация автоматически добавляет её в~глобальное окружение,
как~если~бы она там присутствовала изначально.
◊seeCite{que95}
В~таком мире с~каждым именем связана одна и~только одна глобальная переменная.
Определение переменных здесь не~имеет смысла — все~переменные уже определены.
Присваивание переменным тоже не~вызывает проблем: мы~уверены, что изменяемая переменная существует.
Соответственно, форма ◊ic{define} фактически эквивалентна ◊ic{set!}
и,~как~следствие, можно без~проблем «определять» переменную несколько~раз.

Единственная проблема возникает тогда, когда мы хотим получить значение переменной,
но~этой переменной никогда не~присваивали значения.
Видишь переменную? Она~есть — а~значения~нет. ◊; TODO: шуточку поумнее?
Часто результатом такой операции является сообщение о~«неопределённой переменной»,
хотя строго говоря, переменная-то определена, просто ещё не~была инициализирована.

Свойства такого глобального окружения можно компактно представить следующей таблицей:

◊; TODO: вот где-то ты используешь ◊ii{x}, а где-то ◊${x} -- хорошо бы сделать одинаково
◊; TODO: ещё бы было круто сделать ◊(eq) таким же как ◊${\equiv}, наверное
◊envtable{
  ◊tr{◊td{Ссылка}      ◊td{◊ii{x}}                                  }
  ◊tr{◊td{Значение}    ◊td{◊ii{x}}                                  }
  ◊tr{◊td{Изменение}   ◊td{◊ic{(set! ◊ii{x} ...)}}                  }
  ◊tr{◊td{Расширение}  ◊td{запрещено}                               }
  ◊tr{◊td{Определение} ◊td{отсутствует, ◊ic{define} ◊(eq) ◊ic{set!}}}
}

Подобный вариант окружения по-своему интересен, так~как здесь многие проблемы перестают существовать в~принципе.
Взаимно рекурсивные функции всегда смогут добраться друг до~друга.
Любую переменную можно легко переопределить при необходимости.
Однако эти~же свойства являются источником новых увлекательных проблем.
С~глобальными переменными требуется быть осторожным, так~как
1)~они~могут~быть ещё не~определены (при~первом обращении нужны проверки);
2)~любая~переменная может быть переопределена — то~есть нельзя полагаться на неизменность значений переменных.
В~частности, нельзя применять оптимизации вроде ◊term{инлайн-функций},
ведь в~случае изменения значений переменных ◊ic{car} или~◊ic{cons}
по-хорошему требуется перекомпилировать всю~программу.

Наконец, рассмотрим наглядный пример поведения переменных в~глобальном окружении:

◊; TODO: стрелочки, красивые
◊code:lisp{
g                           ; ошибка: ◊ic{g} не инициализирована
(define (P m) (* m g))
(define g 10)
(define g 9.81)             ; ◊(eq) ◊ic{(set! g 9.81)}
(P 10)           ◊(is) 98.1
(set! e 2.78)               ; определение ◊ic{e}
}

Короче говоря, глобальное окружение можно понимать как гигантскую форму~◊ic{let}, определяющую все возможные переменные:

◊code:lisp{
(let (... a aa ... ab ... ac ...)
  ◊ii{программа}... )
}
