% -*- coding: utf-8 -*-

◊section[#:label "denotational/sect:semantics"]{Семантика Scheme}

◊indexC{evaluate}
По~результатам демократических обсуждений, представителем денотаций было избрано
◊${\lambda}-исчисление.
Предыдущий интерпретатор написан на Scheme без побочных
эффектов.
Его сердце — это функция-вычислитель ◊ic{evaluate}, имеющая вот
такой~тип:
%
◊[
  ◊text{◊ic{evaluate}:} ◊quad
      ◊Vset{Программа}   ◊times ◊Vset{Окружение} ◊times
      ◊Vset{Продолжение} ◊times ◊Vset{Память}    ◊to ◊Vset{Значение}
◊]

Первый аргумент (программу) можно легко каррировать, переходя к~следующему типу:
%
◊[ ◊Vset{Программа} ◊to
  (◊Vset{Окружение} ◊times ◊Vset{Продолжение}
                    ◊times ◊Vset{Память}      ◊to ◊Vset{Значение})
◊]

◊indexR{контекст вычислений}
◊indexR{вычисления!контекст}
◊indexR{Денотация@◊protect◊Vset{Денотация}}
Каждая программа превращается в~функцию, которая по окружению, продолжению и
памяти (вместе они называются ◊term{контекстом вычислений}) может сказать нам
возвращаемое значение.
Это похоже на понятие смысла программы, так что
остановимся на таком определении:
%
◊begin{align*}
& ◊ii{интерпретация}◊colon ◊quad ◊Vset{Программа} ◊to ◊Vset{Денотация} ◊◊
& ◊Vset{Денотация}◊colon ◊quad ◊Vset{Окружение} ◊times ◊Vset{Продолжение}
                               ◊times ◊Vset{Память} ◊to ◊Vset{Значение}
◊end{align*}

◊indexR{соглашения именования!в~денотациях}
Люди, серьёзно занимающиеся денотационной семантикой, не~особо любят скобочки
и имеют своеобразные предпочтения в~наименовании сущностей.
Прежде всего,
они (повсюду) используют греческие буквы и сокращают всё, что только можно.
В~итоге, для непосвящённых их записи выглядят загадочным набором иероглифов.
Причиной таких привычек служит то, что подобная запись позволяет уместить
семантику языка на одной-единственной странице, где она как на~ладони.
Это
преимущество◊footnote{Очень полезное преимущество, если учесть, что средний
размер научной публикации — это около десяти страниц.} недостижимо, если
использовать пространные названия и лишние символы.
Греческие~же буквы выбраны
для того, чтобы не~путать денотации с~выражениями определяемого языка.
Так как
чаще всего денотационная семантика используется для определения языков
программирования, алфавит которых ограничен~ASCII, то греческие буквы являются
хорошим выбором: они компактные и выделяющиеся.
Наконец, для уменьшения
количества ошибок денотации являются типизированными, их тип выводится из имён
переменных.

◊indexR{а льфа@◊${◊a} (адреса)}     ◊indexE{a lpha@◊${◊a} (адреса)}
◊indexR{э псилон@◊${◊e} (значения)} ◊indexE{e psilon@◊${◊e} (значения)}
◊indexR{р о@◊${◊r} (окружение)}     ◊indexE{r ho@◊${◊r} (окружение)}
◊indexR{с игма@◊${◊s} (память)}     ◊indexE{s igma@◊${◊s} (память)}
◊indexR{н ю@◊${◊n} (переменные)}    ◊indexE{n u@◊${◊n} (переменные)}
◊indexR{п и@◊${◊p} (программы)}     ◊indexE{p i@◊${◊p} (программы)}
◊indexR{к аппа@◊${◊k} (продолжения)}◊indexE{k appa@◊${◊k} (продолжения)}
◊indexR{ф и@◊${◊f} (функции)}       ◊indexE{p hi@◊${◊f} (функции)}
Мы тоже будем следовать этим соглашениям.
По~давней традиции функции
обозначаются буквой~◊${◊f}.
Остальные сущности обычно именуют по первой букве их
английского названия: ◊${◊k} для продолжений, ◊${◊a} для адресов, ◊${◊n} для
идентификаторов (name), ◊${◊p} для программ, ◊${◊s} для памяти (store или state).
Попробуйте самостоятельно догадаться, почему окружения обозначаются буквой~◊${◊r}.
%
◊begin{center} ◊begin{tabular}{ll|ll}
  ◊${◊p} & ◊Vset{Программы}    &  ◊${◊r} & ◊Vset{Окружения}  ◊◊
  ◊${◊n} & ◊Vset{Переменные}   &  ◊${◊a} & ◊Vset{Адреса}     ◊◊
  ◊${◊s} & ◊Vset{Память}       &  ◊${◊e} & ◊Vset{Значения}   ◊◊
  ◊${◊k} & ◊Vset{Продолжения}  &  ◊${◊f} & ◊Vset{Функции}
◊end{tabular} ◊end{center}

◊indexR{домены}
◊indexR{Программы@◊Vset{Программы}}
◊indexR{Окружения@◊Vset{Окружения}}
◊indexR{Переменные@◊Vset{Переменные}}
◊indexR{Адреса@◊Vset{Адреса}}
◊indexR{Память@◊Vset{Память}}
◊indexR{Значения@◊Vset{Значения}}
◊indexR{Продолжения@◊Vset{Продолжения}}
◊indexR{Функции@◊Vset{Функции}}
Каждое слово, набранное жирным шрифтом, соответствует ◊term{домену} объектов.
Здесь присутствуют все классы объектов, которые мы рассматривали в~предыдущих
главах.
%
◊begin{align*}
  ◊Vset{Окружение} & = ◊Vset{Переменная} ◊to ◊Vset{Адрес}                     ◊◊
     ◊Vset{Память} & = ◊Vset{Адрес} ◊to ◊Vset{Значение}                       ◊◊
   ◊Vset{Значения} & = ◊Vset{Функции} + ◊Vset{Числа} + ◊Vset{Пары} + ◊cdots   ◊◊
◊Vset{Продолжение} & = ◊Vset{Значение}◊times ◊Vset{Память} ◊to ◊Vset{Значение}◊◊
    ◊Vset{Функция} & = ◊Vset{Значения}^* ◊times ◊Vset{Продолжение}
                                         ◊times ◊Vset{Память} ◊to◊Vset{Значение}
◊end{align*}

◊indexR{приведение типов}
◊indexR{инъекция, ◊${◊Inj{Домен}(x)}}
◊indexR{проекция, ◊${x◊Prj{Домен}}}
◊indexE{-inj@◊${◊Inj{Домен}(x)} (инъекция)}
◊indexE{-proj@◊${x◊Prj{Домен}} (проекция)}
Как~обычно, звёздочка означает список.
Например, домен~◊${◊Vset{Значения}^*} —
это домен последовательностей ◊Vset{Значений}.
Символ~◊${◊times} означает
декартово произведение.
Символ~◊${+} означает дизъюнктивную сумму; то~есть
◊Vset{Значение} — это или~◊Vset{Функция}, или~◊Vset{Число}, или~◊Vset{Пара},
{◊itd} Это важное свойство дизъюнктивной суммы: каждый элемент
домена~◊Vset{Значений} принадлежит одному и только одному из доменов,
составляющих дизъюнктивную сумму.
Так как мы считаем сущности типизированными,
то необходимо чётко обозначать переходы между доменами.
Инъекция
◊${◊Inj{Значение}(◊e)} переносит терм~◊${◊e} в~домен~◊Vset{Значений}, а проекция
◊${◊e◊Prj{Числа}} отображает значение~◊${◊e} на~домен~◊Vset{Чисел} (конечно~же,
если ◊${◊e} ему действительно принадлежит).

◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!математическая модель}
Домены определяются рекурсивно — это важно с~математической точки зрения;
именно по этой и некоторым другим причинам они называются доменами, а не~просто
множествами.
Не~особо углубляясь в~детали, скажем, что ◊${\lambda}-исчисление
было разработано Алонзо~Чёрчем в~1930-х~годах, но ему не~хватало строгой
математической модели — она была построена Даной~Скоттом около 1970~года.
◊${\lambda}-исчисление ещё тогда доказало свою полезность, но с~математической
моделью оно стало идеальным.
Со~временем были разработаны и другие модели:
◊${D_◊infty}, ◊${◊mathcal{P}\omega}.
◊cite{sco76,sto77}

◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!экстенсиональность}
◊indexR{эта-редукция@◊${◊eta}-редукция}
◊indexR{экстенсиональность}
◊term{Экстенcиональность} это свойство функций $◊forall x◊colon ◊big(f(x) =
g(x)◊big) ◊Rightarrow (f = g)$.
Оно связано с~◊${◊eta}-редукцией — одним
из вспомогательных правил ◊${\lambda}-исчисления:
%
◊[
  ◊text{◊${◊eta}-редукция:}
      ◊quad \lambda x . (M◊ x) ◊to*{◊eta} M
      ◊quad ◊text{где ◊${x} не~свободна в~◊${M}}
◊]
%
Удивительно, но есть как экстенсиональные модели вроде ◊${D_◊infty}, так и нет;
например, ◊${◊mathcal{P}\omega} не~экстенсиональна.
Интересно, а наш мир
экстенсионален?

Дана~Скотт показал, что любая формальная система, рекурсивно определяемая
через домены с~помощью ◊${◊to}, ◊${◊times}, ◊${+} и~◊${{}^*}, является алгоритмически
разрешимой: то~есть истинность любого корректного утверждения в~ней можно
доказать или опровергнуть за конечное число шагов.

◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!композициональность}
◊indexR{композициональность!лямбда-исчисления@◊${\lambda}-исчисления}
Ещё один важный принцип денотационной семантики — это
◊term{композициональность}: смысл фрагмента программы зависит только от смысла
составляющих его частей.
Он очень важен для индуктивного метода доказательства и
не~только: это удобно для реализации, когда программы не~зависят от контекста.

◊indexE{"["]@◊${[◊![}◊quad◊${]◊!]} (семантические скобки)}
◊indexE{E-@◊${◊Eval}, интерпретатор}
◊indexR{интерпретатор!E@◊${◊Eval}}
Функцию-интерпретатор обычно обозначают~◊${◊Eval}.
Чтобы отличать программы от их
семантики, фрагменты программ будут заключаться в~семантические скобки:
◊${[◊![}~и~◊${]◊!]}.
Теперь мы наконец-то перейдём к~разбору форм одна за другой.


◊subsection[#:label "denotational/semantics/ssect:var-ref"]{Обращения к~переменным}

Простейшая из денотаций — получение значения переменной:

◊begin{denotation}
◊${◊Eval◊sem{◊n} = \lambda◊r◊k◊s.(◊k◊ (◊s◊ (◊r◊ ◊n))◊ ◊s)}
◊end{denotation}

Денотация ссылки на переменную (с~именем~◊${◊n}) это ◊${\lambda}-терм, который по
окружению~◊${◊r}, продолжению~◊${◊k} и~памяти~◊${◊s} определяет сначала адрес
расположения переменной с~помощью окружения: ◊${(◊r◊ ◊n)}, потом передаёт адрес
памяти для получения значения: ◊${(◊s◊ (◊r◊ ◊n))}, затем, наконец, передаёт
значение продолжению вместе с~исходной памятью (так как чтение её не~меняет).

Здесь мы воспользовались упомянутым ранее сокращением для функций нескольких
аргументов.
Конечно, можно было~бы писать более строго:

◊begin{denotation}
◊${◊Eval◊sem{◊n} = \lambda◊r.\lambda◊k.\lambda◊s.(◊k◊ (◊s◊ (◊r◊ ◊n))◊ ◊s)}
◊end{denotation}

Нам нет смысла выставлять напоказ свою педантичность, поэтому мы не~будем
использовать подобную запутанную запись.
В~действительности, мы её ещё сильнее
упростим, приняв синтаксис, похожий на~◊ic{define}:

◊begin{denotation}
◊${◊Eval◊sem{◊n}◊r◊k◊s = (◊k◊ (◊s◊ (◊r◊ ◊n))◊ ◊s)}
◊end{denotation}

◊indexR{р о0@◊${◊r_0} (начальное окружение)}
◊indexE{r ho0@◊${◊r_0} (начальное окружение)}
Конечно, обязательно надо учитывать возможность ошибки: переменной может
не~оказаться в~окружении.
С~этим будет разбираться начальное окружение~◊${◊r_0}:

◊begin{denotation}
◊${(◊r_0◊ ◊n) = ◊ii{wrong}◊ ◊dc{"No such variable"}}
◊end{denotation}

◊indexE{.bot@◊${◊bot}}
◊indexR{строгие функции}
◊indexR{функции!строгие}
◊indexE{wrong@◊ii{wrong}}
Если переменная не~будет обнаружена в~окружении, то вызывается ◊ii{wrong},
которая в~свою очередь вернёт особое значение, обычно обозначаемое~◊${◊bot}.
Это
значение является в~некотором смысле абсорбентом, то~есть $◊forall f◊colon
f(◊bot) = ◊bot$.
Следовательно, если возникает ошибка, то всё вычисление
возвращает~◊${◊bot}, что явно сигнализирует о~проблеме.
На самом деле, это
не~◊${◊bot} само по себе имеет такое свойство, а функции так с~ним обращаются
(в~этом случае они называются ◊term{строгими}).
Функция~◊${f} строга тогда и
только тогда, когда ◊${f(◊bot) = ◊bot}.
Если условиться использовать только
строгие функции, то это избавит нас в~определённой мере от обработки ошибок и
позволит сконцентрироваться на более важных вещах.


◊subsection[#:label "denotational/semantics/ssect:sequence"]{Последовательность}

◊indexR{интерпретатор!Eplus@◊${◊Eval^+}}
◊indexE{E-plus@◊${◊Eval^+}, интерпретатор}
Денотация последовательных вычислений как обычно вызывает вспомогательную
функцию, которой в~предыдущих интерпретаторах соответствует функция ◊ic{eprogn}.
Мы будем обозначать~её~◊${◊Eval^+}.
С~плюсом, потому что в~форме ◊ic{begin} должен
присутствовать хотя~бы один элемент.
Аналогично будем обозначать
последовательность непустых форм:~◊${◊p^+}.
Интерпретатор~◊${◊Eval^+} превращает
◊${◊p^+} в~денотацию, которая вычисляет все элементы слева направо и возвращает
значение последнего из~них.
Его работа сводится к~двум случаям: когда ◊${◊p^+}
состоит из одной и более чем одной формы.
В~Scheme смысл ◊ic{(begin)}
не~определён, поэтому и здесь такого случая нет в~определении.

◊begin{denotation}
◊${◊Eval◊sem*{(begin }◊p^+◊${)}◊r◊k◊s = (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊k◊ ◊s)}          ◊|
◊${◊Eval^+◊sem{◊p}◊r◊k◊s = (◊Eval◊sem{◊p}◊ ◊r◊ ◊k◊ ◊s)}                         ◊|
$◊Eval^+◊sem{◊p◊ ◊p^+}◊r◊k◊s = ◊big(◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
    (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊k◊ ◊s_1)◊ ◊s◊big)$
◊end{denotation}

◊indexR{эта-упрощение@◊${◊eta}-упрощение}
Если последовательность состоит из одного элемента, то она эквивалентна данному
элементу.
Можно было~бы записать это буквально:

◊begin{denotation}
◊${◊Eval^+◊sem{◊p} = ◊Eval◊sem{◊p}}
◊end{denotation}

В~◊${\lambda}-исчислении это называется ◊${◊eta}"=упрощением.
Мы будем избегать
подобных фокусов, так как они затрудняют понимание программ, а также скрывают
естественную арность функций; как говорят~◊cite{wl93}, часто так пишут только
чтобы выглядеть умнее.

Если последовательность состоит из более чем одного элемента, то вычисляется
значение первого из них и управление передаётся продолжению, которое должно
вычислить все остальные.
Тут — в~одной строке! "--- ещё раз можно увидеть,
что продолжение игнорирует вычисленное ранее значение, но не~состояние памяти
после его вычисления.
В~конечном итоге именно продолжения позволяют упорядочить
вычисления.


◊subsection[#:label "denotational/semantics/ssect:conditional"]{Ветвление}

◊indexE{T@◊comb{T}, комбинатор}
◊indexE{F@◊comb{F}, комбинатор}
◊indexR{комбинаторы}
◊indexR{комбинаторы!T@◊comb{T}}
◊indexR{комбинаторы!F@◊comb{F}}
◊indexR{логические значения!в лямбда-исчислении@в ◊${\lambda}-исчислении}
◊indexR{представление!логических значений!в лямбда-исчислении@в ◊${\lambda}-исчислении}
Денотация условного оператора довольно стандартна и не~представляет трудностей,
если знать, как представить булевы значения с~помощью абстракций
◊${\lambda}-исчисления.
На~самом деле это не~так сложно: мы определим их как
комбинаторы (то~есть функции без свободных переменных).
%
◊[ ◊comb{T} = \lambda xy.
x
      ◊quad ◊text{и} ◊quad
   ◊comb{F} = \lambda xy.
y ◊]

◊indexE{If@◊${◊mathbf{If}} (логическая операция)}
Эти функции принимают два аргумента и выбирают один из них в~качестве
результата.
Это напоминает логическую операцию ◊${◊mathbf{If}}, определяемую
уравнениями
%
◊[ ◊mathbf{If}(◊fn{истина}, p, q) = p
              ◊quad ◊text{и} ◊quad
   ◊mathbf{If}(◊fn{ложь}, p, q) = q ◊]

Внимание: это не~имеет ничего общего с~◊ic{if} в~Scheme.
В~этом определении
ничего не~говорится о~порядке вычислений, только о~том, что ◊${◊mathbf{If}} это
булева функция; её можно определить с~помощью той~же таблицы истинности, но
более коротко она описывается вот так:
%
◊[ ◊mathbf{If}(c, p, q) = (◊neg c ◊lor p) ◊land (c ◊lor q) ◊]

◊indexR{комбинаторы!IF@◊comb{IF}}
◊indexE{IF@◊comb{IF}, комбинатор}
Благодаря выбранному представлению булевых значений, мы можем легко перенести
◊${◊mathbf{If}} в~◊${\lambda}-исчисление, написав следующий комбинатор:
%
◊[ ◊comb{IF}◊ c◊ p◊ q = (c◊ p◊ q) ◊]

Как и в~логике, здесь ничего не~сказано о~порядке вычислений, только
об отношениях между тремя значениями.
Если понимать ◊${◊mathbf{If}} как функцию,
то она возвращает второй аргумент, если первый является истиной, и третий
в противном случае.
Вслед за~◊cite{fw84}, мы будем называть такую
функцию~◊ic{ef}.
На~Scheme она~бы записывалась так:
%
◊indexC{ef}
◊indexE{if@◊ic{if}|seealso{◊ic{ef}}}
◊code:lisp{
(define (ef v v1 v2)
  (v v1 v2) )
}

Чтобы сделать запись более понятной, подобный выбор будем записывать
как~в~◊cite{sch86}:

◊begin{denotation}
◊${◊e_0 ◊is ◊e_1 ◊switch ◊e_2}
◊end{denotation}

◊noindent
В~{◊RnRS} применяется немного другая нотация:

◊begin{denotation}
◊${◊e_1 ◊is ◊e_2, ◊e_3}
◊end{denotation}

Держа всё это в~уме, определим денотацию условного оператора:

◊begin{denotation}
◊${◊Eval◊sem*{(if }◊p◊${ }◊p_1◊${ }◊p_2◊${)}◊r◊k◊s =}                                 ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
(◊fn{boolify}◊ ◊e) ◊to
  (◊Eval◊sem{◊p_1}◊ ◊r◊ ◊k◊ ◊s_1) ◊switch (◊Eval◊sem{◊p_2}◊ ◊r◊ ◊k◊ ◊s_1)◊ ◊s)$
◊end{denotation}

◊indexE{boolify@◊ii{boolify}}
◊indexR{порядок вычислений!в лямбда-исчислении@в ◊${\lambda}-исчислении}
Функция ◊fn{boolify} приводит значение к~булевому типу, так как в~Scheme любое
значение, кроме~◊ic{#f}, считается истиной.
Условный оператор начинает работу
с~вычисления условия с~продолжением, которое выбирает нужную ветку
в~соответствии со~значением условия.
Внимание: условный оператор
в~◊${\lambda}-исчислении только выглядит похожим на ◊ii{if}--◊ii{then}--◊ii{else}
из~Scheme, они отличаются очень важной деталью: порядком вычислений.
В~◊${\lambda}-исчислении он абсолютно произвольный, ничто не~мешает параллельно
вычислять все три выражения и выбирать одну из двух веток только в~конце всех
вычислений.

◊indexE{Scheme!и лямбда-исчисление@и~◊${\lambda}-исчисление}
Это очень важное замечание, так как мы не~можем считать ◊${\lambda}-исчисление
(и,~следовательно, определяемый нами язык) полностью эквивалентным Scheme.
В~◊${\lambda}-исчислении вообще нет понятия порядка вычислений, просто условная
форма может принять одно из двух значений; какое именно — зависит от первого
аргумента.

◊indexR{порядок вычислений}
Тем не~менее, отсутствие порядка не~мешает правильности вычислений, так как
переменные обеих веток изолированы, а функции ◊${\lambda}-исчисления не~имеют
побочных эффектов.
Например, следующее выражение вполне успешно вычисляется,
хотя кажется, что если вычислять его параллельно или в~«неправильном» порядке,
то нас ожидает провал:

◊code:lisp{
(if (= 0 q) 1 (/ p q))
}

Это выражение сначала проверяет, равна~ли~◊ic{q} нулю, и, если это так, то
возвращает единицу, иначе — выполняет деление ◊ic{p} на~◊ic{q} и возвращает
его результат.
Денотация данного вычисления выражает выбор между ◊${1} и~◊${p/q}
в~зависимости от того, равна~ли ◊${q}~нулю.

Из-за «плохого» порядка вычислений, принятого в~Scheme, денотацию этой формы
иногда сложно понимать, так как от неё ожидается вычисление условия перед телом,
а не~вычисление всего сразу вместе с~возможными вариантами подобно квантовым
компьютерам.
Поэтому мы перепишем денотацию следующим образом:

◊begin{denotation}
◊${◊Eval◊sem*{(if }◊p◊${ }◊p_1◊${ }◊p_2$)}◊r◊k◊s =
  (◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
((◊fn{boolify}◊ ◊e) ◊to
    ◊Eval◊sem{◊p_1} ◊switch ◊Eval◊sem{◊p_2}◊ ◊r◊ ◊k◊ ◊s_1)◊ ◊s)$
◊end{denotation}

Здесь вводится некоторый порядок вычислений.
Теперь значение условия служит
только для выбора нужной ветки — собственно вычисление значения выполняется
отдельно и один раз.

Попробуем проверить, эквивалентны~ли данные определения.
Для этого достаточно
будет доказать эквивалентность их денотаций, иными словами, показать, что
%
◊[
  (◊fn{boolify}◊ ◊e) ◊to (◊Eval◊sem{◊p_1}◊ ◊r◊ ◊k◊ ◊s)
      ◊switch (◊Eval◊sem{◊p_2}◊ ◊r◊ ◊k◊ ◊s)
  ◊equiv
  ((◊fn{boolify}◊ ◊e) ◊to ◊Eval◊sem{◊p_1} ◊switch
      ◊Eval◊sem{◊p_2}◊ ◊r◊ ◊k◊ ◊s)
◊]

Это тождество очевидно ложно в~Scheme из-за аппликативного порядка вычислений.
Для доказательства достаточно положить ◊${◊p_2} равной бесконечному циклу.
Но
денотации — это выражения ◊${\lambda}-исчисления, и сравнивать их следует по
законам ◊${\lambda}-исчисления.
В~этом случае мы видим простейший дистрибутивный
закон.

◊indexE{if-then-else-endif@$◊IF◊ldots◊THEN◊ldots%
◊ELSE◊ldots◊ENDIF$}
Надеюсь, иероглифов было достаточно.
Далее будет использоваться более
читабельная запись условных выражений:

◊begin{denotation}
◊${◊Eval◊sem*{(if }◊p◊${ }◊p_1◊${ }◊p_2$)}◊r◊k◊s =
  (◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
(◊${◊.}◊IF    (◊fn{boolify}◊ ◊e)$  ◊◊
                                         ◊${◊THEN  ◊Eval◊sem{◊p_1}   }  ◊◊
                                         ◊${◊ELSE  ◊Eval◊sem{◊p_2}   }  ◊◊
                                         ◊${◊ENDIF ◊r◊ ◊k◊ ◊s_1)◊ ◊s)}
◊end{denotation}


◊subsection[#:label "denotational/semantics/ssect:assign"]{Присваивание}

Денотация присваивания проста.
Версия, приведённая здесь, возвращает только что
присвоенное значение.

◊begin{denotation}
◊${◊Eval◊sem*{(set! }◊n◊${ }◊p$)}◊r◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
(◊k◊ ◊e◊ ◊s_1[(◊r◊ ◊n) ◊to ◊e])◊ ◊s)$  ◊|
◊${f[y ◊to z] = \lambda x .}{}◊${◊IF y = x ◊THEN z ◊ELSE (f◊ x) ◊ENDIF}
◊end{denotation}

◊indexE{->@◊${◊s[◊a ◊to ◊e]} (расширение окружения)}
Память расширяется, чтобы учесть новое значение~◊${◊e} по адресу переменной~◊${◊n}.
Мы обозначаем это расширение ◊${◊s[◊a ◊to ◊e]}.
Подобная нотация используется и
в~других работах: ◊${[◊a ◊to ◊e]◊s} в~◊cite{sch86}, ◊${[◊e/◊a]◊s} в~◊cite{sto77}
или~◊${◊s[◊e/◊a]} в~◊cite{gor88,kcr98}.

◊indexE{-e<>@◊${◊seq{◊e^*_1, ◊ldots, ◊e^*_n}} (последовательность)}
◊indexE{-eS@◊${◊e^*_1 ◊append ◊e^*_2} (конкатенация)}
◊indexE{-ea@◊${◊e^*◊car n} (денотационный ◊ic{car})}
◊indexE{-ed@◊${◊e^*◊cdr n} (денотационный ◊ic{cdr})}
◊indexE{-el@◊${#◊e^*} (длина последовательности)}
Давайте расширим ◊${\lambda}-исчисление несколькими вспомогательными функциями.
Последовательности будем записывать в~угловых скобках: ◊${◊langle}~и~◊${◊rangle}.
Конкатенацию последовательностей будем обозначать знаком~◊${◊append}.
Извлечение
◊${i}-го элемента последовательности будем обозначать $◊seq{◊e_1, ◊e_2, ◊dots,
◊e_n}◊car i◊${ (получая~}◊e_i$).
Отбрасывание первых ◊${i} элементов
последовательности — ◊${◊seq{◊e_1, ◊e_2, ◊dots, ◊e_n}◊cdr i} (получая
◊${◊seq{◊e_{i+1}, ◊dots, ◊e_n}}).
Длина последовательности~◊${◊e^*}
записывается~◊${#◊e^*}.
Все эти определения можно было~бы привести
непосредственно в~виде ◊${\lambda}-термов, но это стало~бы чересчур серьёзным
отступлением от темы, поэтому, ничуть не~умаляя достоверности повествования, мы
сходу будем использовать ◊${◊car 1}, ◊${◊cdr 1}, ◊${#} и~◊${◊append} как денотационные
эквиваленты ◊ic{car}, ◊ic{cdr}, ◊ic{length} и~◊ic{append}.

◊indexE{->*@◊${◊s[◊a^* ◊to*{*} ◊e^*]} (расширение окружения списком)}
Теперь можно коротко записать расширение памяти списком переменных.
Предполагается, что ◊${y^*} и~◊${z^*} имеют равную длину.

◊begin{denotation}
$f[y^* ◊to*{*} z^*] = ◊;
  ◊IF #y^* > 0
  ◊THEN f[y^*◊cdr1 ◊to*{*} z^*◊cdr1][y^*◊car1 ◊to z^*◊car1]
  ◊ELSE f
  ◊ENDIF $
◊end{denotation}

◊subsection[#:label "denotational/semantics/ssect:abstraction"]{Абстракция}

Для начала рассмотрим лишь случай функций фиксированной арности.

◊begin{denotation}
◊${◊Eval◊sem*{(lambda (}◊n^*◊${) }◊p^+◊${)}◊r◊k◊s =}                ◊|
$◊quad(◊k◊ ◊Inj{Значение}(\lambda
    ◊e^*◊k_1◊s_1.◊${◊.}◊IF   #◊e^* = ◊#◊n^*$                   ◊◊
                    ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ #◊n^*} ◊◊
                                  $\lambda ◊s_2◊a^*.
                                  (◊Eval^+◊sem{◊p^+}◊ ◊r[◊n^* ◊to*{*}
                                  ◊a^*]◊ ◊k_1◊ ◊s_2[◊a^* ◊to*{*} ◊e^*])$ ◊/
                    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}◊◊
                    ◊${◊ENDIF)◊ ◊s)}
◊end{denotation}

Инъекция ◊${◊Inj{Значение}(◊ldots)} принимает ◊${\lambda}-терм, представляющий
функцию, и превращает его в~значение.
При применении функции производится
обратное преобразование.

◊indexE{allocate@◊ii{allocate}}
Вызванная функция проверят фактическую арность, затем выделяет место в~памяти
под свои аргументы и связывает переменные со~значениями, после чего
последовательно вычисляет формы, составляющие её тело.
Выделением памяти
занимается функция ◊ii{allocate}; она принимает память, необходимое количество
адресов и продолжение, которому она передаст список выделенных адресов и новое
состояние памяти.
◊ii{allocate} — это чистая функция: эквивалентные аргументы
дают эквивалентные результаты её применения.
Её~определение довольно рутинно,
так что здесь мы его опустим, чтобы не~перегружать выкладки.
(Интересующиеся
могут переписать определение ◊ii{allocate} из предыдущей главы.
◊seePage[assignment/implementation/ssect:memory])

Функция ◊ii{allocate} имеет следующий полиморфный тип (◊${◊alpha}~соответствует
любому типу данных):
%
◊[
  ◊Vset{Память} ◊times ◊Vset{НатуральноеЧисло} ◊times
    (◊Vset{Память} ◊times ◊Vset{Адреса}^* ◊to ◊alpha) ◊to ◊alpha
◊]


◊subsection[#:label "denotational/semantics/ssect:application"]{Аппликация}

◊indexR{интерпретатор!Eseq@◊${◊Eval^*}}
◊indexE{E-seq@◊${◊Eval^*}, интерпретатор}
Функции создаются для того, чтобы их применяли, поэтому на очереди аппликация.
Как~обычно, нам потребуется вспомогательный интерпретатор: ◊${◊Eval^*},
аналог~◊ic{evlis}.

◊begin{denotation}
◊${◊Eval◊sem*{(}◊p◊${ }◊p^*$)}◊r◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ \lambda ◊f◊s_1.
        (◊Eval^*◊sem{◊p^*}◊ ◊r◊ \lambda ◊e^*◊s_2.
            (◊f◊Prj{Функции}◊ ◊e^*◊ ◊k◊ ◊s_2)◊ ◊s_1)◊ ◊s)$  ◊|
◊${◊Eval^*◊sem{◊,}◊r◊k◊s = (◊k◊ ◊seq{}◊ ◊s)}                  ◊|
$◊Eval^*◊sem{◊p◊ ◊p^*}◊r◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ \lambda ◊e◊s_1.
        (◊Eval^*◊sem{◊p^*}◊ ◊r◊ \lambda ◊e^*◊s_2.
            (◊k◊ ◊seq{◊e} ◊append ◊e^*◊ ◊s_2)◊ ◊s_1)◊ ◊s)$
◊end{denotation}

Продолжения, которые принимает ◊${◊Eval^*}◊!, работают со~списками значений, а
не~с~отдельными значениями.
Это отличает ◊${◊Eval^*} от~◊${◊Eval^+}.
Данные
продолжения~◊${◊k} имеют тип
%
◊[ ◊Vset{Значения}^* ◊times ◊Vset{Память} ◊to ◊Vset{Значение} ◊]


◊subsection{◊texorpdfstring{◊ic{call/cc}}{call/cc}}%
◊label{denotational/semantics/ssect:call/cc}

Разумеется, наше знакомство с~денотационной семантикой было~бы неполным без
определения существенной для Scheme функции — ◊ic{call/cc}.
Глобальная
функция ◊ic{call/cc} определяется следующим образом:

◊indexC{call/cc}
◊begin{denotation}
◊${(◊s_0◊ (◊r_0◊ ◊sem*{call/cc})) = }                  ◊|
◊${◊quad◊Inj{Значение}(\lambda◊e^*◊k◊s.}◊.
                ◊${◊IF   #◊e^* = 1}                   ◊◊
                ◊${◊THEN (}◊.◊${◊e^*◊car1◊Prj{Функции}}  ◊◊
                        ◊${◊langle◊Inj{Значение}(\lambda◊e^*_1◊k_1◊s_1.}◊.
                                               $◊IF   #◊e^*_1 = 1
                                                ◊THEN (◊k◊ ◊e^*_1◊car1◊ ◊s_1)$◊◊
                                    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}◊◊
                                    ◊${◊ENDIF)◊rangle◊ ◊k◊ ◊s)}◊-◊-◊◊
                ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}  ◊◊
                ◊${◊ENDIF)}
◊end{denotation}

Обратите внимание на переходы между доменами ◊Vset{Значений} и~◊Vset{Функций}.
Сама денотация не~сложнее любого другого из способов определения ◊ic{call/cc},
которые были рассмотрены ранее в~третьей главе.
◊seePage[escape/implementation/ssect:call/cc]


◊subsection{Предварительные выводы}%
◊label{denotational/sematics/ssect:conclusions}

Нам удалось шаг за шагом определить функцию, которая ставит в~соответствие
каждой программе ◊${\lambda}-терм.
Не~подлежит сомнению тот факт, что она
существует, ведь мы руководствовались принципом композициональности при её
определении.
Возможны только некоторые проблемы с~синтаксически рекурсивными
программами ◊cite{que92a}, так что для точного доказательства корректности
потребуется немного больше математики.

Теперь вы можете своими глазами убедиться в~том, что семантика ядра Scheme
умещается на одном листе бумаги:
см.~таблицу~◊ref{denotational/sematics/fig:naked-scheme}.

◊begin{table}[!p]
◊indexE{Scheme!семантика}
◊begin{semantic}◊begin{denotation}
◊${◊Eval◊sem{◊n}◊r◊k◊s = (◊k◊ (◊s◊ (◊r◊ ◊n))◊ ◊s)}                       ◊~
◊${◊Eval◊sem*{(if }◊p◊${ }◊p_1◊${ }◊p_2$)}◊r◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
(◊${◊.}◊IF    (◊fn{boolify}◊ ◊e)$ ◊◊
                                           ◊${◊THEN  ◊Eval◊sem{◊p_1}   } ◊◊
                                           ◊${◊ELSE  ◊Eval◊sem{◊p_2}   } ◊◊
                                           ◊${◊ENDIF ◊r◊ ◊k◊ ◊s_1)◊ ◊s)} ◊-◊|
◊${◊Eval◊sem*{(set! }◊n◊${ }◊p$)}◊r◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
        (◊k◊ ◊e◊ ◊s_1[(◊r◊ ◊n) ◊to ◊e])◊ ◊s)$                          ◊~
◊${◊Eval◊sem*{(lambda (}◊n^*◊${) }◊p^+◊${)}◊r◊k◊s =}                         ◊|
◊${◊quad(◊k◊ ◊Inj{Значение}(\lambda◊e^*◊k_1◊s_1.}◊.
    ◊${◊IF   #◊e^* = ◊#◊n^*}                            ◊◊
    ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ #◊n^*}          ◊◊
             $\lambda ◊s_2◊a^*.
                (◊Eval^+◊sem{◊p^+}◊ ◊r[◊n^* ◊to*{*}
                ◊a^*]◊ ◊k_1◊ ◊s_2[◊a^* ◊to*{*} ◊e^*])$ ◊/
    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}         ◊◊
    ◊${◊ENDIF)◊ ◊s)}                                     ◊-◊|
◊${◊Eval◊sem*{(}◊p◊${ }◊p^*◊${)}◊r◊k◊s =}                         ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ \lambda ◊f◊s_1.
    (◊Eval^*◊sem{◊p^*}◊ ◊r◊ \lambda ◊e^*◊s_2.
        (◊f◊Prj{Функции}◊ ◊e^*◊ ◊k◊ ◊s_2)◊ ◊s_1)◊ ◊s)$      ◊~
◊${◊Eval^*◊sem{◊p◊ ◊p^*}◊r◊k◊s =}                             ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ \lambda ◊e◊s_1.
    (◊Eval^*◊sem{◊p^*}◊ ◊r◊ \lambda ◊e^*◊s_2.
        (◊k◊ ◊seq{◊e} ◊append ◊e^*◊ ◊s_2)◊ ◊s_1)◊ ◊s)$      ◊~
◊${◊Eval^*◊sem{◊,}◊r◊k◊s = (◊k◊ ◊seq{}◊ ◊s)}                             ◊~
◊${◊Eval◊sem*{(begin }◊p^+◊${)}◊r◊k◊s = (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊k◊ ◊s)}   ◊~
$◊Eval^+◊sem{◊p◊ ◊p^+}◊r◊k◊s = ◊big(◊Eval◊sem{◊p}◊ ◊r◊ \lambda◊e◊s_1.
    (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊k◊ ◊s_1)◊ ◊s◊big)$                        ◊~
◊${◊Eval^+◊sem{◊p}◊r◊k◊s = (◊Eval◊sem{◊p}◊ ◊r◊ ◊k◊ ◊s)}                  ◊~
◊${(◊s_0◊ (◊r_0◊ ◊sem*{call/cc})) = }                                    ◊|
◊${◊quad◊Inj{Значение}(}◊*$\lambda ◊e^*◊k◊s.
$                           ◊◊
                ◊${◊IF   #◊e^* = 1}                                     ◊◊
                ◊${◊THEN (}◊.◊${◊e^*◊car1◊Prj{Функции}}                    ◊◊
                        ◊${◊langle◊Inj{Значение}(}◊*◊${\lambda◊e^*_1◊k_1◊s_1.}    ◊◊
                                               ◊${◊IF   #◊e^*_1 = 1}           ◊◊
                                               ◊${◊THEN (◊k◊ ◊e^*_1◊car1◊ ◊s_1)}◊◊
                                    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}◊◊
                                    ◊${◊ENDIF)◊rangle◊ ◊k◊ ◊s)}◊-◊-     ◊◊
                ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}            ◊◊
                ◊${◊ENDIF)}
◊end{denotation}◊end{semantic}%
◊caption{Сущность Scheme.}◊label{denotational/sematics/fig:naked-scheme}%
◊end{table}

Конечно, специальная форма ◊ic{quote} остаётся нереализованной (как вы помните,
с~цитированием не~всё так просто ◊seePage[assignment/sect:quotation]), функции
с~переменной арностью отложены на~потом.
Естественно, здесь не~хватает ◊ic{eq?}
для сравнения функций, а также множества других примитивов.
Правда, у~нас есть
◊ic{call/cc} в~костюме~Евы.
На самом деле важно то, что другие функции вроде
◊ic{car}, ◊ic{cons}, ◊ic{set-cdr!} могут быть реализованы с~помощью данного
базиса без каких-либо добавок в~ядро.
Специальных форм и некоторых примитивных
функций вроде ◊ic{call/cc} достаточно для понимания принципа.

Как~бы то ни~было, я настаиваю на том, что выражение сути Scheme с~подобной
точностью и лаконичностью стоит затраченных усилий.
Таким образом, наше
путешествие, начавшееся в~первой главе с~определения подмножества Scheme
с~помощью всего Scheme, подходит к~концу.
Сейчас мы определили весь Scheme
с~помощью одного лишь ◊${\lambda}-исчисления.


◊section{◊texorpdfstring{Семантика ◊${\lambda}-исчисления}%
{Семантика λ-исчисления}}◊label{denotational/sect:lambda}

Определение сущности языка с~помощью нескольких формул является одной из
притягательных черт Scheme.
Именно поэтому функциональные языки являются
лингвистическими лабораториями для испытания новых конструкций и изучения их
фундаментальных, обобщённых свойств.
Попробуем и мы провести подобное
исследование.
Для этого мы примемся за довольно простой по своей сути язык —
само ◊${\lambda}-исчисление.
Здесь нет никакой тавтологии или шутки, будет
полезным рассмотреть семантику языка, который отличается от Scheme, но всё~же
является родственным.

Начнём с~синтаксиса.
Он, как уже было сказано, не~важен, так что будем
использовать Scheme-подобный синтаксис:
%
◊[
  x                              ◊qquad◊qquad
  ◊text{◊ic{(lambda (◊${x}) ◊${M})}} ◊qquad◊qquad
  ◊text{◊ic{(◊${M} ◊${N})}}
◊]

Теперь определим домены.
В~◊${\lambda}-исчислении нет присваиваний и продолжений,
что серьёзно облегчает нам работу.
Более того, мы ограничимся чистым
◊${\lambda}-исчислением — то~есть никаких чисел и всего такого, только голые
абстракции.
Итак,~домены:
%
◊[ ◊def◊Venv#1{◊hbox to 0pt{◊Vset{#1}}◊phantom{◊Vset{Окружения}}}
◊begin{array}{ll}
  ◊p & ◊Vset{Программы}                                                       ◊◊
  ◊n & ◊Vset{Переменные}                                                      ◊◊
  ◊r & ◊Vset{Окружения} = ◊Vset{Переменная} ◊to ◊Vset{Значение}               ◊◊
  ◊e & ◊Venv{Значения}  = ◊Vset{Функции}                                      ◊◊
  ◊f & ◊Venv{Функции}   = ◊Vset{Значение} ◊to ◊Vset{Значение}
◊end{array} ◊]

◊indexR{интерпретатор!L@◊${◊Lain}}
◊indexE{L@◊${◊Lain}, интерпретатор}
Функцию-интерпретатор мы назовём~◊${◊Lain}.
Она будет сопоставлять каждому
◊${\lambda}-терму его денотацию — другой ◊${\lambda}"~терм.
Таким образом,
интерпретатор имеет простой тип
%
◊[
  ◊Lain◊colon ◊quad ◊Vset{Программа} ◊to (◊Vset{Окружение} ◊to ◊Vset{Значение})
◊]

Осталось только определить одну за другой денотации синтаксических форм.
Всё их
огромное разнообразие собрано в~таблице~◊ref{denotational/lambda/fig:self}.

◊begin{table}[!h]
◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!семантика}
◊begin{semantic}◊begin{denotation}
◊${◊Lain◊sem{◊n}◊r = (◊r◊ ◊n)}                    ◊~
◊${◊Lain◊sem*{(lambda (}◊n◊${) }◊p$)}◊r =
    \lambda ◊e.
(◊Lain◊sem{◊p}◊ ◊r[◊n ◊to ◊e])$ ◊~
◊${◊Lain◊sem*{(}◊p◊${ }◊p'$)}◊r =
    ◊big((◊Lain◊sem{◊p}◊ ◊r)◊ (◊Lain◊sem{◊p'}◊ ◊r)◊big)$
◊end{denotation}◊end{semantic}%
◊caption{Семантика ◊${\lambda}-исчисления.}◊label{denotational/lambda/fig:self}%
◊end{table}

Данная семантика очень точна, вплоть до неопределённости порядка вычислений.
Аппликация переводится в~аппликацию, так что никакого порядка
не~устанавливается.

Интерпретатор~◊${◊Lain} определяется рекурсивно.
Мы можем так делать благодаря
композициональности: рано или поздно все вычисления сведутся к~ссылкам
на~переменные.

◊${\lambda}-исчисление представляет особенный случай, так как мы и безо всяких
денотаций имеем довольно чёткое представление о~его семантике.
Можно доказать
◊cite{sto77}, что подобное самоопределение сохраняет все необходимые свойства
◊${\lambda}-исчисления вроде ◊${\beta}"=редукции.

Денотирование ◊${\lambda}-исчислением хорошо работает для языков без побочных
эффектов и продолжений.
Но если данные явления в~языке всё~же присутствуют, то
эффективнее будет использовать другой метод, в~котором можно явно задавать
порядок вычислений.
Также для работы присваивания необходимо разделить окружение
и память, введя механизм ссылок, как в~ML, коробки из четвёртой главы, или нечто
подобное.
◊seePage[assignment/assignment/ssect:boxes]


◊section[#:label "denotational/sect:varargs"]{Функции с~переменной~арностью}

◊indexR{переменная арность}
◊indexR{арность!переменная}
В~этом разделе мы покажем, как привнести в~Scheme функции с~точечным аргументом.
Особенность этих функций в~том, что они собирают «лишние» аргументы в~список,
который передаётся через последний аргумент.
Следовательно, при каждом вызове
подобной функции необходимо создавать в~памяти список, что влияет на
производительность.
От некоторых проблем нас может избавить функция ◊ic{apply},
которая сразу принимает список аргументов и применяет к~нему функцию, но ведь
эти списки тоже кто-то должен создать.
В~общем, переменная арность неразлучно
связана со~списками, так что нам потребуются соответствующие функции: ◊ic{car},
◊ic{cons} {◊itd}

◊indexR{Пары@◊Vset{Пары}}
Точечные пары принадлежат домену~◊Vset{Пар}.
Естественно, этот домен также
входит в~дизъюнктивную сумму ◊Vset{Значений}.
Точечные пары представляются
так~же, как и в~предыдущей главе: двумя адресами.
%
◊begin{align*}
  ◊Vset{Значения} & = ◊Vset{Функции} + ◊Vset{Числа} + ◊Vset{Пары} + ◊cdots    ◊◊
      ◊Vset{Пара} & = ◊Vset{Адрес} ◊times ◊Vset{Адрес}
◊end{align*}

Денотации ◊ic{cons}, ◊ic{car} и ◊ic{set-cdr!} (надо~же показать хотя~бы один
побочный эффект) не~таят сюрпризов; мы используем в~точности тот~же подход, что
и в~предыдущей главе.
Единственное, о~чём стоит договориться, это
ассоциативность операций.
Выражение ◊${◊e^*◊car1◊Prj{Пары}◊car2} читается слева
направо: первый аргумент ◊${◊e^*◊car1}, пока ещё значение, проецируется на домен
пар ◊${◊Prj{Пары}} (если это значение на самом деле не~было парой, то мы
получаем~◊${◊bot}), после чего извлекается ◊ic{cdr} этой пары, её второй
компонент~◊${◊car2}.

◊indexC{cons}
◊indexC{car}
◊indexC{set-cdr"!}
◊begin{denotation}
◊${(◊s_0◊ (◊r_0◊ ◊sem*{cons})) = }                            ◊|
◊${◊quad◊Inj{Значение}(\lambda ◊e^*◊k◊s.}◊.
  ◊${◊IF #◊e^* = 2}                                          ◊◊
  ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s◊ 2}                        ◊◊
                $\lambda ◊s_1◊a^*.
                    (◊k◊ ◊Inj{Значение}(◊seq{◊a^*◊car1,
                    a^*◊car2})◊ ◊s_1[◊a^* ◊to*{*} ◊e^*])$   ◊/
  ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}                ◊◊
  ◊${◊ENDIF)}                                               ◊-◊|
◊${(◊s_0◊ (◊r_0◊ ◊sem*{car})) = }                     ◊|
◊${◊quad◊Inj{Значение}(\lambda ◊e^*◊k◊s.}◊.
  ◊${◊IF #◊e^* = 1}                                  ◊◊
  ◊${◊THEN (◊k◊ (◊s◊ ◊e^*◊car1◊Prj{Пары}◊car1)◊ ◊s)}  ◊◊
  ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}        ◊◊
  ◊${◊ENDIF)}                                       ◊-◊|
◊${(◊s_0◊ (◊r_0◊ ◊sem*{set-cdr!})) = }                ◊|
◊${◊quad◊Inj{Значение}(\lambda ◊e^*◊k◊s.}◊.
  ◊${◊IF #◊e^* = 2}                                  ◊◊
  ◊${◊THEN (◊k◊ ◊e^*◊car1◊ ◊s[◊e^*◊car1◊Prj{Пары}◊car2 ◊to ◊e^*◊car2])} ◊◊
  ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}        ◊◊
  ◊${◊ENDIF)}
◊end{denotation}

После определения структуры списков написание ◊ic{apply} не~составляет проблем.
Мы собираем в~последовательность все элементы формы аппликации, кроме первого
(функции) и последнего.
Если предпоследний элемент является списком, то его
необходимо пришить к~концу формируемой последовательности.
После всех этих
манипуляций выполняется собственно вызов функции.

◊makeatletter
◊ForLayout{display}{◊begingroup◊setlength{◊denote@padding}{◊smallskipamount}}
◊makeatother

◊indexC{apply}
◊indexE{collect@◊ii{collect}}
◊indexE{flat@◊ii{flat}}
◊indexE{where-and@◊${◊WHERE ◊ldots ◊AND ◊ldots}}
◊begin{denotation}
◊${(◊s_0◊ (◊r_0◊ ◊sem*{apply})) = } ◊|
◊${◊quad◊Inj{Значение}(\lambda ◊e^*◊k◊s.}◊.
  ◊${◊IF   #◊e^* ◊geq 2}           ◊◊
  ◊${◊THEN {}}◊.◊${(◊e^*◊car1◊Prj{Функции}◊ (◊fn{collect}◊ ◊e^*◊cdr1)◊ ◊k◊ ◊s)} ◊◊
           ◊${◊WHERE ◊ii{collect} = \lambda ◊e^*_1.}◊.
              ◊${◊IF   ◊e^*_1◊cdr1 = ◊seq{}}                                ◊◊
              ◊${◊THEN (◊ii{flat}◊ ◊e^*_1◊car1)}                            ◊◊
              ◊${◊ELSE ◊seq{◊e^*_1◊car1}◊append(◊fn{collect}◊ ◊e^*_1◊cdr1)} ◊◊
              ◊${◊ENDIF}                                                    ◊/
           ◊${◊AND ◊ii{flat} = \lambda◊e.}◊.
              ◊${◊IF   ◊e ◊in ◊Vset{Пары}}                       ◊◊
              $◊THEN ◊seq{(◊s◊ ◊e◊Prj{Пары}◊car1)}◊append
                        (◊ii{flat}◊ (◊s◊ ◊e◊Prj{Пары}◊car2))$  ◊◊
              ◊${◊ELSE ◊seq{}}                                   ◊◊
              ◊${◊ENDIF}                                     ◊-◊-◊◊
  ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}  ◊◊
  ◊${◊ENDIF)}
◊end{denotation}

Здесь ◊${◊WHERE ◊ldots ◊AND ◊ldots} определяет взаимно рекурсивные функции.

◊indexR{интерпретатор!B@◊${◊Bind}}
◊indexE{B@◊${◊Bind}, интерпретатор}
◊indexR{т ау@◊${◊tau} (контекст вычислений)}
◊indexE{t au@◊${◊tau} (контекст вычислений)}
◊indexR{м ю@◊${◊mu} (денотация функции)}
◊indexE{m u@◊${◊mu} (денотация функции)}
Теперь перейдём к~собственно обработке точечных аргументов.
Для этого нам
потребуется изменить форму~◊ic{lambda}, а также ввести ещё один интерпретатор.
Его задачей будет правильным образом связывать переменные и значения.
Мы назовём
его ◊${◊Bind}, от~◊term{binding}.
Его тип связан с~типом~◊${◊Eval} для функций; для
краткости обозначим буквой ◊${◊mu} денотацию функции, для которой ◊${◊Bind}
подготавливает аргументы, а для контекста вычислений используем букву~◊${◊tau}:
%
◊begin{align*}
&  ◊tau ◊equals ◊Vset{Значения}^* ◊times ◊Vset{Окружение}
     ◊times ◊Vset{Продолжение} ◊times ◊Vset{Память}                           ◊◊
&  ◊:◊:◊llap{◊${◊Eval}}◊colon ◊quad ◊Vset{Программа}◊to(◊tau◊to◊Vset{Значение}) ◊◊
&  ◊:◊:◊llap{◊${◊Bind}}◊colon ◊quad ◊Vset{СписокАргументов} ◊to
      ◊big(◊underbrace{(◊tau ◊to ◊Vset{Значение})}_{◊displaystyle◊mu}
          ◊times ◊tau ◊to ◊Vset{Значение}◊big)
◊end{align*}


◊${◊Bind}, связывающий интерпретатор, начинает работу после проверки арности.
Если
с~ней всё в~порядке, то он заносит один за другим фактические значения
аргументов в~память и расширяет лексическое окружение функции соответствующими
переменными.
Наконец, управление передаётся телу функции.
Определение функций
фиксированной арности с~помощью ◊${◊Bind} выглядит~так:

◊indexC{lambda}
◊indexE{let-in@◊${◊LET ◊ldots ◊IN}}
◊begin{denotation}
◊${◊Eval◊sem*{(lambda (}◊n^*◊${) }◊p^+◊${)}◊r◊k◊s = } ◊|
◊${◊quad(◊k◊ ◊Vset{Значение}(\lambda ◊e^*◊k_1◊s_1.}◊.
  ◊${◊IF   #◊e^* = ◊#◊n^*}                       ◊◊
  $◊THEN ◊big((◊Bind◊sem{◊n^*}◊ \lambda◊e^*_1◊r_1◊k_2◊s_2.
            (◊Eval^+◊sem{◊p^+}◊ ◊r_1◊ ◊k_2◊ ◊s_2))◊ ◊e^*◊ ◊r◊ ◊k_1◊ ◊s_1◊big)$◊◊
  ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}    ◊◊
  ◊${◊ENDIF)◊ ◊s)}                              ◊-◊|
◊${◊Bind◊sem{◊n◊ ◊n^*}◊mu = (◊Bind◊sem{◊n}◊ (◊Bind◊sem{◊n^*}◊ ◊mu))}  ◊|
◊${◊Bind◊sem{◊,}◊mu = ◊mu}                                            ◊|
$◊Bind◊sem{◊n}◊mu =
  \lambda ◊e^*◊r◊k◊s.
      ◊ii{allocate}◊ ◊s◊ 1◊ \lambda ◊s_1◊a^*.$◊.
                                ◊${◊LET ◊a = ◊a^*◊car1}  ◊◊
                                $◊IN  (◊mu◊ ◊e^*◊cdr1◊ ◊r[◊n ◊to
                                         ◊a]◊ ◊k◊ ◊s_1[◊a ◊to ◊e^*◊car1])$
◊end{denotation}

Конструкция ◊${◊LET ◊ldots ◊IN} вводит локальные нерекурсивные определения.

◊ForLayout{display}{◊endgroup} % ◊setlength{◊denotepadding}

Для обработки случая функций переменной арности потребуется определить
дополнительный синтаксис формы ◊ic{lambda}, принимающей список с~точкой, а также
новый вариант~◊${◊Bind}.
Эта форма принимает последовательность «лишних»
значений, превращает её в~список (настоящий, из точечных пар), который связывает
с~именем последнего аргумента.
Если учесть, что функции с~переменной арностью и
◊ic{apply} могут использоваться совместно с~побочными эффектами, то подобные
списки необходимо создавать заново при каждом вызове.
В~конце концов,
в~стандарте есть требование, чтобы функции вели таким образом.
Поэтому следующее
выражение должно возвращать ложь:

◊code:lisp{
(let ((arguments (list 1 2 3)))
  (apply (lambda args (eq? args arguments)) arguments) )
}

Если мы не~хотим этого делать, то вначале потребуется доказать, что совместное
использование одного и того~же физического списка не~изменит смысла программы.

Наконец, переходим к~денотациям:

◊indexE{listify@◊ii{listify}}
◊begin{denotation}
◊${◊Eval◊sem*{(lambda (}◊n^*$ ◊!.
◊${◊n}) ◊${◊p^+})}◊r◊k◊s = $                   ◊|
◊${◊quad(◊k◊ ◊Inj{Значение}(\lambda ◊e^*◊k_1◊s_1.}◊.
  ◊${◊IF   #◊e^* ◊geq ◊#◊n^*}                                               ◊◊
  ◊${◊THEN ◊big(}◊.$(◊Bind◊sem{◊n^*}◊ %
                    (◊Bind◊sem*{.
◊${◊n}}◊ {}◊${◊*}\lambda ◊e^*_1◊r_1◊k_2◊s_2.$◊◊
                                ◊${(◊Eval^+◊sem{◊p^+}◊ ◊r_1◊ ◊k_2◊ ◊s_2)))}  ◊/
              ◊${◊e^*◊ ◊r◊ ◊k_1◊ ◊s_1◊big)}                                  ◊/
  ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}                               ◊◊
  ◊${◊ENDIF)◊ ◊s)}                                                         ◊-◊|
◊*$◊Bind◊sem*{.
◊${◊n}}◊mu = {}$◊.
  $\lambda ◊e^*◊r◊k◊s.
◊big(◊fn{listify}◊ ◊e^*◊ ◊s◊ ◊${◊*}\lambda ◊e◊s_1.$   ◊◊
           ◊*◊${◊ii{allocate}◊ ◊s_1◊ 1}                                      ◊◊
                ◊${\lambda ◊s_2◊a^*.}◊.
             ◊${◊LET ◊a = ◊a^*◊car1}                                         ◊◊
             ◊${◊IN  (◊mu◊ ◊seq{}◊ ◊r[◊n◊to◊a]◊ ◊k◊ ◊s_2[◊a◊to◊e])◊big)}◊-◊-◊-◊-◊◊
  ◊${◊WHERE ◊ii{listify} = {}}◊*%
      ◊${\lambda ◊e^*_1◊s_1◊k_1.}              ◊◊
        ◊${◊IF   #◊e^*_1 > 0}                 ◊◊
        ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ 2} ◊◊
            ◊${\lambda ◊s_2◊a^*.}◊.
              ◊${◊LET ◊k_2 = {}}◊*◊${\lambda ◊e◊s_3 .}                 ◊◊
                             $(◊k_1◊ ◊Inj{Значение}
                                  (◊a^*)◊ ◊s_3[◊a^*◊car2 ◊to ◊e])$ ◊/
              $◊IN (◊fn{listify}◊
                    ◊e^*_1◊cdr1◊ ◊s_2[◊a^*◊car1 ◊to ◊e^*_1◊car1]◊ ◊k_2)$◊-◊-◊◊
        ◊${◊ELSE (◊k_1◊ ◊Inj{Значение}(◊seq{})◊ ◊s_1)}                        ◊◊
        ◊${◊ENDIF}
◊end{denotation}

◊indexR{переменная арность!сложность}
Как видите, введение нетривиальных возможностей вроде функций переменной арности
требует существенных усилий.
Нам пришлось, фактически, написать ещё один
интерпретатор.
Если сравнить получившуюся версию с~элегантной реализацией ядра
Scheme, то станет очевидным, что добавление всего одной интересной, но всё~же
несущественной детали почти удвоило размер кода, не~говоря уже о~читабельности
и~понятности.


◊section[#:label "denotational/sect:eval-order"]{Порядок вычисления аргументов}

◊indexR{порядок вычислений!в Scheme и Си}
Время от времени в~Интернете вспыхивают яростные религиозные войны по поводу
толкования стандартов Scheme.
Данная книга строго следует стандарту: порядок
вычисления термов аппликации не~определён.
К~сожалению, из-за этого правила
сложно не~только писать корректные программы, зависящие от конкретного порядка,
но и отлаживать некорректные.
Многие программы, даже некоторые из написанных
видными экспертами, неявно зависят от порядка вычислений; особенно программы,
использующие продолжения.
Лично я предпочитаю порядок слева направо, так как
он соответствует направлению чтения во~многих языках, а также привносит хоть
какую-то систематичность в~поиск ошибок.

Особый интерес среди доводов противоборствующей стороны представляют
следующие~два.
Первый из них состоит в~том, что многие языки не~указывают
порядок вычислений.
Даже императивный Си не~указывает порядок вычисления
аргументов функций.
Если выражение ◊ic{(foo (f~x) (g~x~y))} транслируется
в~следующий код на Си: ◊ic{foo(f(x), g(x,~y))}, то нам действительно
не~следует полагаться на какой-либо порядок.

Второй довод больше философский.
В~языке без предопределённого порядка
вычислений его всё~же можно явно установить самостоятельно с~помощью ◊ic{begin}.
Следовательно, порядок всё~же есть, просто «не~определён» следует читать как
«не~определён нами».
Поэтому для истинной неопределённости реализация языка
должна использовать какой-нибудь генератор случайных чисел, который будет
определять «неопределённый» порядок непосредственно перед вычислениями.
◊seeEx[denotational/ex:truly-random]

В~Си порядок в~действительности не~определяется для того, чтобы разрешить
компилятору выбирать любой необходимый ему порядок, например, чтобы эффективнее
распределять регистры.

Явный порядок вычислений упрощает отладку, делая одной неопределённостью меньше.
Если порядок будет случайным, то два прогона одной и той же программы на одних и
тех~же данных могут дать разные результаты.
Рассмотрим пример◊footnote{Данная
функция была придумана и реализована совместно с~Матиасом~Феллайзеном
(Matthias~Felleisen).}:

◊indexC{dynamically-changing-evaluation-order}
◊indexC{amb}
◊code:lisp{
(define (dynamically-changing-evaluation-order?)
  (define (amb)
    (call/cc (lambda (k) ((k #t) (k #f)))) )
  (if (eq? (amb) (amb))
    (dynamically-changing-evaluation-order?)
    #t ) )
}

Функция~◊ic{amb} возвращает истину или ложь в~зависимости от того, какой терм
вычисляется первым.
Если порядок вычислений не~фиксирован, то функция
◊ic{dynamically-changing-evaluation-order?} рано или поздно остановится и
вернёт~◊ic{#t}; иначе она попадает в~бесконечный цикл.
В~{◊RnRS} нет ничего,
что требовало~бы от этой функции того или иного поведения.
Оно зависит
исключительно от реализации.

◊indexR{порядок вычислений!неопределённый}
Необходимо чётко отделять реализацию языка от его стандарта.
Интерпретатор или
компилятор по очевидным причинам вынуждены использовать хоть какой-нибудь
порядок.
Не~особо важно, слева направо, или справа налево, как MacScheme, или
хоть в~зависимости от текущей фазы Луны.
Но ни~одна из известных мне реализаций
не~изменяет всерьёз порядок вычисления аргументов во~время выполнения программы.
Обычно порядок устанавливается при компиляции, после чего к~этому вопросу больше
не~возвращаются.
Поэтому неопределённость порядка всё~же следует понимать как
привилегию выбирать любой, а не~обязанность поддерживать случайный.

◊indexR{результат@◊Vset{Результат}}
Проблема в~том, как показать в~денотациях неопределённость порядка, но в~то~же
время разрешить реализациям определять свой порядок, используя одни и те~же
денотации.
Идея решения данной проблемы состоит в~небольшом изменении структуры
денотаций.
Сейчас они считаются ◊${\lambda}-термами, которые принимают окружение,
продолжение и~память, а потом возвращают некоторый результат.
Данный результат
принадлежит домену ◊Vset{Значений}, но ведь на самом деле он неразрывно связан
с~состоянием памяти: мы говорили, что побочные эффекты — это тоже результат
работы программы.
Поэтому нам стоит сделать результатом вычислений именно пару
(◊ii{значение}, ◊ii{память}).
Мы не~будем заниматься философствованиями на тему
того, чем именно является результат вычислений, а просто сделаем областью
значений денотаций домен~◊Vset{Результатов}.

◊indexR{порядок вычислений!неопределённый!денотация}
◊indexR{интерпретатор!N@◊${◊Noir◊mskip-◊thinmuskip}}
◊indexE{N@◊${◊Noir◊mskip-◊thinmuskip}, интерпретатор}
◊indexE{P@◊${◊mathcal{P}(Q)} (множество)}
Так как вычисления могут проходить по-разному, то и денотации будут возвращать
не~один результат, а множество всех возможных результатов в~зависимости от
порядка вычислений.
Реализация~же будет выбирать из этого множества какой-нибудь
один, руководствуясь собственными соображениями.
Следовательно, ◊${◊Eval} теперь
соответствует обобщённому результату, а конкретная реализация представляется
функцией~◊${◊Noir}◊!.
Если обозначить множество всех подмножеств~◊${Q} как
◊${◊mathcal{P}(Q)}, то эти функции имеют следующие типы:
%
◊begin{align*}
  ◊Eval◊colon& ◊quad ◊Vset{Программа} ◊to ◊Vset{Значения}^*
      ◊times ◊Vset{Окружение} ◊times {}                             ◊◊
  & ◊hskip10em {} ◊times ◊Vset{Продолжение} ◊times ◊Vset{Память}
      ◊to ◊mathcal{P}(◊Vset{Результаты})                            ◊◊
◊Noir◊!◊colon& ◊quad ◊Vset{Программа} ◊to ◊Vset{Значения}^*
      ◊times ◊Vset{Окружение} ◊times {}                             ◊◊
  & ◊hskip10em {} ◊times ◊Vset{Продолжение} ◊times ◊Vset{Память}
      ◊to ◊Vset{Результат}
◊end{align*}

◊indexE{oneof@◊ii{oneof}}
◊${◊Noir} определяется просто: она использует ◊ii{oneof}◊!, чтобы выбрать один из
возможных результатов.
Определение функции~◊ii{oneof}◊!, естественно, возлагается
на реализацию.

◊begin{denotation}
◊${◊Noir◊sem{◊p}◊r◊k◊s = (◊fn{oneof}◊ (◊Eval◊sem{◊p}◊ ◊r◊ ◊k◊ ◊s))}
◊end{denotation}

Теперь необходимо переопределить аппликацию функций так, чтобы получать все
возможные результаты.
Если порядок случаен, то это фактически значит, что
аппликация выполняется так: сначала выбирается случайный терм, обозначим
его~◊${◊p'_0}, он вычисляется в~◊${◊e'_0}, потом из оставшихся выбирается следующий
терм~◊${◊p'_1}, который вычисляется в~◊${◊e'_1}, и так далее.
Затем значения
◊${◊e'_0, ◊e'_1, ◊dots, ◊e'_n} переупорядочиваются так, как они шли в~исходной
форме: ◊${◊e_0, ◊e_1, ◊dots, ◊e_n}, и, наконец, первое значение-функция
применяется к~последовательности из~всех остальных.
При таком подходе порядок
вычислений действительно случаен для каждого отдельного вызова, а не~выбирается
и фиксируется для каждой функции.
Рассмотрим пример.
Следующая функция не~только
выводит неопределённое число, но и продолжение, которое она возвращает, тоже
выводит неопределённое число.

◊indexC{one-two-three}
◊code:lisp{
(define (one-two-three)
  (call/cc (lambda (k)
             ((begin (display 1) (call/cc k))
              (begin (display 2) (call/cc k))
              (begin (display 3) (call/cc k)) ) )) )
}

◊indexE{forall@◊ii{forall}}
◊indexE{cut@◊ii{cut}}
◊indexR{стиль передачи продолжений (CPS)}
◊indexE{CPS}
Денотация аппликации с~неопределённым порядком вычисления аргументов будет
выполнять именно то, что мы сказали ранее.
Она рассмотрит все возможные
перестановки аргументов с~помощью функции~◊ii{forall}, которая применяет свой
первый аргумент (тернарную функцию) ко~всем возможным срезам своего второго
аргумента (списка).
Срезы предоставляются функцией~◊ii{cut}, которая разрезает
список на две части: одна из них содержит первые ◊${i} элементов, другая — все
оставшиеся; затем ◊ii{cut} применяет свой третий аргумент (продолжение) к~этим
двум частям.
Определения слегка запутанные, но это хороший пример стиля передачи
продолжений.
(Данная программа была разработана в~сотрудничестве с~Софи~Англад и
Жан-Жаком~Лакрампом ◊cite{alq95}.)

◊indexE{possible-paths@◊ii{possible-paths}}
◊indexE{loop@◊ii{loop}}
◊indexE{accumulate@◊ii{accumulate}}
◊begin{denotation}
◊${◊Eval◊sem*{(}◊p_0◊${ }◊p_1$ ...
◊${◊p_n})}◊r◊k◊s = ◊big($◊.
  $(◊ii{possible-paths}◊ ◊seq{◊Eval◊sem{◊p_0},
      ◊Eval◊sem{◊p_1}, ◊dots, ◊Eval◊sem{◊p_n}})$                    ◊◊
  $◊r◊ \lambda◊e^*◊s_1.
         (◊e^*◊car1◊Prj{Функции}◊ ◊e^*◊cdr1◊ ◊k◊ ◊s_1)◊ ◊s◊big)$  ◊-◊~
◊${(◊ii{possible-paths}◊ ◊mu^+) = }                                   ◊◊
◊${◊quad\lambda ◊r◊k◊s.}◊.
  ◊${◊IF   #◊mu^+◊cdr1 > 0}        ◊◊
  ◊${◊THEN (◊ii{forall}◊ }◊*%
    ◊${\lambda ◊mu^+_1◊mu◊mu^+_2.}  ◊◊
    ◊${(◊mu◊ ◊r◊ }◊*%
      ◊${\lambda ◊e◊s_1.}           ◊◊
      ◊${(}◊.◊${(◊ii{possible-paths}◊ ◊mu^+_1◊append◊mu^+_2)} ◊◊
           ◊${◊r◊ \lambda ◊e^*◊s_2.}◊.
              ◊${◊LET ◊k_1 = {}}◊*◊${\lambda ◊e^*_1◊e^*_2.}      ◊◊
                        ◊${(◊k◊ ◊e^*_1 ◊append ◊seq{◊e} ◊append ◊e^*_2◊ ◊s_2)}◊-◊◊
              ◊${◊IN  (◊fn{cut}◊ #◊mu^+_1◊ ◊e^*◊ ◊k_1)}    ◊/
           ◊${◊s_1)◊ ◊s)◊ ◊mu^+)}                     ◊-◊-◊-◊◊
  ◊${◊ELSE (◊mu^+◊car1◊ ◊r◊ \lambda ◊e◊s_1.(◊k◊ ◊seq{◊e}◊ ◊s_1)◊ ◊s)}◊◊
  ◊${◊ENDIF}  ◊-◊~
◊*◊${(◊ii{forall}◊ ◊f◊ ◊ell) = (◊fn{loop}◊ ◊seq{}◊ ◊ell◊car1◊ ◊ell◊cdr1)}       ◊◊
  $◊WHERE ◊ii{loop} =
    \lambda ◊ell_1◊e◊ell_2.
      (◊f◊ ◊ell_1◊ ◊e◊ ◊ell_2) ◊cup {}$◊.
          ◊${◊IF   #◊ell_2 > 0}                        ◊◊
          $◊THEN (◊fn{loop}◊ ◊ell_1 ◊append
                 ◊seq{◊e}◊ ◊ell_2◊car1◊ ◊ell_2◊cdr1)$ ◊◊
          ◊${◊ELSE ◊emptyset}                           ◊◊
          ◊${◊ENDIF}                                ◊-◊-◊~
◊*◊${(◊fn{cut}◊ ◊iota◊ ◊e^*◊ ◊k) = (◊fn{accumulate}◊ ◊iota◊ ◊seq{}◊ ◊e^*)}      ◊◊
  ◊${◊WHERE ◊ii{accumulate} = \lambda ◊iota◊ell◊ell_1.}◊.
    ◊${◊IF   ◊iota > 0}                                       ◊◊
    $◊THEN (◊fn{accumulate}◊ (◊iota - 1)◊ ◊seq{◊ell_1◊car1}
            ◊append◊ell◊ ◊ell_1◊cdr1)$                      ◊◊
    ◊${◊ELSE (◊k◊ (◊fn{reverse}◊ ◊ell)◊ ◊ell_1)}              ◊◊
    ◊${◊ENDIF}
◊end{denotation}

◊indexE{Scheme!параллельные вычисления}
Во~всех приведённых случаях порядок вычисления аргументов является
неопределённым, но сами вычисления остаются последовательными — это
требование стандарта: результат должен быть эквивалентен вычислению аргументов
в~какой-нибудь последовательности.
То~есть следующая программа может вернуть
◊ic{(3~5)} или~◊ic{(4~3)}, но никак не~◊ic{(3~3)}:

◊code:lisp{
(let ((x 1) (y 2))
  (list (begin (set! x (+ x y)) x)
        (begin (set! y (+ x y)) y) ) )
}

Денотация следующей программы, полученная с~помощью новой ◊${◊Eval}, будет
возвращать два возможных результата: ◊ic{1} и~◊ic{2}.
Конкретная реализация
сможет выбрать один из них с~помощью ◊${◊Noir} и~◊ii{oneof}◊!.

◊code:lisp{
(call/cc (lambda (k) ((k 1) (k 2)))) |{◊is} ◊${◊{◊ic{1},◊ ◊ic{2}◊}}|
}


◊section[#:label "denotational/sect:dynamic"]{Динамическое связывание}

◊indexR{динамическое связывание}
◊indexR{связывание!динамическое}
◊indexR{окружение!динамическое}
Идея динамического связывания не~только важна сама по себе, но и действительно
полезна.
В~конце концов, довольно долгое время разнообразные диалекты Лиспа были
именно динамическими.
Поэтому мы просто не~можем обойти стороной эту идею и
не~показать её денотацию.
Для этого нам потребуется поправить ядро Scheme, а
также добавить несколько специальных форм для работы с~новым типом привязок.
Конечно, есть далеко не~один вариант реализации динамического окружения; взять
хотя~бы возможность использовать или специальные формы, или~же
специализированные функции.
◊seePage[lisp1-2-omega/namespaces/ssect:dyn-vars-no-special] Традиционно
в~Scheme принят второй подход, чтобы как можно меньше вмешиваться в~ядро языка.
К~сожалению, не~все функции можно отделить от ядра, даже если они вызываются,
используются и ведут себя именно как функции.
Например, ◊ic{call/cc}: ей
необходим доступ к~продолжениям.
Аналогично, всем функциям для работы
с~динамическими переменными потребуется доступ к~окружению динамических
переменных.
Доработанное ядро Scheme приведено
в~таблице~◊ref{denotational/dynamic/fig:dynamic-scheme}.

◊begin{table}[!p]
◊indexE{Scheme!семантика!динамическое окружение}
◊begin{semantic}◊begin{denotation}
◊${◊Eval◊sem{◊n}◊r◊d◊k◊s = (◊k◊ (◊s◊ (◊r◊ ◊n))◊ ◊s)}                     ◊~
◊${◊Eval◊sem*{(if }◊p◊${ }◊p_1◊${ }◊p_2$)}◊r◊d◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ ◊d◊ \lambda◊e◊s_1.
(◊${◊.}◊IF    (◊fn{boolify}◊ ◊e)$    ◊◊
                                            ◊${◊THEN  ◊Eval◊sem{◊p_1}   }       ◊◊
                                            ◊${◊ELSE  ◊Eval◊sem{◊p_2}   }       ◊◊
                                            ◊${◊ENDIF ◊r◊ ◊d◊ ◊k◊ ◊s_1)◊ ◊s)} ◊-◊|
◊${◊Eval◊sem*{(set! }◊n◊${ }◊p$)}◊r◊d◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ ◊d◊ \lambda◊e◊s_1.
        (◊k◊ ◊e◊ ◊s_1[(◊r◊ ◊n) ◊to ◊e])◊ ◊s)$                          ◊~
◊${◊Eval◊sem*{(lambda (}◊n^*◊${) }◊p^+◊${)}◊r◊d◊k◊s =}                       ◊|
◊${◊quad(◊k◊ ◊Inj{Значение}(\lambda◊e^*◊d_1◊k_1◊s_1.}◊.
    ◊${◊IF   #◊e^* = ◊#◊n^*}                            ◊◊
    ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ #◊n^*}          ◊◊
              ◊*◊${\lambda ◊s_2◊a^*.}                    ◊◊
                $(◊Eval^+◊sem{◊p^+}◊ ◊r[◊n^* ◊to*{*}
                ◊a^*]◊ ◊d_1◊ ◊k_1◊ ◊s_2[◊a^* ◊to*{*} ◊e^*])$ ◊-◊/
    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}         ◊◊
    ◊${◊ENDIF)◊ ◊s)}                                     ◊-◊|
◊${◊Eval◊sem*{(}◊p◊${ }◊p^*◊${)}◊r◊d◊k◊s =}                         ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊d◊ \lambda ◊f◊s_1.
    (◊Eval^*◊sem{◊p^*}◊ ◊r◊ ◊d◊ \lambda ◊e^*◊s_2.
        (◊f◊Prj{Функции}◊ ◊e^*◊ ◊d◊ ◊k◊ ◊s_2)◊ ◊s_1)◊ ◊s)$    ◊~
◊${◊Eval^*◊sem{◊p◊ ◊p^*}◊r◊d◊k◊s =}                             ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊d◊ \lambda ◊e◊s_1.
        (◊Eval^*◊sem{◊p^*}◊ ◊r◊ ◊d◊ \lambda ◊e^*◊s_2.
            (◊k◊ ◊seq{◊e} ◊append ◊e^*◊ ◊s_2)◊ ◊s_1)◊ ◊s)$    ◊~
◊${◊Eval^*◊sem{◊,}◊r◊d◊k◊s = (◊k◊ ◊seq{}◊ ◊s)}                  ◊~
◊${◊Eval◊sem*{(begin }◊p^+◊${)}◊r◊d◊k◊s = (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊d◊ ◊k◊ ◊s)}◊~
$◊Eval^+◊sem{◊p◊ ◊p^+}◊r◊d◊k◊s = ◊big(◊Eval◊sem{◊p}◊ ◊r◊ ◊d◊ \lambda◊e◊s_1.
    (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊d◊ ◊k◊ ◊s_1)◊ ◊s◊big)$           ◊~
◊${◊Eval^+◊sem{◊p}◊r◊d◊k◊s = (◊Eval◊sem{◊p}◊ ◊r◊ ◊d◊ ◊k◊ ◊s)}   ◊~
◊${(◊s_0◊ (◊r_0◊ ◊sem*{call/cc})) = }                           ◊|
◊${◊quad◊Inj{Значение}(}◊*◊${\lambda ◊e^*◊d◊k◊s.}                 ◊◊
                ◊${◊IF   #◊e^* = 1}                            ◊◊
                ◊${◊THEN (}◊.◊${◊e^*◊car1◊Prj{Функции}}           ◊◊
                        ◊${◊langle◊Inj{Значение}(}◊*◊${\lambda◊e^*_1◊d_1◊k_1◊s_1.}◊◊
                                               ◊${◊IF   #◊e^*_1 = 1}           ◊◊
                                               ◊${◊THEN (◊k◊ ◊e^*_1◊car1◊ ◊s_1)}◊◊
                                    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}◊◊
                                    ◊${◊ENDIF)◊rangle◊ ◊d◊ ◊k◊ ◊s)}  ◊-◊-◊◊
                ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}             ◊◊
                ◊${◊ENDIF)}
◊end{denotation}◊end{semantic}%
◊caption{Scheme с~динамическим окружением.}%
◊label{denotational/dynamic/fig:dynamic-scheme}%
◊end{table}

◊indexR{д ельта@◊${◊d} (динамическое окружение)}
◊indexE{d elta@◊${◊d} (динамическое окружение)}
◊indexR{память!однопоточность}
Динамическое окружение, обозначаемое~◊${◊d}, отличается от лексического~◊${◊r}.
Оно
передаётся только туда, где его можно использовать.
Отличается оно и от
памяти~◊${◊s}, которая является ◊term{однопоточной}: каждое вычисление принимает
память, достаёт значения нужных переменных или изменяет их, после чего передаёт
новое состояние памяти дальше.
Поток передачи памяти только один, в~каждый
момент времени существует только одно актуальное состояние памяти.
Динамическое
окружение хоть и передаётся от функции к~функции похожим образом, но поток может
разделяться, например, при вычислении термов аппликации.

◊indexR{ДинамическоеОкружение@◊Vset{ДинамическоеОкружение}}
Динамические окружения принадлежат одноимённому домену, определяемому следующим
образом:
%
◊[
  ◊d ◊quad ◊Vset{ДинамическоеОкружение} = ◊Vset{Переменная} ◊to ◊Vset{Значение}
◊]

◊phantomlabel{denotational/dynamic/par:two-forms}
Для работы с~динамическим окружением предназначены две специальные формы:
◊ic{dynamic-let} и~◊ic{dynamic}.
Форма ◊ic{dynamic-let} устанавливает
динамическую связь между ◊ii{переменной} и ◊ii{значением} на время вычисления
◊ii{тела}.
Она обрабатывает только одну переменную за раз, но это не~проблема
(макросы).
Форма ◊ic{dynamic} возвращает текущее значение динамической
переменной; или ошибку, если запрошенная переменная не~существует.
Так как
изменять динамические привязки мы запрещаем, то данное окружение связывает
переменные со~значениями напрямую, без посредников в~виде адресов.
Семантика
рассмотренных форм показана
в~таблице~◊ref{denotational/dynamic/fig:dynamic-semantics}, а~вот их синтаксис:

◊indexC{dynamic-let}
◊indexC{dynamic}
◊code:lisp{
(dynamic-let (|◊ii{переменная}| |◊ii{значение}|) |◊ii{тело}|...)
(dynamic |◊ii{переменная}|)
}

◊begin{table}[!ht]
◊indexR{динамическое связывание!семантика}
◊indexR{д ельта0@◊${◊delta_0} (начальное окружение)}
◊indexE{d elta0@◊${◊delta_0} (начальное окружение)}
◊begin{semantic}◊begin{denotation}
◊${(◊d_0◊ ◊n) = ◊ii{wrong}◊ ◊dc{"No such dynamic variable"}}                    ◊~
◊${◊Eval◊sem*{(dynamic }◊n◊${)}◊r◊d◊k◊s = (◊k◊ (◊d◊ ◊n)◊ ◊s)}                     ◊~
◊${◊Eval◊sem*{(dynamic-let (}◊n◊${ }◊p◊${) }◊p^+◊${)}◊r◊d◊k◊s = }                     ◊|
$◊quad(◊Eval◊sem{◊pi}◊ ◊r◊ ◊d◊ \lambda ◊e◊s_1.
    (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊d[◊n ◊to ◊e]◊ ◊k◊ ◊s_1)◊ ◊s)$
◊end{denotation}◊end{semantic}%
◊caption{Семантика специальных форм динамического связывания.}%
◊label{denotational/dynamic/fig:dynamic-semantics}%
◊end{table}

Приведённая денотация довольно очевидна.
Формы получают значение из
динамического окружения или~же расширяют его, таким образом мы получаем второе
пространство имён для динамических переменных, отделённое от пространства
лексических.
И~снова вы можете убедиться в~огромной информативности подобной
записи: лишь несколькими греческими буквами описывается новое пространство имён.
Денотационная семантика одарит своей силой любого, кто сможет разобраться
в~её~тайнописи.

◊indexR{обработка ошибок}
Идея динамического окружения находит применение не~только просто для переменных,
но и при обработке ошибок, для реализации переходов и иных механизмов управления
потоком исполнения ◊cite{hd90,qd93}.
Рассмотрим, например, простой, собранный
на коленке механизм обработки ошибок: в~случае неожиданной ситуации функция
создаёт объект, описывающий, что именно произошло, и передаёт его функции,
хранящейся в~динамической переменной ◊ic{*error*}.
Теперь можно на любые
вычисления навесить нужный нам обработчик ошибок, обернув эти вычисления в~форму
◊ic{dynamic-let}, устанавливающую необходимую функцию в~◊ic{*error*}.
Например,
стандарт Scheme требует, чтобы попытка открыть несуществующий файл вызывала
ошибку, но, к~сожалению, он не~определяет функцию, позволяющую заранее
проверить, существует~ли файл.
Используя динамические переменные, мы можем
написать подобный предикат самостоятельно:

◊indexC{file-exists"?}
◊code:lisp{
(define (file-exists? filename)
  (dynamic-let (*error* (lambda (anomaly) #f))
    (call-with-input-file filename
      (lambda (port) #t) ) ) )
}

Это приближённое определение, так как в~действительности надо ещё проверить,
что ◊ic{*error*} вызвана потому, что файл действительно не~существует, а не,
например, потому что мы исчерпали лимит открытых портов~ввода.
Для этого
необходимо знать структуру объектов, которые ◊ic{call-with-input-file} может
положить в~◊ic{anomaly}.


◊section[#:label "denotational/sect:global"]{Глобальное окружение}

◊indexR{глобальное окружение}
◊indexR{окружение!глобальное}
◊indexR{г амма@◊${◊g} (глобальное окружение)}
◊indexE{g amma@◊${◊g} (глобальное окружение)}
В~этом разделе мы изучим глобальное окружение, рассмотрев несколько вариантов
его денотации.
Добавляется оно аналогично динамическому окружению~◊${◊d}.
Как и
локальное окружение~◊${◊r}, глобальное окружение~◊${◊g} переводит идентификаторы
в~адреса.
Глобальное окружение следует тенью за памятью: всякое вычисление
теперь принимает, возможно использует и передаёт дальше не~только память, но и
глобальное окружение.
В~таблице~◊ref{denotational/global/fig:global-scheme}
приведена денотация ядра Scheme с~глобальным окружением.
Из неё пока исключены
ссылки на переменные и присваивание, их мы рассмотрим чуть позже.

◊begin{table}[!p]
◊indexE{Scheme!семантика!глобальное окружение}
◊begin{semantic}◊begin{denotation}
◊${◊Eval◊sem*{(if }◊p◊${ }◊p_1◊${ }◊p_2$)}◊r◊g◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda◊e◊g_1◊s_1.(◊${◊.}◊IF (◊fn{boolify}◊ ◊e)$    ◊◊
                                           ◊${◊THEN  ◊Eval◊sem{◊p_1}   }        ◊◊
                                           ◊${◊ELSE  ◊Eval◊sem{◊p_2}   }        ◊◊
                                           ◊${◊ENDIF ◊r◊ ◊g_1◊ ◊k◊ ◊s_1)◊ ◊s)}◊-◊|
◊${◊Eval◊sem*{(lambda (}◊n^*◊${) }◊p^+◊${)}◊r◊g◊k◊s =}       ◊|
◊${◊quad(◊k◊ ◊Inj{Значение}(\lambda◊e^*◊g_1◊k_1◊s_1.}◊.
    ◊${◊IF   #◊e^* = ◊#◊n^*}                            ◊◊
    ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ #◊n^*}          ◊◊
              ◊*◊${\lambda ◊s_2◊a^*.}                    ◊◊
                $(◊Eval^+◊sem{◊p^+}◊ ◊r[◊n^* ◊to*{*}
                ◊a^*]◊ ◊g_1◊ ◊k_1◊ ◊s_2[◊a^* ◊to*{*} ◊e^*])$ ◊-◊/
    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}         ◊◊
    ◊${◊ENDIF)◊ ◊g◊ ◊s)}                               ◊-◊|
◊${◊Eval◊sem*{(}◊p◊${ }◊p^*◊${)}◊r◊g◊k◊s =}                         ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda ◊f◊g_1◊s_1.
    (◊Eval^*◊sem{◊p^*}◊ ◊r◊ ◊g_1◊ \lambda ◊e^*◊g_2◊s_2.
        (◊f◊Prj{Функции}◊ ◊e^*◊ ◊g_2◊ ◊k◊ ◊s_2)◊ ◊s_1)◊ ◊s)$  ◊~
◊${◊Eval^*◊sem{◊p◊ ◊p^*}◊r◊g◊k◊s =}                             ◊|
$◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda ◊e◊g_1◊s_1.
    (◊Eval^*◊sem{◊p^*}◊ ◊r◊ ◊g_1◊ \lambda ◊e^*◊g_2◊s_2.
        (◊k◊ ◊seq{◊e} ◊append ◊e^*◊ ◊g_2◊ ◊s_2)◊ ◊s_1)◊ ◊s)$  ◊~
◊${◊Eval^*◊sem{◊,}◊r◊g◊k◊s = (◊k◊ ◊seq{}◊ ◊g◊ ◊s)}              ◊~
◊${◊Eval◊sem*{(begin }◊p^+◊${)}◊r◊g◊k◊s = (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊g◊ ◊k◊ ◊s)}◊~
$◊Eval^+◊sem{◊p◊ ◊p^+}◊r◊g◊k◊s = ◊big(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda◊e◊g_1◊s_1.
    (◊Eval^+◊sem{◊p^+}◊ ◊r◊ ◊g_1◊ ◊k◊ ◊s_1)◊ ◊s◊big)$                  ◊~
◊${◊Eval^+◊sem{◊p}◊r◊g◊k◊s = (◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ ◊k◊ ◊s)}            ◊~
◊${(◊s_0◊ (◊r_0◊ ◊sem*{call/cc})) = }                                    ◊|
◊${◊quad◊Inj{Значение}(}◊*$\lambda ◊e^*◊g◊k◊s.
$                         ◊◊
                ◊${◊IF   #◊e^* = 1}                                     ◊◊
                ◊${◊THEN (}◊.◊${◊e^*◊car1◊Prj{Функции}}                    ◊◊
                        ◊${◊langle◊Inj{Значение}(}◊*◊${\lambda◊e^*_1◊g_1◊k_1◊s_1.}◊◊
                                    ◊${◊IF   #◊e^*_1 = 1}                      ◊◊
                                    ◊${◊THEN (◊k◊ ◊e^*_1◊car1◊ ◊g_1◊ ◊s_1)}     ◊◊
                                    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}◊◊
                                    ◊${◊ENDIF)◊rangle◊ ◊g◊ ◊k◊ ◊s)}  ◊-◊-◊◊
                ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}             ◊◊
                ◊${◊ENDIF)}
◊end{denotation}◊end{semantic}%
◊caption{Scheme с~глобальным окружением.}%
◊label{denotational/global/fig:global-scheme}%
◊end{table}


◊subsection{Глобальное~окружение в~Scheme}%
◊label{denotational/global/ssect:in-scheme}

С~помощью подобного базиса можно реализовать несколько вариантов глобального
окружения.
В~стандарте Scheme используется следующая вариация:
1)~получить значение переменной можно только если она существует
и~инициализирована;
2)~изменять значение переменной можно только если она существует;
3)~переопределение переменной эквивалентно присваиванию.

◊indexR{ГлобальноеОкружение@◊Vset{ГлобальноеОкружение}}
◊indexR{ЛокальноеОкружение@◊Vset{ЛокальноеОкружение}}
◊indexE{no-binding@◊ii{no-binding}}
◊indexE{no-global-binding@◊ii{no-global-binding}}
Чтобы выразить первые два правила, нам необходим способ проверки, определена~ли
переменная в~окружении.
Для этого расширим область значений окружений: к~домену
адресов прибавим специальное значение, которое не~является адресом и обозначает
отсутствие привязки в~окружении:
%
◊begin{align*}
   ◊Vset{ЛокальноеОкружение}◊colon& ◊quad ◊Vset{Переменная} ◊to ◊Vset{Адрес}
                                          + ◊{ ◊fn{no-binding} ◊}             ◊◊
  ◊Vset{ГлобальноеОкружение}◊colon& ◊quad ◊Vset{Переменная} ◊to ◊Vset{Адрес}
                                          + ◊{ ◊fn{no-global-binding} ◊}
◊end{align*}

Теперь смысл ссылок и присваиваний должен быть ясен: сначала мы ищем локальную
переменную, если не~находим, то продолжаем искать уже в~глобальном окружении.
В~итоге у~нас на руках или~адрес, с~которым мы идём к~памяти, или~◊${◊bot},
который отдаётся как есть.
Конечно, кроме этого ещё надо подправить начальные
окружения.

◊begin{denotation}
◊${(◊r_0◊ ◊n) = ◊ii{no-binding}}                  ◊|
◊${(◊g_0◊ ◊n) = ◊ii{no-global-binding}}           ◊|
◊${◊Eval◊sem{◊n}◊r◊g◊k◊s = {}}◊.
  ◊${◊LET ◊a = (◊r◊ ◊n)}                          ◊◊
  ◊${◊IN {}}◊.◊${◊IF   ◊a = ◊ii{no-binding}}        ◊◊
            ◊${◊THEN {}}◊.◊${◊LET ◊a_1 = (◊g◊ ◊n)}  ◊◊
                        ◊${◊IN {}}◊.◊${◊IF   ◊a_1 = ◊ii{no-global-binding}}       ◊◊
                                  ◊${◊THEN ◊ii{wrong}◊ ◊dc{"No such variable"}} ◊◊
                                  ◊${◊ELSE (◊k◊ (◊s◊ ◊a_1)◊ ◊g◊ ◊s)}            ◊◊
                                  ◊${◊ENDIF}                                ◊-◊-◊◊
            ◊${◊ELSE (◊k◊ (◊s◊ ◊a)◊ ◊g◊ ◊s)}      ◊◊
            ◊${◊ENDIF}                        ◊-◊-◊|
◊${◊Eval◊sem*{(set! }◊n◊${ }◊p◊${)}◊r◊g◊k◊s = }       ◊|
◊${◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda ◊e◊g_1◊s_1.}◊.
  ◊${◊LET ◊a = (◊r◊ ◊n)}                          ◊◊
  ◊${◊IN {}}◊.◊${◊IF   ◊a = ◊ii{no-binding}}        ◊◊
            ◊${◊THEN {}}◊.◊${◊LET ◊a_1 = (◊g_1◊ ◊n)}                              ◊◊
                        ◊${◊IN {}}◊.◊${◊IF   ◊a_1 = ◊ii{no-global-binding}}       ◊◊
                                  ◊${◊THEN ◊ii{wrong}◊ ◊dc{"No such variable"}} ◊◊
                                  ◊${◊ELSE (◊k◊ ◊e◊ ◊g_1◊ ◊s_1[◊a_1 ◊to ◊e])}   ◊◊
                                  ◊${◊ENDIF}                                ◊-◊-◊◊
            ◊${◊ELSE (◊k◊ ◊e◊ ◊g_1◊ ◊s_1[◊a ◊to ◊e])}                           ◊◊
            ◊${◊ENDIF ◊s)}
◊end{denotation}

Пусть глобальные переменные определяются специальной формой ◊ic{define}, причём
для простоты положим, что она (пере)определяет исключительно ◊term{глобальные}
переменные (даже если находится внутри определения функции).
Поэтому назовём~её
◊ic{define-global}.
Итак, запишем её денотацию, которая должна или создать новую
переменную, или изменить значение уже существующей:

◊indexC{define-global}
◊begin{denotation}
◊${◊Eval◊sem*{(define-global }◊n◊${ }◊p◊${)}◊r◊g◊k◊s = }  ◊|
◊${◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda ◊e◊g_1◊s_1.}◊.
  ◊${◊LET ◊a = (◊g◊ ◊n)}                              ◊◊
  ◊${◊IN {}}◊.◊${◊IF   ◊a = ◊ii{no-global-binding}}     ◊◊
            ◊${◊THEN ◊ii{allocate}◊ ◊s_1◊ 1◊ }◊*$
                 \lambda ◊s_2◊a^*.$                 ◊◊
                    $(◊k◊ ◊e◊ ◊g_1[◊n ◊to ◊a^*◊car1]◊ %
                          ◊s_2[◊a^*◊car1 ◊to ◊e])$◊-◊◊
            ◊${◊ELSE (◊k◊ ◊e◊ ◊g_1◊ ◊s_1[◊a ◊to ◊e])} ◊◊
            ◊${◊ENDIF ◊s)}
◊end{denotation}

◊indexR{г амма0@◊${◊g_0} (начальное окружение)}
◊indexE{g amma0@◊${◊g_0} (начальное окружение)}
Единственная деталь, оставшаяся недоработанной, — это начальное состояние
глобального окружения~◊${◊g_0}.
Сейчас в~нём нет ни~одной переменной, но мы
могли~бы их туда добавить.
Можно сделать так, чтобы в~начальном глобальном
окружении были лишь примитивы, а можно добавить туда все мыслимые переменные:
раз~уж все повторные определения переменной эквивалентны присваиванию ей, то
пусть и первое будет таким~же.


◊subsection{Автоматически~расширяемое окружение}%
◊label{denotational/global/ssect:autoexpand}

◊indexR{автоматически расширяемое окружение}
◊indexR{глобальное окружение!автоматически расширяемое}
Некоторые диалекты Лиспа делают немного по-другому: в~них первое присваивание
переменной эквивалентно её определению.
Это можно легко реализовать, вместо
ошибки создавая новую переменную при присваивании.

◊begin{denotation}
◊${◊Eval◊sem*{(set! }◊n◊${ }◊p◊${)}◊r◊g◊k◊s = }       ◊◊
◊${◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda ◊e◊g_1◊s_1.}◊.
  ◊${◊LET ◊a = (◊r◊ ◊n)}                          ◊◊
  ◊${◊IN {}}◊.◊${◊IF   ◊a = ◊ii{no-binding}}        ◊◊
            ◊${◊THEN {}}◊.◊${◊LET ◊a_1 = (◊g_1◊ ◊n)}                              ◊◊
                        ◊${◊IN {}}◊.◊${◊IF   ◊a_1 = ◊ii{no-global-binding}}       ◊◊
                                  ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ 1}        ◊◊
                                              ◊*◊${\lambda◊s_2◊a^*.}            ◊◊
                                                $(◊k◊ ◊e◊ ◊g_1[◊n
                                                 ◊to ◊a^*◊car1]◊ ◊s_2[◊a^*◊car1
                                                 ◊to ◊e])$                ◊-◊-◊◊
                                  ◊${◊ELSE (◊k◊ ◊e◊ ◊g_1◊ ◊s_1[◊a_1 ◊to ◊e])}   ◊◊
                                  ◊${◊ENDIF}                                ◊-◊-◊◊
            ◊${◊ELSE (◊k◊ ◊e◊ ◊g_1◊ ◊s_1[◊a ◊to ◊e])}                           ◊◊
            ◊${◊ENDIF ◊s)}
◊end{denotation}

Преимущество такой вариации в~том, что нам больше не~требуется отдельная форма
◊ic{define}.
Недостаток~же в~том, что ошибки в~именах переменных становятся
менее заметными, так как никаких предупреждений о~неопределённых переменных уже
не~выводится.


◊subsection{Гиперстатическое окружение}%
◊label{denotational/global/ssect:hyperstatic}

◊indexR{гиперстатическое окружение}
◊indexR{глобальное окружение!гиперстатическое}
◊indexR{окружение!глобальное!гиперстатическое}
В~гиперстатическом случае замыкания захватывают не~только локальное окружение,
но и текущее состояние глобального.
Это поведение реализуется простым изменением
определения абстракции из таблицы~◊ref{denotational/global/fig:global-scheme}:

◊indexC{lambda}
◊begin{denotation}
◊${◊Eval◊sem*{(lambda (}◊n^*◊${) }◊p^+◊${)}◊r◊g◊k◊s =}       ◊|
◊${◊quad(◊k◊ ◊Inj{Значение}(\lambda◊e^*◊g_1◊k_1◊s_1.}◊.
    ◊${◊IF   #◊e^* = ◊#◊n^*}                            ◊◊
    ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ #◊n^*}          ◊◊
              ◊*◊${\lambda ◊s_2◊a^*.}                    ◊◊
                $(◊Eval^+◊sem{◊p^+}◊ ◊r[◊n^* ◊to*{*}
                 ◊a^*]◊ ◊g◊ ◊k_1◊ ◊s_2[◊a^* ◊to*{*} ◊e^*])$ ◊-◊-◊◊
    ◊${◊ELSE ◊ii{wrong}◊ ◊dc{"Incorrect arity"}}         ◊◊
    ◊${◊ENDIF)◊ ◊g◊ ◊s)}
◊end{denotation}

Если присваивание, как в~Scheme, может изменять значения только существующих
переменных, то такое определение не~вызывает проблем.
Если~же ◊ic{set!} может
работать как ◊ic{define}, то поведение уже не~всегда очевидно.
Например:

◊indexC{weird}
◊code:lisp{
(define (weird v)
  (set! a-new-variable v) )
}

◊noindent
Присваивание внутри ◊ic{weird} расширяет глобальное окружение, захваченное
замыканием.
Но состояние этого окружения не~сохраняется между вызовами
◊ic{weird}, каждый из них начинает с~чистого листа.

◊indexC{global}
◊indexR{рекурсия!взаимная}
Также, как мы упоминали ранее, гиперстатическое глобальное окружение не~дружит
со~взаимно рекурсивными функциями.
Можно было~бы ввести специальную форму для
множественных одновременных определений, но лучше создать новый механизм для
доступа к~глобальным переменным: ◊ic{(global~◊${◊n})}.
Эта специальная форма
позволяет обратиться к~глобальной переменной~◊${◊n} в~◊term{любом} контексте,
даже если существует одноимённая локальная переменная.
Следовательно, мы сможем
определять глобальные взаимно рекурсивные функции следующим образом:

◊code:lisp{
(letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
         (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
  (define-global odd? odd?)
  (define-global even? even?) )
}

◊begin{denotation}
◊${◊Eval◊sem*{(global }◊n◊${)}◊r◊g◊k◊s = {}}◊.
  ◊${◊LET ◊a = (◊g◊ ◊n)}                                  ◊◊
  ◊${◊IN {}}◊.◊${◊IF   ◊a = ◊ii{no-global-binding}}         ◊◊
            ◊${◊THEN ◊ii{wrong}◊ ◊dc{"No such variable"}} ◊◊
            ◊${◊ELSE (◊k◊ (◊s◊ ◊a)◊ ◊g◊ ◊s)}              ◊◊
            ◊${◊ENDIF}                                ◊-◊-◊|
◊${◊Eval◊sem*{(define-global }◊n◊${ }◊p◊${)}◊r◊g◊k◊s = }      ◊|
◊${◊quad(◊Eval◊sem{◊p}◊ ◊r◊ ◊g◊ \lambda ◊e◊g_1◊s_1.}◊.
  ◊${◊LET ◊a = (◊g◊ ◊n)}                                  ◊◊
  ◊${◊IN {}}◊.◊${◊IF   ◊a = ◊ii{no-global-binding}}         ◊◊
            ◊${◊THEN {}}◊*◊${◊ii{allocate}◊ ◊s_1◊ 1}        ◊◊
                      ◊*◊${\lambda ◊s_2◊a^*.}             ◊◊
                        $(◊k◊ ◊e◊ ◊g_1[◊n ◊to ◊a^*◊car1]◊ %
                          ◊s_2[◊a^*◊car1 ◊to ◊e])$  ◊-◊-◊◊
            ◊${◊ELSE (◊k◊ ◊e◊ ◊g_1◊ ◊s_1[◊a ◊to ◊e])}     ◊◊
            ◊${◊ENDIF ◊s)}
◊end{denotation}

И~снова мы видим, как денотационная семантика позволяет элегантно описывать
разнообразные варианты окружений.
Конечно, мы также могли~бы легко объединить
определённые выше окружения, получив множественные пространства имён, как это
сделано в~{◊CommonLisp}.


◊section[#:label "denotational/sect:beneath"]{Под~капотом у~денотаций}

Предназначением данной главы было снять покров таинственности с~денотационной
семантики.
Здесь это сделано весьма неформально (кое-кто~бы поправил:
"`кощунственно"'), так как именно такой подход полезен для популяризации
денотационной семантики.
Мы постепенно уточняли определяемый язык с~помощью
различных интерпретаторов, одновременно с~этим используя всё более и более
ограниченный язык описания; в~итоге к~этой главе мы дошли до чистой математики,
до денотационного интерпретатора.

◊indexR{денотация!исполнимость}
Scheme и ◊${\lambda}-исчисление — дальние родственники, но всё~же
родственники.
Поэтому вполне возможно сделать денотации исполнимыми, чтобы
получить возможность исправить ошибки в~этих запутанных уравнениях.
Возможность
перепроверить правильность денотаций с~помощью компьютера очень важна: так можно
убедиться в~том, что язык ведёт себя именно так, как задумано; это позволяет
экспериментировать с~языком без опаски что-либо сломать.
Так как денотации
почти непосредственно исполнимы, отсутствует необходимость писать сложный
интерпретатор и доказывать, что он правильно понимает их семантику.

◊indexE{LISP0@LISP2◊TeX}
Поэтому писать транслятор денотаций в~исполнимый код приятно и полезно.
Он
не~уменьшает мощь ◊${\lambda}-исчисления, хоть и накладывает одно ограничение:
все вызовы производятся по значению (используется «плохое» правило вычислений
Scheme).
Но эта не~такая уж и проблема.
Заявляю при свидетелях: все денотации,
приведённые в~данной главе, на самом деле выполнены на~Scheme и пропущены через
небольшой препроцессор (LISP2◊TeX), который перевёл их на греческий
◊cite{que93d}.
% А я захардкодил все эти закарлючки самостоятельно, да.
Представьте себе, скольких трудов стоило~бы сделать денотации
исполнимыми (и~протестировать их), если~бы для симуляции аппликативного
◊${\lambda}-исчисления (в~котором, к~тому~же, ещё и порядок вычислений должен
быть неопределённым) использовался~бы не~аппликативный язык!

◊indexR{абстракция!денотация}
Вот пример исходного кода для денотации простой абстракции (с~фиксированной
арностью).
Можете сравнить его с~соответствующим «греческим профилем»
на странице~◊pageref{denotational/sematics/fig:naked-scheme}.

◊code:lisp{
(define ((meaning-abstraction n* e+) r k s)
  (k (inValue (lambda (v* k1 s1)
                (if (= (length v*) (length n*))
                    (allocate s1 (length n*)
                              (lambda (s2 a*)
                                ((meaning*-sequence e+)
                                 (extend* r n a*)
                                 k1
                                 (extend* s2 a* v*) ) ) )
                    (wrong "Incorrect arity") ) ))
     s ) )
}

◊indexCS{define}{синтаксис}
Здесь используется устаревшая форма ◊ic{define}, которая понимает ◊ic{(define
(◊${◊n}~.~◊ii{переменные}) ◊${◊p^*})} как ◊ic{(define ◊${◊n} (lambda ◊ii{переменные}
◊${◊p^*}))}, где ◊${◊n}~описывает форму вызова определяемой функции.

Заданные подобным образом функции ставятся под начало синтаксического
анализатора, который по получаемому выражению определяет соответствующую
функцию для его обработки.
Его структура вам давно знакома:

◊indexC{meaning}
◊code:lisp{
(define (meaning e)
  (if (atom? e)
      (if (symbol? e) (meaning-reference e)
                      (meaning-quotation e) )
      (case (car e)
        ((quote)  (meaning-quotatione (cadr e)))
        ((lambda) (meaning-abstraction (cadr e) (cddr e)))
        ((if)     (meaning-alternative (cadr e) (caddr e) (cadddr e)))
        ((begin)  (meaning-sequence (cdr e)))
        ((set!)   (meaning-assigment (cadr e) (caddr e)))
        (else     (meaning-application (car e) (cdr e))) ) ) )
}


◊section{◊texorpdfstring{◊${\lambda}-исчисление и~Scheme}%
{λ-исчисление и Scheme}}%
◊label{denotational/sect:lambdify}

◊indexR{Лисп!и лямбда-исчисление@и ◊${\lambda}-исчисление}
◊indexE{Scheme!и лямбда-исчисление@и~◊${\lambda}-исчисление}
Так как для нас важен вопрос исполнимости денотаций, то следует подробнее
разобраться в~различиях между Scheme и ◊${\lambda}-исчислением.
(Естественно,
имеется в~виду «целомудренное» подмножество Scheme, не~испорченное побочными
эффектами, присваиваниями {◊itp}) Самое главное отличие лежит в~порядке
вычислений.
В~◊${\lambda}-исчислении нет фиксированного порядка, есть только
не~очень хорошие порядки, которых стоит избегать.
В~Scheme~же всё по-другому:
здесь обязателен аппликативный порядок вычислений.
То~есть, хоть
последовательность вычисления аргументов и не~определена, но все они должны быть
вычислены до применения функции.
Кроме того, это~же правило запрещает вычислять
тела ◊ic{lambda}-форм раньше времени.

◊indexR{обещания}
Вызовы по имени можно проэмулировать в~Scheme с~помощью ◊term{обещаний}
(promises, также известны как thunks, futures или delays).
Обещание — это
замыкание без параметров, инкапсулирующее отложенные вычисления.
Мы можем дать
обещание что-то вычислить с~помощью ◊ic{delay} и потребовать выполнения
обещания с~помощью ◊ic{force}.
Эти функции на Scheme определяются элементарно:

◊indexC{delay}
◊indexC{force}
◊code:lisp{
(define-syntax delay
  (syntax-rules ()
    ((delay expression) (lambda () expression)) ) )

(define (force promise) (promise))
}

◊indexR{вызов!по имени!эмуляция}
Форма ◊ic{delay} замыкает вычисления вместе с~их окружением в~обещании, которое
можно выполнить, передав его ◊ic{force}.
Используя обещания, можно легко
проэмулировать вызов по имени, преобразуя каждый вызов ◊ic{(◊${f} ◊${a} ...
◊${z})}
в~◊ic{(◊${f} (delay ◊${a}) ...
(delay ◊${z}))}, а когда нам внутри понадобится
значение аргумента, мы его затребуем с~помощью ◊ic{force}.
Рассмотрим пример.
Вот выражение, с~которым у~нас были проблемы из-за аппликативного порядка
вычислений:

◊code:lisp{
(((lambda (x) (lambda (y) y))|◊dialect{;◊ic{ $◊big((\lambda x.
\lambda y.
                                                y◊ (\omega◊ \omega))◊ z◊big)$}}|
  ((lambda (x) (x x)) (lambda (x) (x x))) ) z )
}

Использовав вышеуказанный приём, мы задерживаем вычисление ◊${(\omega◊ \omega)} до
тех пор, пока его значение не~потребуется (то~есть навсегда), и возвращаем
правильное значение нормальной формы этого выражения — значение свободной
переменной~◊ic{z}.

◊code:lisp{
(((lambda (x) (lambda (y) (delay y)))
  (delay ((lambda (x) ((force x) (delay (force x))))
          (lambda (x) ((force x) (delay (force x)))) )) )
 (delay z) )
}

◊indexR{мемоизация}
◊indexR{вызов!по необходимости}
Хотя это несомненно работает ◊cite{dh92}, но вычисления выполняются
неэффективно.
Не~говоря уже о~бессмысленных ◊ic{(delay (force~x))}, сейчас
каждый вызов ◊ic{force} требует вычислить нам значение ◊emph{заново}.
А~ведь
мы можем вычислить его один раз, сохранить где-нибудь и впоследствии просто
возвращать уже сохранённое значение.
Такой приём называется вызовом по
необходимости или ◊term{мемоизацией}.
Для его использования потребуется изменить
определение ◊ic{delay}, чтобы обещание при его выполнении запоминало результат.
К~счастью, Scheme прекрасно подходит для метапрограммирования, так что
реализация такого поведения не~представляет труда:

◊indexCS{delay}{◊ic{memo-delay}}
◊code:lisp{
(define-syntax memo-delay
  (synatax-rules ()
    ((memo-delay expression)
     (let ((already-computed? #f)
           (value 'wait) )
       (lambda ()
         (if (not already-computed?)
             (begin (set! value expression)
                    (set! already-computed? #t) ) )
         value ) ) ) ) )
}

◊indexR{анализ строгости}
◊indexR{ленивые вычисления}
Конечно, вовсе необязательно преобразовывать все вызовы вручную, когда в~языке
есть макросы, см.~◊cite{dfh86}.
Если~же мы желаем максимальной эффективности, то
существует техника ◊term{анализа строгости} (strictness analysis), которая
определяет, какие объекты бессмысленно заворачивать в~обещания, потому что они
вычисляются всегда ◊cite{bhy88}.
Наконец, сами обещания можно представлять иным
образом, чтобы минимизировать затраты времени на проверку ◊ic{(if
(not~already-computed?) ...)}.
Обещания добавляют в~Scheme ленивые вычисления,
где преобразования лишь описываются, а выполняются уже самостоятельно и
автоматически в~нужное время.
Однако такой стиль программирования вызывает
очевидные затруднения при отладке, а также не~особо сочетается с~побочными
эффектами и продолжениями.
Сравним, например, следующие программы
из~◊cite{kw90,mor92}, они отличаются лишь на одну~◊ic{delay}, но дают
совершенно различные результаты:

◊code:lisp{
(pair? (call/cc (lambda (k) (list (k 33)))))
(pair? (call/cc (lambda (k) (list (delay (k 33))))))
}


◊subsection{Круговорот продолжений в~природе}%
◊label{denotational/lambdify/ssect:cps}

◊indexC{call/cc}
Только совсем~уж невнимательный читатель ещё не~заметил, что все денотации были
записаны в~◊term{стиле передачи продолжений} (◊english{continuation passing
style}).
Очевидно, что мы можем транслировать любую программу на Scheme,
использует она ◊ic{call/cc} или нет, в~её денотационный эквивалент
в~◊${\lambda}-исчислении.
Но ведь сами ◊${\lambda}-термы тоже однозначно
представляются в~виде программ на Scheme, которые не~используют ◊ic{call/cc}.
Вопрос: а можно~ли преобразовать программу на Scheme, содержащую~◊ic{call/cc},
в~эквивалентную программу на Scheme, но без~◊ic{call/cc}?

Ответ: да, но в~этом случае нам придётся передавать продолжения явно.
К~счастью,
с~этим нет особых проблем, так как продолжения — это те~же ◊ic{lambda}-формы.
В~действительности, некоторые компиляторы ◊cite{app92a} намеренно переводят
компилируемые программы сначала в~такой промежуточный вид, чтобы избавиться от
«особенной» формы~◊ic{call/cc}.
Однако, у~этого приёма есть и недостатки: он
сильно вредит читабельности получаемого кода, а также иногда преждевременно
вносит упорядоченность в~вычисления.
Тем не~менее, программы, как показано
в~◊cite{sf92}, действительно остаются эквивалентными.
Преобразование,
рассматриваемое здесь, вдохновлено работой ◊cite{df90}.
В~разделе~◊ref{cc/call/cc/ssect:cc} рассматривается иной вариант.
◊seePage[cc/call/cc/ssect:cc]

◊indexE{CPS}
◊indexR{преобразование!в CPS}
◊indexR{стиль передачи продолжений (CPS)!CPS-преобразование}
Перейдём к~реализации.
Мы полагаем, что отныне всякая функция принимает
дополнительный аргумент◊footnote{Он передаётся первым, чтобы упростить
работу с~функциями переменной арности.} — своё продолжение.
То~есть
◊ic{◊cont*{k}(foo bar~...
hux)} превращается в~◊ic{(foo ◊${k} bar~...
hux)}.
С~продолжениями разобрались, с~функциями тоже, остались специальные формы.
Их разбор и преобразование производится обычным способом.
Продолжения в~них
используются точно так~же, как и в~денотациях: для вычисления и хранения
промежуточных результатов, а также для передачи управления следующему коду
(оставшимся вычислениям).

◊indexC{cps}
◊code:lisp{
(define (cps e)
  (if (atom? e) (lambda (k) (k `,e))
      (case (car e)
        ((quote)  (cps-quote (cadr e)))
        ((if)     (cps-if (cadr e) (caddr e) (cadddr e)))
        ((begin)  (cps-begin (cdr e)))
        ((set!)   (cps-set! (cadr e) (caddr e)))
        ((lambda) (cps-abstraction (cadr e) (cddr e)))
        (else     (cps-application e)) ) ) )
}

Транслятор~◊ic{cps} принимает программу, выполняет преобразования и возвращает
замыкание, являющееся той~же программой в~стиле передачи продолжений.
Такая
программа принимает своё продолжение (такое~же замыкание) и возвращает результат
вычислений, представляемый ещё одним замыканием.
В~итоге, ◊ic{cps} имеет
следующий своеобразный тип:
%
◊[
  ◊Vset{Программа} ◊to
      ◊big((◊Vset{Программа} ◊to ◊Vset{Программа}) ◊to ◊Vset{Программа}◊big)
◊]

Цитирование снова элементарно:

◊indexC{cps-quote}
◊code:lisp{
(define (cps-quote data)
  (lambda (k)
    (k `(quote ,data)) ) )
}

Присваивание тоже просто записывается:

◊indexC{cps-set"!}
◊code:lisp{
(define (cps-set! variable form)
  (lambda (k)
    ((cps form)
     (lambda (a)
       (k `(set! ,variable ,a)) ) ) ) )
}

◊noindent
Мы вычисляем новое значение переменной~◊ic{(cps form)}, передаём его
промежуточному продолжению через переменную~◊ic{a}, затем передаём результат
присваивания дальнейшей программе.

Условный оператор действует аналогично:

◊indexC{cps-if}
◊code:lisp{
(define (cps-if bool formT formF)
  (lambda (k)
    ((cps bool)
     (lambda (b)
       `(if ,b ,((cps formT) k)
               ,((cps formF) k) ) ) ) ) )
}

Упорядочить вычисления чуть сложнее:

◊indexC{cps-begin}
◊code:lisp{
(define (cps-begin e)
  (if (pair? e)
      (if (pair? (cdr e))
          (let ((void (gensym "void")))
            (lambda (k)
              ((cps (car e))
               (lambda (a)
                 ((cps-begin (cdr e))
                  (lambda (b)
                    (k `((lambda (,void) ,b) ,a)) ) ) ) ) ) )
          (cps (car e)) )
      (cps '()) ) )
}

◊noindent
Здесь интересным местом является способ игнорирования промежуточных значений.

Самое сложное — это обработка ◊ic{lambda}-форм.
Им всем надо добавить
ещё один аргумент — продолжение "--- и гарантировать правильность его
передачи.
Кроме этого мы введём небольшую оптимизацию для простых функций
(которые быстро выполняются и всегда возвращают результат).
Список
◊ic{primitives} определяет перечень таких функций.◊footnote*{Правильная
оптимизация вызовов предопределённых примитивов рассматривается
в~разделе~◊ref{fast/fast/ssect:integrating}.}

◊indexC{cps-application}
◊indexC{cps-terms}
◊indexC{cps-abstraction}
◊code:lisp{
(define (cps-application e)
  (lambda (k)
    (if (memq (car e) primitives)
        ((cps-terms (cdr e))
         (lambda (t*)
           (k `(,(car e) ,@t*)) ) )
        ((cps-terms e)
         (lambda (t*)
           (let ((d (gensym)))
             `(,(car t*) (lambda (,d) ,(k d))
                         . ,(cdr t*) ) ) ) ) ) ) )

(define primitives '(cons car cdr list * + - = pair? eq?))

(define (cps-terms e*)
  (if (pair? e*)
      (lambda (k)
        ((cps (car e*))
         (lambda (a)
           ((cps-terms (cdr e*))
            (lambda (a*)
              (k (cons a a*)) ) ) ) ) )
      (lambda (k) (k '())) ) )

(define (cps-abstraction variables body)
  (lambda (k)
    (k (let ((c (gensym "cont")))
         `(lambda (,c . ,variables)
            ,((cps `(begin ,@body))
              (lambda (a) `(,c ,a)) ) ) )) ) )
}

◊noindent
Готово.
Посмотрим, во~что данная трансформация превратит факториал:

◊indexC{fact}
◊code:lisp{
(set! fact (lambda (n)
             (if (= n 1) 1
                 (* n (fact (- n 1))) ) ))
|◊${◊leadsto}| (set! fact
         (lambda (cont112 n)
           (if (= n 1)
               (cont112 1)
               (fact (lambda (g113) (cont112 (* n g113)))
                     (- n 1) ) ) ) )
}

Теперь мы автоматически получаем то, что раньше были вынуждены писать вручную.
Заметьте, что преобразование превратило программу в~последовательность простых
вызовов функций: сравнений, арифметики и продолжений.
Нет никаких дополнительных
особых случаев, кроме специальных форм.

После CPS-преобразования форма ◊ic{◊cont*{k}(call/cc~f)} превращается
в~◊ic{(call/cc ◊${k}~f)}, а сама функция~◊ic{call/cc} становится вообще
тривиальной: ◊ic{(lambda (k~f) (f~k~k))}, поэтому мы на ней и
не~останавливались.
Единственная загвоздка в~том, чтобы сами продолжения,
возвращаемые ◊ic{call/cc}, оставались функциями.
То~есть, чтобы форма
◊ic{(procedure? (apply call/cc (list~call/cc)))} возвращала истину.

Одним из достоинств стиля передачи продолжений является то, что благодаря явному
указанию, когда что вычислять и кому возвращать результат, становится без
разницы, нормальный~ли порядок принят в~языке реализации или аппликативный.
В~обоих случаях мы получим одинаковое поведение.
Поэтому использование обещаний
совместно с~подобным стилем позволяет сократить разрыв между Scheme
и~◊${\lambda}-исчислением ◊cite{dh92}.


◊subsection[#:label "denotational/lambdify/ssect:dynamic"]{Динамическое окружение}

◊indexR{динамическое окружение}
◊indexR{окружение!динамическое}
В~предыдущем разделе денотации натолкнули нас на идею преобразования программ,
позволяющего избавиться от~◊ic{call/cc}.
Ранее мы рассматривали динамическое
окружение; а ведь мы можем аналогичным образом избавиться и от форм
◊ic{dynamic-let} и~◊ic{dynamic}.
Для этого потребуется явно ввести динамическое
окружение и определить соответствующее преобразование программ.

◊indexE{D@◊${◊Dana}, преобразование}
◊indexR{преобразование!динамического окружения (◊${◊Dana})}
Предположим, у~нас есть идентификатор, который не~используется ни~в~одной
программе.
Назовём его~◊${◊d}.
Свяжем его с~динамическим окружением — функцией,
которая по имени динамической переменной возвращает её значение.
Предположим,
что у~нас есть функция ◊ic{update}, которая умеет расширять подобное окружение
◊seePage[assignment/implementation/ssect:environment], которая доступна
отовсюду, которую нельзя переопределить, перекрыть локальными переменными
{◊itp} Используя всё это, можно реализовать преобразования ◊${◊Dana}
и~◊${◊Dana^*}, приведённые
в~таблице~◊ref{denotational/lambdify/dynamic/fig:transform}.

◊begin{table}[!ht]◊setlength{◊tabcolsep}{0.3em}◊small%
◊begin{tabular}{lcl}
◊${◊Dana^*◊sem{◊,}} & ◊${◊to} & ◊◊
◊${◊Dana^*◊sem{◊p◊ ◊p^*}}
    & ◊${◊to} &
  ◊${◊Dana◊sem{◊p}◊ ◊Dana^*◊sem{◊p^*}}                              ◊◊
%
◊${◊Dana◊sem*{(if }◊p_c◊${ }◊p_t◊${ }◊p_f◊${)}}
    & ◊${◊to} &
  ◊ic{(if ◊${◊Dana◊sem{◊p_c}} ◊${◊Dana◊sem{◊p_t}} ◊${◊Dana◊sem{◊p_f}})} ◊◊
%
◊${◊Dana◊sem*{(begin }◊p^*◊${)}}
    & ◊${◊to} &
  ◊ic{(begin ◊${◊Dana^*◊sem{◊p^*}})}                                ◊◊
%
◊${◊Dana◊sem*{(}◊p◊${ }◊p^*◊${)}}
    & ◊${◊to} &
  ◊ic{(◊${◊Dana◊sem{◊p}} ◊${◊d} ◊${◊Dana^*◊sem{◊p^*}})}                 ◊◊
%
◊${◊Dana◊sem*{(lambda (}◊n^*◊${) }◊p^*◊${)}}
    & ◊${◊to} &
  ◊ic{(lambda (◊${◊d} ◊${◊n^*}) ◊${◊Dana^*◊sem{◊p^*}})}                 ◊◊
%
◊${◊Dana◊sem*{(dynamic }◊n◊${)}} & ◊${◊to} & ◊ic{(◊${◊d} (quote ◊${◊n}))}   ◊◊
%
◊${◊Dana◊sem*{(dynamic-let (}◊n◊${ }◊p◊${) }◊p^+◊${)}}
    & ◊${◊to} &
  ◊ic{(let ((◊${◊d} (update ◊${◊d} (quote ◊${◊n}) ◊${◊p}))) ◊${◊Dana^*◊sem{◊p^+}})}
◊end{tabular}%
◊caption{Трансформация, убирающая динамическое окружение.}%
◊label{denotational/lambdify/dynamic/fig:transform}%
◊end{table}

Таким образом мы можем проэмулировать динамическое окружение, если не~можем или
не~хотим встраивать его поддержку в~ядро языка.
Последний штрих: начальное
динамическое окружение.
Программа~◊${◊p} преобразуется~в

◊code:lisp{
(let ((|◊${◊d}| (lambda (n) (error "No such dynamic variable" n)))) |◊${◊Dana◊sem{◊p}}|)
}

В~итоге можно сделать следующий вывод: денотации специальных форм языка иногда
способны показать, что некоторые формы вовсе не~такие уж и специальные.


◊section[#:label "denotational/sect:conclusions"]{Заключение}

Данная глава венчает серию интерпретаторов, определяющих Scheme всё точнее и
точнее с~использованием всё более ограниченных средств.
Денотационная семантика,
по крайней мере в~рассмотренном виде, позволяет очень точно и лаконично
описывать ◊term{ядро} языка.
Она плохо подходит для описания всего языка, его
мельчайших деталей, так как на таком уровне нотация уже чрезмерно усложняется.

В~данной главе среди важных вещей мы не~рассмотрели сравнение функций, денотацию
констант, а также всевозможные не~особо важные тонкости, которые редко заметны и
ещё реже используются.
Денотационная семантика прекрасно подходит для
набрасывания общей формы языка, но проработка деталей с~её помощью становится
неимоверно скучной.

Существует огромное множество вещей, которые можно описать с~помощью
денотационной семантики.
Например, организовать параллелизм с~помощью техники
пошаговых вычислений ◊cite{que90c}.
Или распределённое хранение и~обработку
данных ◊cite{que92b}.
Но есть также вещи, которые таким образом описывать
неудобно ◊cite{mcd93}.
К~примеру, вывод типов довольно сложно выразить
денотационно, именно поэтому существует естественная семантика ◊cite{kah87}.


◊section[#:label "denotational/sect:exercises"]{Упражнения}

◊begin{exercise}◊label{denotational/ex:truly-random}
◊indexR{интерпретатор!E@◊${◊Eval}}
◊indexE{E-@◊${◊Eval}, интерпретатор}
Рассмотрим ещё один способ денотации аппликации.
Докажите, что он эквивалентен
показанному в~разделе~◊ref{denotational/semantics/ssect:application}.

◊begingroup
◊def◊rev#1{◊overline{◊mathstrut◊kern-0.1em #1 ◊kern0.1em}}
◊begin{denotation}
◊${◊Eval◊sem*{(}◊p◊${ }◊p^*$)}◊r◊k◊s =
    (◊Eval◊sem{◊p}◊ ◊r◊ \lambda ◊f◊s_1.
        (◊rev◊Eval◊sem{◊p^*}◊ ◊seq{}◊ ◊r◊ \lambda ◊e^*◊s_2.
            (◊f|_{◊Vset{Функции}}◊ ◊e^*◊ ◊k◊ ◊s_2)◊ ◊s_1)◊ ◊s)$   ◊|
◊${◊rev◊Eval◊sem{◊,}◊e^*◊r◊k◊s = (◊k◊ (◊ii{reverse}◊ ◊e^*)◊ ◊s)}     ◊|
$◊rev◊Eval◊sem{◊p◊ ◊p^*}◊e^*◊r◊k◊s = (◊Eval◊sem{◊p}◊ ◊r◊ \lambda ◊e◊s_1.
    (◊rev◊Eval◊sem{◊p^*}◊ ◊seq{◊e}◊append◊e^*◊ ◊r◊ ◊k◊ ◊s_1)◊ ◊s)$
◊end{denotation}
◊endgroup
◊end{exercise}

◊begin{exercise}◊label{denotational/ex:label}
◊indexC{label}
Определения из~раздела~◊ref{denotational/sect:lambda} слишком затрудняют
описание рекурсивных функций.
Мы могли~бы, как в~◊LISP~1.5, ввести специальную
форму ◊ic{label}.
В~Scheme форма ◊ic{(label ◊${◊n} (lambda~...))} эквивалентна
◊ic{(letrec ((◊${◊n} (lambda~...))) ◊${◊n})}.
Определите семантику аналогичного
оператора~◊ic{label} для ◊${\lambda}-исчисления.
◊end{exercise}

◊begin{exercise}◊label{denotational/ex:dynamic-fallback}
Измените денотацию ◊ic{dynamic} таким образом, чтобы в~случае отсутствия
динамической переменной с~искомым именем возвращалась одноимённая переменная
из глобального окружения.
◊end{exercise}

◊begin{exercise}◊label{denotational/ex:quantum}
◊indexR{порядок вычислений!неопределённый}
Напишите макрос, который~бы эмулировал неопределённый порядок вычисления
аргументов в~такой реализации Scheme, где аргументы вычисляются слева направо.
В~вашем распоряжении есть унарная функция ◊ic{random-permutation}, которая
принимает целое число~◊${n} и возвращает случайную перестановку
чисел~◊${0, ◊dots, n - 1}.
◊end{exercise}


◊section*{Рекомендуемая литература}

Я настойчиво рекомендую обратить внимание на книги ◊cite{sto77} и~◊cite{sch86}.
В~обеих содержатся просто горы информации о~денотационной семантике, а~также
примеры денотирования языков.

Тем~же, кого серьёзно зацепило ◊${\lambda}-исчисление, стоит приняться за
классическую книгу~◊cite{bar84}.

◊endgroup % ◊ChapterFiveSpecials
