% -*- coding: utf-8 -*-

◊section[#:label "escape/sect:partial"]{Частичные продолжения}

◊indexR{продолжения (continuations)!частичные продолжения}
Среди прочих вопросов, поднимаемых продолжениями, есть ещё один довольно
интересный: что именно случается с~отбрасываемым при переходе кодом? Другими
словами, с~тем куском продолжения (или~стека), который находится между
положениями до прыжка и после.
Мы говорили, что такой ◊term{срез} стека
не~сохраняется при переходе.
Но он вовсе не~является бесполезным: ведь если~бы
через него не~перешагнули, то он~бы принял какое-то значение, выполнил
определённые действия и передал~бы полученное значение своему продолжению.
То~есть вёл~бы себя как обычная функция.
Во~многих работах, вроде
◊cite{ffdm87,ff87,fel88,df90,hd90,qs91,mq94}, приводятся способы сохранения и
приёмы использования этих срезов~— ◊term{частичных продолжений}
(◊english{partial/delimited continuations}).

Рассмотрим следующий простой пример:

◊code:lisp{
(+ 1 (call/cc (lambda (k) (set! foo k) 2))) |◊is| 3
(foo 3)                                     |◊is| 4
}

◊noindent
Какое именно продолжение хранится в~◊ic{foo}? Казалось~бы ◊${◊lambda u . 1 + u},
но чему тогда равно ◊ic{(foo~(foo~4))}?

◊code:lisp{
(foo (foo 4))                               |◊is| 5
}

◊indexR{композициональность!продолжений}
◊indexR{продолжения (continuations)!композициональность}
Получается~◊ic{5}, а не~ожидаемое значение~◊ic{6}, которое~бы получилось при
правильной композиции функций.
Дело в~том, что вызов продолжения означает
отбрасывание всех последующих вычислений ради продолжения других вычислений.
Таким образом, вызов продолжения внутри ◊ic{foo} приводит к~вычислению значения
$◊lambda u.
1 + u◊${ при }u = 4$, которое становится значением всего выражения, и
второй вызов ◊ic{foo} вообще не~происходит~— он не~нужен, ведь значение
выражения уже вычислено и передано продолжению! Именно в~этом проблема: мы
захватили обычное продолжение, а не~частичное.
Обычные продолжения
◊term{активируются} и полностью заменяют стек собой, а ◊emph{не~вызываются}
как функции.

Возможно, так будет понятнее.
В~◊ic{foo} мы сохранили ◊ic{(+~1~[])}.
Это всё,
что ещё осталось вычислить.
Так как аргументы передаются по значению, то
вычисление аргумента-продолжения в~◊ic{(foo (foo 4))} фактически завершает
вычисления, отбрасывает ◊ic{(foo~[])} и возвращает значение формы ◊ic{(+~1~4)},
которое, очевидно, равно~◊ic{5}.

◊indexR{продолжения (continuations)!и интерактивная сессия}
◊indexR{интерактивная сессия (REPL)!продолжения}
◊indexE{REPL!продолжения}
Частичные продолжения представляют собой лишь часть оставшихся вычислений, тогда
как обычные продолжения~— это ◊emph{все} оставшиеся вычисления.
В~статьях ◊cite{fwfd88,df90,hd90,qs91} приводятся способы захвата частичных и,
следовательно, поддающихся композиции продолжений.
Предположим, теперь
с~◊ic{foo} связано продолжение ◊ic{[(+~1~[])]}, где внешние квадратные скобки
означают, что оно ведёт себя как функция.
Тогда ◊ic{(foo (foo~4))} будет
эквивалентно уже ◊ic{(foo [(+~1~[4])])}, что превращается в~◊ic{(+~1~5)},
которое в~итоге даёт~◊ic{6}.
Захваченное продолжение ◊ic{[(+~1~[])]} определяет
не~все последующие вычисления, которые когда-либо произойдут, а только их часть
вплоть до момента возврата значения.
Для интерактивной сессии продолжением
обычных продолжений является ◊term{главный цикл} (он~же ◊ic{toplevel}), именно
ему продолжения передают своё значение, а он выводит его на экран, читает
следующее выражение из входного потока, вычисляет его и~так~далее.
Продолжение
частичных продолжений неизвестно, именно поэтому они конечны и ведут себя как
обычные функции~— ведь функции тоже не~знают, кому они вернут значение.

Давайте взглянем на наш пример с~◊ic{(set! foo~k)} с~другой стороны.
Оставим всё
по-прежнему, но объединим эти два выражения в~явную последовательность:

◊code:lisp{
(begin (+ 1 (call/cc (lambda (k) (set! foo k) 2)))
       (foo 3) )
}

Бабах! Мы получили бесконечный цикл, так как ◊ic{foo} оказывается теперь
связанной с~◊ic{(begin (+~1~[]) (foo~3))}, что приводит к~рекурсии.
Как видим,
главный цикл~— это не~только последовательное вычисление выражений.
Если мы
хотим правильно его проэмулировать, то вдобавок необходимо изменять продолжение
каждого вычисляемого в~главном цикле выражения:

◊code:lisp{
(let (foo sequel print?)
  (define-syntax toplevel
    (syntax-rules ()
      ((toplevel e) (toplevel-eval (lambda () e))) ) )
  (define (toplevel-eval thunk)
    (call/cc (lambda (k)
               (set! print? #t)
               (set! sequel k)
               (let ((v (thunk)))
                 (when print? (display v) (set! print? #f))
                 (sequel v) ) )) )
  (toplevel (+ 1 (call/cc (lambda (k) (set! foo k) 2))))
  (toplevel (foo 3))
  (toplevel (foo (foo 4))) )
}

Каждый раз, когда мы хотим вычислить выражение с~помощью ◊ic{toplevel}, его
продолжение~— ◊emph{продолжение} работы ◊ic{toplevel} — сохраняется
в~переменной ◊ic{sequel}.
Любое продолжение, захватываемое внутри ◊ic{thunk},
теперь будет ограничено текущей вычисляемой формой.
Аналогичным образом применяя
присваивание, можно сохранить любой срез стека в~виде частичного продолжения.
Как видим, все продолжения с~неограниченным временем жизни для своего создания
требуют побочных эффектов.

◊indexR{присваивание!роль для продолжений}
Частичные продолжения явно указывают, когда необходимо остановить вычисления.
Этот эффект может быть полезен в~некоторых случаях, а также интересен сам по
себе.
Мы вполне можем даже переписать нашу ◊ic{call/cc} так, чтобы она
захватывала именно частичные продолжения вплоть до ◊ic{toplevel}.
Естественно,
кроме них потребуются также и переходы на тот случай, когда мы действительно
не~заинтересованы в~сохранении срезов стека.
Но, с~другой стороны, частичные
продолжения в~реальности используются довольно редко; сложно привести пример
программы, где частичные продолжения были~бы действительно полезны, но при этом
не~усложняли~бы её сильнее обычных.
Тем не~менее, они важны как ещё один пример
управляющей формы, которую можно реализовать на~Scheme с~помощью ◊ic{call/cc}
и~присваивания.


◊section[#:label "escape/sect:conclusions"]{Заключение}

Продолжения вездесущи.
Если вы понимаете продолжения, вы одновременно овладели
ещё одним стилем программирования, получили широчайшие возможности управления
ходом вычислений и знаете, во~что вам обойдётся это управление.
Продолжения
тесно связаны с~потоком исполнения, так как они динамически определяют всё, что
ещё осталось сделать.
Поэтому они так важны и полезны для обработки исключений.

Интерпретатор, определённый в~этой главе, довольно мощный, но легко понятный
только по частям.
Это обычное дело для объектно-ориентированного стиля: есть
много маленьких и простых кусочков, но не~так просто составить понимание цельной
картины того, как они работают вместе.
Интерпретатор модульный и легко
расширяется новыми возможностями.
Он не~особо быстрый, так как в~процессе работы
создаёт целую гору объектов, которые удаляются тут~же после использования.
Конечно, это является одной из задач компилятора: выяснить, какие из объектов
действительно стоит создавать и сохранять.


◊section[#:label "escape/sect:exercises"]{Упражнения}

◊begin{exercise}◊label{escape/ex:cc-cc}
Что вернёт ◊ic{(call/cc call/cc)}? Зависит~ли ответ от порядка вычислений?
◊end{exercise}


◊begin{exercise}◊label{escape/ex:cc-cc-cc-cc}
А~что вернёт ◊ic{((call/cc call/cc) (call/cc call/cc))}?
◊end{exercise}


◊begin{exercise}◊label{escape/ex:tagbody}
◊indexC{tagbody}◊indexC{go}
Реализуйте пару ◊ic{tagbody}/◊ic{go} с~помощью ◊ic{block}, ◊ic{catch} и
◊ic{labels}.
Напомним синтаксис этой формы из~{◊CommonLisp}:

◊code:lisp{
(tagbody
          |◊ii{выражения◊sub{0}}|...
  |◊hbox to 0pt{◊ii{метка◊sub{1}}}|        |◊ii{выражения◊sub{1}}|...
          ...
  |◊hbox to 0pt{◊ii{метка◊sub{i}}}|        |◊ii{выражения◊sub{i}}|...
          ...
)
}

Все ◊ii{выражения◊sub{i}} (и~только они) могут содержать безусловные переходы
◊ic{(go~◊ii{метка})} и возвраты ◊ic{(return~◊ii{значение})}.
Если ◊ic{return}
не~будет, то форма ◊ic{tagbody} возвращает~◊ic{nil}.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:arity-optimize}
Вы скорее всего заметили, что функции при вызове проверяют фактическую арность:
количество переданных им аргументов.
Измените механизм создания функций так,
чтобы правильная арность рассчитывалась только один раз.
Можете считать, что
функции бывают только фиксированной арности.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:apply}
Определите функцию ◊ic{apply} для интерпретатора из этой главы.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:dotted}
Реализуйте поддержку функций переменной арности для интерпретатора из этой
главы.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:evaluate}
Измените функцию запуска интерпретатора так, чтобы она вызывала ◊ic{evaluate}
только единожды.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:cc-value}
Способ реализации продолжений из
раздела~◊ref{escape/implementation/ssect:call/cc} отделяет продолжения от других
значений.
Поэтому мы вынуждены реализовывать метод ◊ic{invoke} лично для класса
продолжений, представляемых функциями языка определения.
Переопределите
◊ic{call/cc} так, чтобы она возвращала объекты определяемого языка, являющиеся
экземплярами класса-наследника ◊ic{value}, соответствующего продолжениям.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:eternal}
◊indexR{бесконечный цикл}
Напишите на {◊CommonLisp} функцию ◊ic{eternal-return}, принимающую замыкание и
вызывающую его в~бесконечном цикле.
Этот цикл должен быть истинно бесконечным:
перекройте абсолютно все выходы из него.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:crazy-cc}
Рассмотрим следующую хитроумную функцию (спасибо за неё Алану~Бодену):

◊indexR{коробки}
◊indexC{make-box}
◊code:lisp{
(define (make-box value)
  (let ((box
         (call/cc
          (lambda (exit)
            (letrec
             ((behavior
               (call/cc
                (lambda (store)
                  (exit (lambda (msg . new)
                          (call/cc
                           (lambda (caller)
                             (case msg
                               ((get) (store (cons (car behavior)
                                                   caller )))
                               ((set)
                                (store
                                 (cons (car new)
                                       caller ) ) ) ) ) ) )) ) ) ))
             ((cdr behavior) (car behavior)) ) ) ) ))
    (box 'set value)
    box ) )
}

Предположим, в~◊ic{box1} лежит значение ◊ic{(make-box~33)}, тогда что получится
в~результате следующих вычислений?

◊code:lisp{
(box1 'get)
(begin (box1 'set 44) (box1 'get))
}
◊end{exercise}


◊begin{exercise}◊label{escape/ex:generic-evaluate}
Среди всех наших функций только ◊ic{evaluate} не~является обобщённой.
Можно
создать класс программ, от которого будут наследоваться подклассы программ
с~различным синтаксисом.
Правда, в~этом случае мы не~сможем хранить программы
как S-выражения, они должны быть объектами.
Соответственно, функция
◊ic{evaluate} уже должна быть обобщённой.
Это позволит легко вводить новые
специальные формы (возможно, даже прямо из определяемого языка).
Воплотите эту
идею в~жизнь.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:throw}
Реализуйте оператор ◊ic{throw} как функцию, а не~специальную форму.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:cps-speed}
Сравните скорость выполнения обычного кода и переписанного в~стиле передачи
продолжений.
◊end{exercise}


◊begin{exercise}◊label{escape/ex:the-current-cc}
◊indexC{the-current-continuation}
Реализуйте ◊ic{call/cc} с~помощью функции ◊ic{the-current-continuation}, которая
определяется следующим образом:

◊code:lisp{
(define (the-current-continuation)
  (call/cc (lambda (k) k)) )
}
◊end{exercise}


◊section*[#:label "escape/sect:recommended-reading"]{Рекомендуемая литература}

Годный, нетривиальный пример использования продолжений приведён в
◊cite{wan80a}.
Также стоит почитать~◊cite{hfw84} об~эмуляции сопрограмм.
В~◊cite{dr87} прекрасно рассказано о~развитии понимания важности рефлексии
для управляющих форм.
