#lang pollen

◊subsubsection{Ещё~немного об~◊ic{evaluate}}

◊indexR{порядок вычислений!термов аппликации}
Рассмотренное описание языка является более-менее полным.
Мы не~разобрали лишь несколько вспомогательных функций:
◊ic{lookup} и ◊ic{update!}, отвечающие за~окружения,
и~◊ic{make-function} вместе с~◊ic{invoke}, занимающиеся функциями.
Довольно многое можно сказать об~◊ic{evaluate} уже сейчас.
Например, наш диалект имеет единое пространство имён,
содержащее только один класс объектов (типичный~◊Lisp-1),
куда включаются в~том числе и~функции.
◊seePage{chapter:lisp1-2-omega}

Что~насчёт порядка вычисления аргументов функций?
В~нашем случае он зависит от порядка вычисления аргументов у~◊ic{cons},
которая используется в~◊ic{evlis}.
Но~мы легко можем обеспечить конкретный порядок, например, слева направо:

◊code:lisp{
(define (evlis exps env)
  (if (pair? exps)
      (let ((argument1 (evaluate (car exps) env)))
        (cons argument1 (evlis (cdr exps) env)) )
      '() ) )
}

Без введения новых специальных конструкций
◊footnote{
  Как известно, ◊ic{let} — это простой макрос:
  ◊ic{(let~((◊${x}~◊${\pi_1}))~◊${\pi_2})}
  ◊(eq)
  ◊ic{((lambda~(◊${x})~◊${\pi_2})~◊${\pi_1})}.
}
мы уточнили поведение определяемого языка.
Первая часть книги направлена именно на это:
уточнение определяемого языка с~помощью всё более ограниченных возможностей,
что снижает зависимость описания от языка, используемого для реализации.
