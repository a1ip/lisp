#lang pollen

◊subsection[#:label "basics/evaluating-forms/ssect:alternatives"]{Ветвление}

◊indexC{if}
Вспомним, как работает условный оператор ◊ic{if}:
эта~форма вычисляет свой первый аргумент (◊term{условие}),
затем в~зависимости от результата вычислений выбирает,
возвращать значение второго аргумента (◊term{следствия}) или третьего (◊term{альтернативы}).
Эта~идея выражается следующим~кодом:

◊code:lisp{
... (case (car e)
      ((if) (if (evaluate (cadr e) env)
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env) )) ... ) ...
}

◊indexR{представление!логических значений}
◊indexR{логические значения}
Здесь не~совсем точно учитывается представление логических значений.
Совершенно очевидно, что мы случайно смешиваем два языка:
Scheme (или хотя~бы что-то неотличимо похожее на~него) и~Scheme (или что-то весьма похожее).
Причём мы определяем второй в~терминах первого.
Так что между этими языками присутствуют примерно те~же отношения,
что и между Паскалем (на~котором написана первая реализация~◊|TeX|) и~самой системой~◊|TeX|.
◊seeCite{knu84}
Соответственно, нет ни~единого повода считать способы представления логических значений в~этих языках одинаковыми.

Функция ◊ic{evaluate} возвращает значения определяемого языка.
Они априори никак не~связаны с~логическими значениями языка, используемого для реализации.
Следуя соглашению о~том, что любой объект, не~являющийся логической ◊term{ложью}, считается логической ◊term{истиной},
мы запишем:

◊code:lisp{
... (case (car e)
      ((if) (if (not (eq? (evaluate (cadr e) env) the-false-value))
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env) )) ... ) ...
}

◊indexC{the-false-value}
Здесь считается, что переменная~◊ic{the-false-value} хранит значение ◊term{лжи} определяемого языка,
выраженное средствами языка реализации.
Существует огромное множество вариантов представления значений.
Например, можно поступить~так:

◊code:lisp{
(define the-false-value (cons "false" "boolean"))
}

Отличный вариант, так как ◊ic{eq?} в~Scheme сравнивает не~значения объектов, а~их адреса в~памяти.
Соответственно, любое другое значение определяемого языка
никак нельзя будет спутать со~значением переменной ◊ic{the-false-value}.

◊indexC{()}
◊indexC{NIL}
◊indexR{пустой список, ◊ic{()}}
Вопрос представления логических значений вовсе не~тривиален.
В~истории Лиспа полно споров на тему различий между булевым значением~◊term{ложь}, пустым списком~◊ic{()} и символом~◊ic{NIL}.
Наиболее чёткая позиция по этому вопросу:
◊term{ложь} — это не~◊ic{()} (ведь,~в~конце концов, это всего лишь пустой список),
и~они оба тем более не~имеют никакого отношения к~символу,
состоящему из букв ◊ic{N},~◊ic{I},~◊ic{L}.

Scheme занимает именно такую позицию;
об~этом всё~же смогли договориться за пару недель до принятия стандарта~IEEE.
◊◊seeCite{iee91}.

Теперь в~Scheme всё хорошо
(разве что ◊ic{()} по-английски всё ещё читается как~◊emph{nil}!)
В~изначальном Лиспе ◊term{ложь}, ◊ic{()} и~◊ic{NIL} — это эквивалентные понятия.
В~◊|LeLisp|, например, ◊ic{NIL} — это переменная со~значением~◊ic{()},
а~пустой список (и~пустой символ~◊ic{||}) используются в~качестве~◊term{лжи}.
