#lang pollen

◊subsection*{Создание окружений}

◊indexR{окружение!как тип данных}
Окружения — это составной абстрактный тип данных.
Мы~уже умеем извлекать и изменять их части с~помощью соответствующих функций;
ещё остаётся научиться создавать новые окружения и добавлять в~них новые~элементы.

◊indexR{окружение!начальное}
Изначально в~окружении ничего нет.
Это записывается просто:

◊indexC{env.init}
◊code:lisp[#:chunk "env.init"]{
(define env.init '())
}

(Чуть позже, в~разделе~◊ref{basics/sect:representing-functions},
мы сделаем начальное окружение более обжитым.)

Когда вызывается функция, для неё создаётся новое окружение,
в~котором аргументы функции связаны со~своими фактическими значениями.
Функция~◊ic{extend} расширяет окружение~◊ic{env} переменными~◊ic{variables} со~значениями~◊ic{values}.

◊indexC{extend}
◊code:lisp[#:chunk "extend"]{
(define (extend env variables values)
  (cond ((pair? variables)
         (if (pair? values)
             (cons (cons (car variables) (car values))
                   (extend env (cdr variables) (cdr values)) )
             (wrong "Too few values") ) )
        ((null? variables)
         (if (null? values)
             env
             (wrong "Too many values") ) )
        ((symbol? variables) (cons (cons variables values) env)) ) )
}

◊indexR{список аргументов}
◊indexR{синтаксис!списка аргументов}
◊indexR{переменные!точечные}
◊indexR{точечные переменные}
Главная сложность состоит в~том, что нам надо проанализировать все варианты
записи ◊${<◊math-ii{списка аргументов}>}, какие разрешены в~Scheme.
◊footnote{
  Некоторые лисп-системы, вроде ◊CommonLisp,
  поддались соблазну расширить синтаксис перечня аргументов ключевыми словами
  вроде~◊ic{&aux}, ◊ic{&key}, ◊ic{&rest}.
  Подобные возможности заметно усложняют синтаксический разбор программ и передачу аргументов.
  Иные системы позволяют даже обобщённое указание аргументов с~помощью шаблонов~◊cite{sj93}.
}
Список аргументов может быть представлен не~только обычным списком символов,
но~и точечным: заканчивающимся не~на~◊ic{()}, а~на определённый символ (◊term{точечную переменную}).
Более формально список аргументов определяется следующей грамматикой:

◊$${
\begin{align*}
<◊math-ii{список аргументов}> & ::= &  ◊math-ic{()}           \\
                              &  |  & <◊math-ii{переменная}>  \\
                              &  |  &  ◊math-ic{(}<◊math-ii{переменная}>◊math-ic{ . }<◊math-ii{список аргументов}>◊math-ic{)} \\
       <◊math-ii{переменная}> & \in &  ◊Vset{Символы}
\end{align*}
}

Когда мы расширяем окружение, количество значений переменных должно соответствовать количеству их имён.
Обычно их поровну, но если список оканчивается на точечную (или~◊term{◊${n}-арную}) переменную,
то она связывается со~списком всех оставшихся аргументов.
Здесь возможны две~ошибки: либо~значений больше, чем переменных, либо~наоборот.
