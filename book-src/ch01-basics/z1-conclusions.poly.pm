#lang pollen

◊section*[#:label "basics/sect:conclusions"]{Заключение}

◊indexR{язык!и смысл программ}
Действительно~ли мы сейчас определили язык~программирования?

◊indexR{смысл программ}
◊indexR{программы!смысл}
Конечно, мы можем вызвать ◊ic{evaluate}, передать ей выражение, и она вскоре вернёт результат вычислений.
Но сама функция ◊ic{evaluate} не~имеет никакого смысла без языка, на котором ◊emph{она} реализована.
А~если у~нас нет реализации языка реализации, то все наши программы превращаются в~тыкву.

Так как каждый лиспер является дальним родственником барона Мюнхгаузена,
то, наверное, наш язык программирования сможет как-нибудь определить себя~сам.
Язык~◊${L}, определённый функцией~◊ic{evaluate}, написанной на языке~◊${L},
является решением следующего уравнения относительно~◊${L}:

◊$${
\begin{equation*}
  \forall\pi \in ◊Vset{Программы}\colon L◊math-ic{(evaluate (quote $\pi$) env.global)} \equiv L\pi
\end{equation*}
}

Поведение любой программы~◊${\pi}, написанной на~◊${L} (обозначается как~◊${L\pi}),
должно быть идентично (то~есть давать тот~же результат или никогда не~завершаться)
выражению~◊ic{(evaluate (quote~◊${\pi}) env.global)} на том~же языке~◊${L}.
Одним из занимательных следствий этого утверждения является то, что ◊ic{evaluate} должна быть способна
◊footnote{
  После того, как мы раскроем все используемые макросы и сокращения
  вроде ◊ic{let}, ◊ic{case}, ◊ic{define}, и~т.~д.
  Ещё необходимо будет поместить в~глобальное окружение функции ◊ic{evaluate}, ◊ic{evlis}, и~прочие.
}
проинтерпретировать сама себя.
Таким образом, следующие выражения эквивалентны:

◊; TODO: точно *нужно* делать формулой?
◊$${
\begin{gather*}
◊math-ic{(evaluate (quote $\pi$) env.global)} \\
\equiv \\
◊math-ic{(evaluate (quote (evaluate (quote $\pi$) env.global)) env.global)}
\end{gather*}
}

Есть~ли другие решения приведённого выше уравнения?
Да, и~их великое множество!
Например, как мы видели раньше, определение ◊ic{evaluate} не~указывает порядок вычислений.
Множество других свойств языка, используемого для реализации, бессознательно ◊emph{наследуются} определяемым языком.
Мы ничего не~можем о~них сказать по~сути, но все эти варианты удовлетворяют нашему уравнению.
Вместе с~многочисленными тривиальными решениями.
Рассмотрим, к~примеру, язык~◊${L_{2001}}, любая программа на котором возвращает~◊${2001}.
Даже такой язык удовлетворяет этому уравнению.
Так что для определения настоящих языков необходимы другие методы;
их~мы рассмотрим в~следующих главах.
