#lang pollen

◊subsection[#:label "basics/representing-functions/ssect:deep-or-shallow"]{Дальнее~и~ближнее связывание}

◊indexR{дальнее связывание}
◊indexR{связывание!дальнее}
◊indexC{lookup!стоимость}
История динамических переменных не~заканчивается с~появлением компиляторов.
Разработчики языков изобрели разные способы ускорения доступа к~переменным.
Если окружения представлены ассоциативными списками,
то время на поиск значения переменной (стоимость вызова ◊ic{lookup}) линейно зависит от длины списка.
◊footnote{
  К~счастью, статистика показывает,
  что переменные, располагающиеся ближе к~началу списка, используются чаще тех, что находятся глубоко внутри.
  Кстати, ещё стоит отметить, что лексические окружения в~среднем меньше по размеру, чем динамические,
  так как последним необходимо хранить все переменные, участвующие в~вычислениях, включая одноимённые ◊cite{bak92a}.
}
Такой подход называется ◊term{дальним связыванием} (◊english{deep binding}),
так как значения динамических переменных обычно располагаются на некотором удалении от текущего локального окружения.

◊indexR{ближнее связывание}
◊indexR{связывание!ближнее}
◊indexE{Cval}
Существует и другой способ, называемый ◊term{ближним связыванием} (◊english{shallow binding}).
Суть его в~том, что переменная напрямую связана с~местом, где хранится её значение в~текущий момент, независимо от окружения.
Проще всего это реализовать, расположив значение переменной в~специальном поле символа с~именем переменной;
это поле называют ◊ic{Cval} или ◊term{ячейкой значения} (◊english{value cell}).
В~таком случае стоимость ◊ic{lookup} более-менее постоянна:
требуется лишь одна косвенная адресация и, может быть, сдвиг.
Так как бесплатный сыр бывает только в~мышеловке,
стоит отметить, что вызовы функций при использовании этого метода выходят дороже,
потому как сначала требуется где-то сохранить текущие значения аргументов,
затем записать новые значения в~поля соответствующих символов.
А~потом, что самое важное, после выхода из функции предыдущие значения в~символах необходимо восстановить обратно,
что может помешать оптимизации хвостовой рекурсии.
(Не~обязательно:~◊cite{sj93}.)

Изменив структуру окружений, мы можем частично проэмулировать
◊footnote{
  Мы не~поддерживаем присваивание переменным, которые захвачены замыканиями.
  Об~этом можно почитать в~◊cite{bcsj86}.
}
ближнее связывание.
Но с~оговорками: список аргументов не~может быть точечным (так будет легче его разбирать)
и~мы не~будем проверять арность функций.
Новые функции обозначим префиксом~◊ic{s.}, чтобы не~путать их с~другими.

◊indexC{s.make-function}
◊indexC{s.lookup}
◊indexC{s.update!}
◊code:lisp{
(define (s.make-function variables body env)
  (lambda (values current.env)
    (let ((old-bindings
           (map (lambda (var val)
                  (let ((old-value (getprop var 'apval)))
                    (putprop var 'apval val)
                    (cons var old-value) ) )
                variables
                values ) ))
      (let ((result (eprogn body current.env)))
        (for-each (lambda (b) (putprop (car b) 'apval (cdr b)))
                  old-bindings )
        result ) ) ) )

(define (s.lookup id env)
  (getprop id 'apval) )

(define (s.update! id env value)
  (putprop id 'apval value) )
}

◊indexC{putprop}
◊indexC{getprop}
Функции ◊ic{putprop} и ◊ic{getprop} не~входят в~стандарт Scheme,
так как здесь не~любят неэффективные глобальные побочные эффекты,
но~тем не~менее, даже в~◊cite{as85} используются аналогичные ◊ic{put} и~◊ic{get}.
◊seeEx{lisp1-2-omega/ex:write-put/get-prop}

◊indexR{списки свойств}
◊indexR{символы!списки свойств}
◊indexE{P-список}
◊indexR{хеш-таблицы}
С~помощью этих функций мы эмулируем наличие у~символов поля,
◊footnote{
  Это поле названо в~честь ◊ic{apval} из~◊cite{mae+62}.
  ◊; TODO: эта ссылка куда-то протерялась в HTML
  ◊seePage{lisp1-2-omega/par:apval}
  Тогда значения полей действительно хранились в~наивных P-списках.
}
где хранится значение одноимённой переменной.
Независимо от их настоящей реализации,
◊footnote{
  Эти функции обычно проходят по списку свойств символа (его P-списку, от~◊english{property})
  до тех пор, пока не~найдут нужное.
  Скорость поиска, соответственно, линейно зависит от длины списка,
  если только не~применяются хеш-таблицы.
}
будем считать, что они выполняются за постоянное время.

Заметьте, что в~нашей реализации сейчас абсолютно не~используется окружение определения~◊ic{env}.
Поэтому для поддержки замыканий нам потребуется изменить реализацию ◊ic{make-closure},
так как она теперь не~имеет доступа к~окружению определения (ввиду его отсутствия).
При создании замыкания необходимо просмотреть тело функции, выделить все свободные переменные и правильно их сохранить внутри замыкания.
Мы~реализуем всё это~позже.

◊indexE{rerooting}
Дальнее связывание облегчает смену окружений и многозадачность, теряя в~скорости поиска переменных.
Ближнее связывание ускоряет поиск переменных, но теряет в~скорости вызова функций.
Генри~Бейкеру ◊cite{bak78} удалось объединить эти два подхода в~технику под названием ◊english{◊term{rerooting}}.

Наконец, не~забывайте, что ближнее и дальнее связывание — это лишь способы реализации,
они никак не~влияют на семантику переменных.
