#lang pollen

◊subsection*{Окружение исполнения~функций}

◊indexR{окружение!исполнения тела функции}
Исполнение функции сводится к~вычислению выражений, составляющих её тело,
в~окружении, где аргументы функции связаны со~значениями, переданными при вызове функции.
Вспомните, что ◊ic{evaluate} передаёт ◊ic{make-function} и ◊ic{invoke} всё необходимое для~вычислений.

Окружения, используемые при вычислениях, будут выделены~◊ii{курсивом}.


◊subsubsection{Минимальное окружение}

Для начала рассмотрим минимально возможное окружение:

◊indexC{make-function}
◊code:lisp{
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend ◊ii{env.init} variables values)) ) )
}

◊indexE{K@◊comb{K}, комбинатор}
◊indexR{комбинаторы!K@◊comb{K}}
В~строгом соответствии с~определением,
тело функции вычисляется в~окружении, где аргументы функции связаны с~переданными значениями.
Возьмём, например, комбинатор~◊comb{K}, определяемый как ◊ic{(lambda~(a~b)~a)}:

◊code:lisp{
(K 1 2) ◊(is) 1
}

Несмотря на определённый успех, есть и плохие новости:
функции могут использовать только свои аргументы и локальные переменные,
ведь мы определили ◊ii{env.init} как пустое окружение.
В~нём нет даже базовых функций из глобального окружения вроде ◊ic{car} или~◊ic{cons}.


◊subsubsection{Улучшенное окружение}

Хорошо, попробуем улучшить наше определение следующим~образом:

◊code:lisp{
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend ◊ii{env.global} variables values)) ) )
}

Замечательно, теперь наши функции имеют доступ к~глобальному окружению и всем его функциям.
А~что если мы попробуем определить взаимно рекурсивные функции?
Также, какой результат даст программа слева?
(Справа она~же с~раскрытыми макросами.)

◊; TODO: таблица

◊code:lisp{
(let ((a 1))
  (let ((b (+ 2 a)))
    (list a b) ) )
}

◊(is)

◊code:lisp{
((lambda (a)
   ((lambda (b)
      (list a b) )
    (+ 2 a) ) )
 1 )
}

Давайте рассмотрим по шагам, как вычисляется это~выражение:

◊code:lisp{
((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)◊where{
                                                  | ◊ii{env.global}
                                                  }
◊(eq) ((lambda (b) (list a b)) (+ 2 a))◊where{
                                       | a ◊(is) 1
                                       | ◊ii{env.global}
                                       }
◊(eq) (list a b)◊where{
                | b ◊(is) 3
                | ◊ii{env.global}
                }
}

Тело внутренней функции ◊ic{(lambda~(b) (list~a~b))} выполняется в~окружении,
полученном расширением глобального окружения переменной~◊ic{b}.
Всё верно.
Но~в~этом окружении нет необходимой переменной~◊ic{a}!


◊subsubsection{Улучшенное окружение (вторая~попытка)}

Так как нам надо видеть переменную~◊ic{a} во~внутренней функции,
то~достаточно будет передать ◊ic{invoke} текущее окружение,
а~она в~свою очередь передаст его вызываемой функции.
Для реализации этой идеи потребуется немного подправить ◊ic{evaluate} и~◊ic{invoke}.
Чтобы не~путать эти определения с~предыдущими, пусть они начинаются на~◊ic{d.}:

◊indexC{d.evaluate}
◊indexC{d.invoke}
◊indexC{d.make-function}
◊code:lisp{
(define (d.evaluate e ◊ii{env})
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (d.make-function (cadr e) (cddr e) ◊ii{env}))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )

(define (d.make-function variables body ◊ii{def.env})
  (lambda (values ◊ii{current.env})
    (eprogn body (extend ◊ii{current.env} variables values)) ) )
}

Здесь стоит отметить,
что передача окружения определения ◊ic{env} через переменную~◊ii{def.env} бессмысленна,
так~как при вызове используется лишь текущее окружение ◊ii{current.env}.

◊indexR{стек!вызовов}
Теперь рассмотрим наш пример ещё~раз.
Сейчас переменные не~пропадают:

◊code:lisp{
((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)◊where{
                                                  | ◊ii{env.global}
                                                  }
◊(eq) ((lambda (b) (list a b)) (+ 2 a))◊where{
                                       | a ◊(is) 1
                                       | ◊ii{env.global}
                                       }
◊(eq) (list a b)◊where{
                | b ◊(is) 3
                | a ◊(is) 1
                | ◊ii{env.global}
                }
}

Заодно мы явно видим ◊term{стек вызовов}:
каждая связывающая форма сначала укладывает свои новые переменные поверх текущего окружения,
а~затем убирает их оттуда после окончания вычислений.


◊subsubsection{Исправляем проблему}

Но~даже при таком определении всё ещё остаются проблемы.
Рассмотрим следующий пример:

◊code:lisp{
(((lambda (a)
    (lambda (b) (list a b)) )
  1 )
 2 )
}

Функция~◊ic{(lambda~(b) (list~a~b))} создаётся в~окружении,
где~◊ic{a}~связана со~значением~◊ic{1},
но~в~момент вызова в~окружении будет присутствовать только~◊ic{b}.
Таким образом, мы опять потеряли переменную~◊ic{a}.

Внимательный читатель заметил, что в~определении ◊ic{d.make-function} присутствуют два~окружения:
окружение определения ◊ii{def.env} и окружение исполнения ◊ii{current.env}.
В~жизни функции существуют два важных события: её~создание и её~вызов(ы).
Очевидно, что создаётся функция только однажды, а~вызываться может несколько раз;
или вообще никогда не~вызываться.
Следовательно, единственное
◊footnote{
  На~самом деле, здесь можно использовать любое необходимое окружение.
  См.~про~форму~◊ic{closure} на~странице~◊pageref{assignement/assignement/para:closure}.
}
окружение, которое мы однозначно можем связать с~функцией, — это окружение, в~котором она была создана.
Вернёмся к~исходным определениям функций ◊ic{evaluate} и ◊ic{invoke},
но~в~этот раз функцию~◊ic{make-function} запишем следующим~образом:

◊indexC{make-function}
◊code:lisp[#:label "basics/representing-functions/fixing/src:inject-current-env" #:chunk "make-function"]{
(define (make-function variables body ◊ii{env})
  (lambda (values)
    (eprogn body (extend ◊ii{env} variables values)) ) )
}

Теперь все приведённые примеры работают ожидаемо.
В~частности, последний пример вычисляется следующим образом:

◊code:lisp{
(((lambda (a) (lambda (b) (list a b))) 1) 2)|◊where{
                                             | ◊ii{env.global}
                                             }
◊(eq) ((lambda (b) (list a b))◊where{
                              | a ◊(is) 1
                              | ◊ii{env.global}
                              }
    2 )◊where{
       | ◊ii{env.global}
       }
◊(eq) (list a b)◊where{
                | b ◊(is) 2
                | a ◊(is) 1
                | ◊ii{env.global}
                }
}

◊indexR{абстракция!замыкание}
◊indexR{абстракция!значение}
◊indexR{возвращаемые значения!абстракций}
◊indexR{замыкания}
Форма ◊ic{(lambda~(b) (list~a~b))} создаётся в~глобальном окружении, расширенном переменной~◊ic{a}.
Когда эта функция вызывается, она расширяет окружение своего создания переменной~◊ic{b}:
таким образом, тело функции будет вычисляться в~окружении, где обе переменные ◊ic{a} и~◊ic{b} присутствуют.
После того, как функция вернёт результат, исполнение продолжается в~глобальном окружении.
Такое определение абстракции называется ◊term{замыканием} (◊english{closure}),
потому что тело функции становится замкнутым в~окружении своего определения.

Стоит отметить, что сейчас ◊ic{make-function} сама использует замыкания языка реализации.
Это не~является обязательным, как мы покажем далее в~третьей~главе.
◊seePage{escape/actors/ssect:functions}
Функция~◊ic{make-function} возвращает замыкания —
характерная черта функциональных языков программирования вроде~Scheme.
