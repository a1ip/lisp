#lang pollen

◊section[#:label "basics/sect:global-environment"]{Глобальное окружение}

◊indexR{библиотека!функций}
◊indexR{Лисп!примитивы}
Пустое глобальное окружение — это печально,
поэтому большинство лисп-систем предоставляют ◊term{библиотеки} функций.
Например, в~глобальном окружении ◊(CommonLisp) (CLtL1) около 700~функций,
у~◊(LeLisp) их более~1500,
у~◊(ZetaLisp) — более~10◊(thinsp)000.
Без библиотек Лисп был~бы лишь прикладным ◊${\lambda}-исчислением,
в~котором нельзя даже распечатать полученные результаты.
Библиотеки очень важны для конечного пользователя.
Специальные формы — это строительные кирпичики для разработчиков интерпретаторов,
но для конечного пользователя такими кирпичиками являются функции библиотек.
По-видимому, именно отсутствие в~чистом Лиспе таких банальных вещей вроде библиотеки тригонометрических функций
прочно укоренило мысль о~непригодности Лиспа для «серьёзных программ».
Как говорится в~◊cite{sla61}, возможность символьного интегрирования или дифференцирования —
это, конечно, замечательно, но кому нужен язык, где нет даже синуса или тангенса?

Мы ожидаем, что все привычные функции вроде ◊ic{cons}, ◊ic{car}, и~т.~д. будут доступны в~глобальном окружении.
Также можно определить несколько простых констант вроде логических значений и пустого~списка.

Давайте определим пару макросов.
Исключительно для нашего удобства, потому что об~их~семантике мы ещё даже не~говорили.
◊footnote{Согласитесь, было~бы странным втискивать всю книгу в~первую главу.}
Макросы — это довольно сложная и важная вещь сами по себе, так что им посвящена собственная глава.
◊seePage{chapter:macros}

Макросы существенно облегчат наполнение глобального окружения.
Само глобальное окружение~◊ic{env.global} является расширением начального окружения~◊ic{env.init}.

◊indexC{env.global}
◊indexC{definitial}
◊indexC{defprimitive}
◊code:lisp[#:chunk "definitial"]{
(define env.global env.init)

(define-syntax definitial
  (syntax-rules ()
    ((definitial name)
     (begin (set! env.global (cons (cons 'name 'void) env.global))
            'name ) )
    ((definitial name value)
     (begin (set! env.global (cons (cons 'name value) env.global))
            'name ) ) ) )

(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial name
       (lambda (values)
         (if (= arity (length values))
             (apply value values)     ; Родная функция apply из Scheme
             (wrong "Incorrect arity" (list 'name values)) ) ) ) ) ) )
}

◊indexC{the-false-value}
Несмотря на то, что стандарт Scheme этого не~требует, мы определим несколько полезных констант.
Заметим, что ◊ic{t} — это переменная в~определяемом нами Лиспе, а~◊ic{#t} — это значение из Лиспа, используемого для реализации.
Оно подходит, так как любое значение, не~совпадающее с~◊ic{the-false-value}, считается~◊term{истиной}.

◊code:lisp[#:chunk "boolean-constants"]{
(definitial t #t)
(definitial f the-false-value)
(definitial nil '())
}

◊indexR{синтаксис!для ◊ic{#t} и~◊ic{#f}}
◊indexR{логические значения}
Хотя это и по-своему удобно — иметь глобальные переменные с~настоящими объектами для данных сущностей,
но есть и другое решение: особый синтаксис.
Например, Scheme использует ◊ic{#t} и ◊ic{#f}, подставляя вместо них логические ◊term{истину} и~◊term{ложь}.
В~этом тоже есть определённый смысл:

◊itemize{
  ◊item{
    Отсутствие конфликтов имён:
    ◊ic{#t} означает ◊term{истину} в~любом контексте,
    даже тогда, когда локальная переменная названа~◊ic{t}.
  }
  ◊item{
    Значение~◊ic{#t} невозможно изменить,
    но многие интерпретаторы позволят изменить значение глобальной переменной~◊ic{t}.
  }
}

Например, выражение~◊ic{(if~t~1~2)} вернёт~◊ic{2},
если оно вычисляется в~следующем окружении: ◊ic{(let ((t~#f)) (if~t~1~2))}.

◊indexC{eq?}
Существует много способов ввести такой синтаксис.
Наиболее простой из~них — это вшить значения ◊ic{t} и~◊ic{f} в~вычислитель:

◊code:lisp{
(define (evaluate e env)
  (if (atom? e)
      (cond ((eq? e 't) #t)
            ((eq? e 'f) #f)
            ...
            ((symbol? e) (lookup e env))
            ...
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )
}

◊indexR{инлайнинг!функций}
◊indexR{встраивание!функций}
◊indexR{функции!встраиваемые}
◊indexR{связывание!изменяемое}
◊indexR{связывание!неизменяемое}
Также мы могли~бы ввести понятия ◊term{изменяемого} и ◊term{неизменяемого} связывания.
Неизменяемым переменным нельзя присваивать новые значения.
Ничто и никогда не~сможет изменить значение неизменяемой переменной после её определения.
Такая концепция существует, хоть и не~всегда явно, во~многих системах.
Например, существуют так называемые ◊term{инлайн-функции}
(также известные как ◊term{подставляемые} или ◊term{встраиваемые}),
вызов которых можно полностью заменить прямой подстановкой их тела.
◊seePage{fast/fast/integrating/par:inlining}

Чтобы можно было спокойно подставить вместо ◊ic{(car~x)} код функции,
возвращающей левый элемент точечной пары~◊ic{x},
необходимо быть абсолютно уверенным в~том,
что значение глобальной переменной~◊ic{car} никогда не~менялось и не~поменяется в~будущем.
Рассмотрим следующую программу:

◊code:lisp{
(set! my-global (cons 'c 'd))
   ◊(is) (c . d)

(set! my-test (lambda () (car my-global)))
   ◊(is) #<MY-TEST procedure>

(begin (set! car cdr)
       (set! my-global (cons 'a 'b))
       (my-test) )
   ◊(is) ◊ii{?????}
}

К~счастью, поведение этой программы не~совсем уж неопределённое.
В~результате может получиться только ◊ic{a} или~◊ic{b}.
Если ◊ic{my-test} использует значение~◊ic{car} на~момент определения, то мы получим~◊ic{a}.
Если~же ◊ic{my-test} будет использовать текущее значение~◊ic{car}, то ответом будет~◊ic{b}.
Обратите внимание на разницу в~ожиданиях между ◊ic{my-test} и ◊ic{my-global}:
при использовании компилятора, от функций вроде ◊ic{my-test} ожидается первый вариант — сохранение изначального определения,
тогда как от переменных вроде ◊ic{my-global} всегда ожидается доступ к~их текущему значению.
◊seePage{lisp1-2-omega/recusion/simple/code:redefine}

◊indexC{foo}
◊indexC{bar}
◊indexC{fib}
◊indexC{fact}
Добавим ещё несколько рабочих переменных
◊footnote{К~сожалению, сейчас они ещё и инициализируются. Эта ошибка будет исправлена позже.}
в~глобальное окружение — просто сейчас у~нас нет иного способа создавать глобальные переменные.
По статистике, предлагаемые имена составляют приблизительно ◊nobr{96,7549◊(thinsp)%} используемых при тестировании свеженаписанных интерпретаторов.

◊code:lisp[#:chunk "globals"]{
(definitial foo)
(definitial bar)
(definitial fib)
(definitial fact)
}

Наконец, определим несколько примитивных функций
(здесь показаны не~все, потому что мне платят не~за~килобайты текста).
Главная сложность состоит в~том, чтобы подружить механизмы вызова функций языка реализации и определяемого языка.
Мы знаем, что наш интерпретатор собирает аргументы в~список, так что достаточно просто вызвать ◊ic{apply}.
◊footnote{Можно только порадоваться за наш выбор не~называть ◊ic{invoke} «◊ic{apply}».}
Заметьте, что арность функций будет соблюдаться,
так как мы включили проверку в~определение макроса~◊ic{defprimitive}.

◊code:lisp[#:chunk "primitives"]{
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive set-cdr! set-cdr! 2)
(defprimitive + + 2)
(defprimitive eq? eq? 2)
(defprimitive < < 2)
}
