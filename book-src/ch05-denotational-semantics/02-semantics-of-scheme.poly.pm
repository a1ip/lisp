#lang pollen

◊section[#:label "denotational/sect:semantics"]{Семантика Scheme}

◊indexC{evaluate}
По~результатам демократических обсуждений, представителем денотаций было избрано ◊${\lambda}-исчисление.
Предыдущий интерпретатор написан на Scheme без побочных эффектов.
Его сердце — это функция-вычислитель ◊ic{evaluate}, которая имеет следующий~тип:

◊$${
◊text{◊ic{evaluate}:} \quad ◊Vset{Программа} \times ◊Vset{Окружение} \times ◊Vset{Продолжение} \times ◊Vset{Память} \to ◊Vset{Значение}
}

Первый аргумент — программу — можно легко каррировать, получая

◊$${
◊Vset{Программа} \to (◊Vset{Окружение} \times ◊Vset{Продолжение} \times ◊Vset{Память} \to ◊Vset{Значение})
}

◊indexR{контекст вычислений}
◊indexR{вычисления!контекст}
◊indexR{Денотация@◊Vset{Денотация}}
Каждая программа превращается в~функцию, которая по~окружению, продолжению и~памяти (вместе они называются ◊term{контекстом вычислений})
определяет возвращаемое значение.
Это~похоже на понятие смысла программы, так~что остановимся на таком определении:

◊; TODO: когда "\colon", а когда ":"? у тебя разнобой
◊$${
\begin{align*}
◊text{◊ii{интерпретация}}\colon & \quad ◊Vset{Программа} \to ◊Vset{Денотация} \\
         ◊Vset{Денотация}\colon & \quad ◊Vset{Окружение} \times ◊Vset{Продолжение} \times ◊Vset{Память} \to ◊Vset{Значение} \\
\end{align*}
}

◊indexR{соглашения именования!в~денотациях}
Адепты денотационной семантики не~особо любят скобочки, а~также имеют своеобразные и строгие предпочтения в~наименовании сущностей.
Прежде всего, следует использовать как можно больше разнообразных греческих букв, но~как можно меньше в~каждом отдельном утверждении.
В~итоге, для непосвящённых записи выглядят загадочным набором иероглифов.
Причиной таких привычек служит~то, что
после нескольких лет тренировок семантика исследуемого языка умещается всего на одной-единственной странице — кр.~с.~т.
Подобное преимущество
◊footnote{
  Учтите, что средний размер научной публикации — около десяти страниц.
  Представляете, насколько больше полезной информации можно сообщить!
}
недостижимо, если использовать пространные названия и лишние символы.
Греческие~же буквы выбраны для того, чтобы не~путать денотации с~выражениями определяемого языка.
Так~как чаще всего денотационная семантика используется для определения языков программирования, алфавит которых ограничен~◊sc{ASCII},
◊; TODO: красивая капитель
то~греческие буквы являются хорошим выбором: они компактные и выделяющиеся.
Наконец, для уменьшения количества ошибок денотации являются типизированными —
типы выражений выводятся из имён переменных.

◊; TODO: ты можешь вспомнить нафига здесь пробелы?
◊indexR{а льфа@◊${◊a} (адреса)}
◊indexR{э псилон@◊${◊e} (значения)}
◊indexR{р о@◊${◊r} (окружение)}
◊indexR{с игма@◊${◊s} (память)}
◊indexR{н ю@◊${◊n} (переменные)}
◊indexR{п и@◊${◊p} (программы)}
◊indexR{к аппа@◊${◊k} (продолжения)}
◊indexR{ф и@◊${◊f} (функции)}
◊indexE{a lpha@◊${◊a} (адреса)}
◊indexE{e psilon@◊${◊e} (значения)}
◊indexE{r ho@◊${◊r} (окружение)}
◊indexE{s igma@◊${◊s} (память)}
◊indexE{n u@◊${◊n} (переменные)}
◊indexE{p i@◊${◊p} (программы)}
◊indexE{k appa@◊${◊k} (продолжения)}
◊indexE{p hi@◊${◊f} (функции)}
Со~своей стороны, мы~также будем следовать сложившимся канонам.
По~давней традиции функции обозначаются буквой~◊${◊f}.
Остальные сущности обычно именуют по~первой букве их английского названия:
◊${◊k}~для продолжений,
◊${◊a}~для адресов,
◊${◊n}~для идентификаторов (◊english{name}),
◊${◊p}~для программ,
◊${◊s}~для памяти (◊english{store}).
Попробуйте самостоятельно догадаться, почему окружения обозначаются буквой~◊${◊r}.

◊; TODO: красивная табличка с линейкой
◊table{
  ◊tr{◊td{◊${◊p}} ◊td{◊${◊Vset{Программы}}}   ◊td{◊${◊r}} ◊td{◊${◊Vset{Окружения}}}}
  ◊tr{◊td{◊${◊n}} ◊td{◊${◊Vset{Переменные}}}  ◊td{◊${◊a}} ◊td{◊${◊Vset{Адреса}}}   }
  ◊tr{◊td{◊${◊s}} ◊td{◊${◊Vset{Память}}}      ◊td{◊${◊e}} ◊td{◊${◊Vset{Значения}}} }
  ◊tr{◊td{◊${◊k}} ◊td{◊${◊Vset{Продолжения}}} ◊td{◊${◊f}} ◊td{◊${◊Vset{Функции}}}  }
}

◊indexR{домены}
◊indexR{Программы@◊${◊Vset{Программы}}}
◊indexR{Окружения@◊${◊Vset{Окружения}}}
◊indexR{Переменные@◊${◊Vset{Переменные}}}
◊indexR{Адреса@◊${◊Vset{Адреса}}}
◊indexR{Память@◊${◊Vset{Память}}}
◊indexR{Значения@◊${◊Vset{Значения}}}
◊indexR{Продолжения@◊${◊Vset{Продолжения}}}
◊indexR{Функции@◊${◊Vset{Функции}}}
Каждое слово, набранное жирным шрифтом, соответствует ◊term{домену} объектов.
Здесь присутствуют все классы объектов, которые мы рассматривали в~предыдущих главах.

◊; TODO: красивая формула; я не буду писать больше TODO, это относится ко всем ◊$$ здесь, хорошо?
◊$${
\begin{align*}
  ◊Vset{Окружение} & = ◊Vset{Переменная} \to ◊Vset{Адрес}                       \\
     ◊Vset{Память} & = ◊Vset{Адрес} \to ◊Vset{Значение}                         \\
   ◊Vset{Значения} & = ◊Vset{Функции} + ◊Vset{Числа} + ◊Vset{Пары} + \cdots     \\
◊Vset{Продолжение} & = ◊Vset{Значение} \times ◊Vset{Память} \to ◊Vset{Значение} \\
    ◊Vset{Функция} & = ◊Vset{Значения}^* \times ◊Vset{Продолжение} \times ◊Vset{Память} \to ◊Vset{Значение} \\
\end{align*}
}

◊indexR{приведение типов}
◊indexR{инъекция, ◊${◊Inj{Домен}(x)}}
◊indexR{проекция, ◊${x◊Prj{Домен}}}
◊indexE{-injection@◊${◊Inj{Домен}(x)} (инъекция)}
◊indexE{-projection@◊${x ◊Prj{Домен}} (проекция)}
Как~обычно, звёздочка означает список.
Например, домен~◊${◊Vset{Значения}^*} — это~домен последовательностей ◊${◊Vset{Значений}}.
Символ~◊${\times} означает декартово произведение.
Символ~◊${+} означает дизъюнктивную сумму;
то~есть ◊${◊Vset{Значение}} — это~или~◊${◊Vset{Функция}}, или~◊${◊Vset{Число}}, или~◊${◊Vset{Пара}}, и~т.~д.
Важное свойство дизъюнктивной суммы:
каждый элемент домена~◊${◊Vset{Значений}} принадлежит одному и~только одному из доменов, составляющих дизъюнктивную сумму.
Так~как мы считаем сущности типизированными, то~необходимо чётко обозначать переходы между доменами.
Инъекция ◊${◊Inj{Значение}(◊e)} переносит терм~◊${◊e} в~домен~◊${◊Vset{Значений}},
а~проекция ◊${◊e ◊Prj{Числа}} отображает значение~◊${◊e} на~домен~◊${◊Vset{Чисел}}
(конечно~же, если~◊${◊e} ему действительно принадлежит).

◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!математическая модель}
Домены определяются рекурсивно — это важно с~математической точки~зрения;
именно по~этой и некоторым другим причинам они называются ◊term{доменами},
а~не~просто множествами.
Не~особо углубляясь в~детали, скажем, что ◊${\lambda}-исчисление было разработано Алонзо~Чёрчем в~1930-х~годах,
однако~ему не~хватало строгой математической модели — которая была построена Даной~Скоттом около 1970~года.
◊${\lambda}-исчисление ещё тогда доказало свою полезность, но~с~математической моделью оно стало идеальным.
Со~временем были разработаны и другие модели: ◊${D_\infty}, ◊${\mathcal{P}\omega}.
◊seeCite{sco76,sto77}

◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!экстенсиональность}
◊indexR{эта-редукция@◊${\eta}-редукция}
◊indexR{экстенсиональность}
◊term{Экстенcиональность} это свойство функций:
◊${\forall x \colon \big(f(x) = g(x)\big) \Rightarrow (f = g)},
которое связано с~◊${\eta}-редукцией — одним из вспомогательных правил ◊${\lambda}-исчисления:

◊$${
  ◊text{◊${\eta}-редукция:}
      \quad \lambda x . (M\ x) \to*{\eta} M
      \quad ◊text{где ◊${x} не~свободна в~◊${M}}
}

Удивительно, но~существуют как экстенсиональные математические модели вроде ◊${D_\infty},
так~и~нет: например, ◊${\mathcal{P}\omega} не~экстенсиональна.
Интересно, экстенсионален~ли наш~мир?

Дана~Скотт показал, что любая формальная система, которая рекурсивно определяется через домены
используя лишь ◊${\to}, ◊${\times}, ◊${+}~и~◊${{}^*}, является алгоритмически разрешимой:
то~есть истинность любого корректного утверждения в~ней можно доказать или опровергнуть за конечное число~шагов.

◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!композициональность}
◊indexR{композициональность!лямбда-исчисления@◊${\lambda}-исчисления}
Ещё~один важный принцип денотационной семантики — это~◊term{композициональность}:
смысл фрагмента программы зависит только от смысла составляющих его частей.
Композициональность очень важна для индуктивного метода доказательства и~не~только:
это~удобно для реализации, когда программы не~зависят от~контекста.

◊; TODO: для скобочек должен быть какой-то макрос, да?
◊indexE{[]@◊${[\![}\quad◊${]\!]} (семантические скобки)}
◊indexE{E-@◊${◊Eval}, интерпретатор}
◊indexR{интерпретатор!E@◊${◊Eval}}
Функцию-интерпретатор обычно обозначают~◊${◊Eval}.
Чтобы отличать программы от их~семантики,
фрагменты программ мы будем заключать в~семантические скобки: ◊${[\![}~и~◊${]\!]}.
Теперь мы наконец-то перейдём к~разбору форм одна за другой.
