#lang pollen

◊subsection[#:label "denotational/semantics/ssect:abstraction"]{Абстракция}

Для начала рассмотрим лишь случай функций фиксированной арности,
то~есть без точечных переменных.

◊; TODO: как превратить inValue в ◊Inj{Значение}?
◊code:denotation{
(define ((meaning-abstraction n* e+) r k s)
  (k (inValue (lambda (v* k1 s1)
                (if (= (length v*) (length n*))
                    (allocate s1 (length n*)
                              (lambda (s2 a*)
                                ((meaning*-sequence e+)
                                 (extend* r n* a*)
                                 k1
                                 (extend* s2 a* v*) ) ) )
                    (wrong "Incorrect arity") ) ))
     s ) )
}

Инъекция ◊${◊Inj{Значение}(\ldots)} принимает ◊${\lambda}-терм, представляющий функцию, и~превращает его в~значение языка.
Последующая аппликация функции выполнит обратное преобразование.

◊; TODO: ◊ii{allocate} или какой-нибудь ◊${◊fn{allocate}}? что ты делаешь в других местах?
◊indexE{allocate@◊ii{allocate}}
Вызванная функция сперва проверят фактическую арность,
затем выделяет место в~памяти под свои аргументы и~связывает переменные со~значениями,
после чего последовательно вычисляет формы, составляющие её тело.
Выделением памяти занимается функция ◊ii{allocate},
которая принимает память, необходимое количество адресов,
и~«продолжение», которому передаётся список выделенных адресов вместе с~новым состоянием памяти.
◊ii{allocate} — это чистая функция:
эквивалентные аргументы приводят к~эквивалентному результату.
Её~определение довольно рутинно,
так~что здесь мы его опустим, чтобы не~перегружать выкладки.
(Интересующиеся могут переписать реализацию ◊ii{allocate} из предыдущей~главы.◊seePage{assignment/implementation/ssect:memory})

Функция ◊ii{allocate} имеет следующий полиморфный тип, где~◊${\alpha}~соответствует любому типу данных:

◊$${
  ◊Vset{Память} \times ◊Vset{НатуральноеЧисло} \times (◊Vset{Память} \times ◊Vset{Адреса}^* \to \alpha) \to \alpha
}
