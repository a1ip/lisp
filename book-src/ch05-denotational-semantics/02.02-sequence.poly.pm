#lang pollen

◊subsection[#:label "denotational/semantics/ssect:sequence"]{Последовательность}

◊indexR{интерпретатор!E-plus@◊${◊|Eval|^+}}
◊indexE{E-plus@◊${◊|Eval|^+}, интерпретатор}
Денотация последовательных вычислений как обычно использует вспомогательную функцию,
которой в~предыдущих интерпретаторах соответствует функция~◊ic{eprogn}.
Мы~будем обозначать~её~◊${◊|Eval|^+} — с~плюсом,
потому что в~форме ◊ic{begin} должен присутствовать хотя~бы один элемент.
Аналогично будем обозначать непустую последовательность форм:~◊${◊|p|^+}.
Интерпретатор~◊${◊|Eval|^+} трактует ◊${◊|p|^+} как денотацию,
которая вычисляет все элементы слева направо и возвращает значение последнего из~них.
Интерпретатор необходимо рассмотреть два~случая: когда~◊${◊|p|^+} состоит из одной или нескольких~форм.
В~Scheme смысл ◊ic{(begin)} не~определён, поэтому и~здесь такого случая попросту нет в~определении.

◊; TODO: ох будет весело тебе писать конвертер
◊code:denotation{
(define ((meaning-sequence e+) r k s)
  ((meaning*-sequence e+) r k s) )

(define (meaning*-sequence e+)
  (if (pair? e+)
      (if (pair? (cdr e+))
          (meaning*-multiple-sequence (car e+) (cdr e+))
          (meaning*-single-sequence (car e+)) )
      (wrong "Illegal syntax") ) )

(define ((meaning*-single-sequence e) r k s)
  ((meaning e) r k s) )

(define ((meaning*-multiple-sequence e e+) r k s)
  ((meaning e) r
               (lambda (v s1)
                 ((meaning*-sequence e+) r k s1) )
               s ) )
}

◊; TODO: упращение? не редукция?
◊indexR{эта-упрощение@◊${\eta}-упрощение}
Если последовательность состоит из одного элемента, то~она эквивалентна данному элементу.
Можно было~бы записать это буквально:

◊; TODO: поразительно весело
◊code:denotation{
(define ((meaning*-single-sequence e) . args)
  (apply (meaning e) args) )
}

◊noindent
В~◊${\lambda}-исчислении подобный приём называется ◊${\eta}-упрощением.
Мы~будем избегать таких фокусов, потому что они затрудняют понимание программ,
а~также скрывают естественную арность функций.
Как~говорят~◊cite{wl93}, часто так пишут только чтобы выглядеть умнее.

Если последовательность состоит из более чем одного элемента,
то~вычисляется значение первого из них и~управление передаётся продолжению,
которое вычислит все остальные.
Тут — в~одной строке! — ещё~раз можно увидеть, что продолжение игнорирует вычисленное ранее значение,
но~не~состояние памяти после его вычисления.
В~конечном итоге именно продолжения упорядочивают вычисления,
передавая память по~цепочке.
