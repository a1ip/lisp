#lang pollen

◊subsection[#:label "denotational/semantics/ssect:assign"]{Присваивание}

Денотация присваивания записывается просто.
Приведённая здесь версия возвращает только что присвоенное значение.

◊code:denotation{
(define ((meaning-assignment n e) r k s)
  ((meaning e) r
               (lambda (v s1)
                 (k v (extend s1 (r n) v)) )
               s ) )

(define (extend f y z)
  (lambda (x) (if (equal? x y) z (f x))) )
}

◊indexE{->@◊${◊|s|[◊|a| \to ◊|e|]} (расширение окружения)}
Память расширяется, чтобы учесть новое значение~◊${◊e} по адресу переменной~◊${◊n}.
Мы~обозначаем такое расширение ◊${◊|s|[◊|a| \to ◊|e|]}.
Похожа нотация используется и~в~других работах:
◊${[◊|a| \to ◊|e|]◊|s|}~в~◊cite{sch86},
◊${[◊|e|/◊|a|]◊|s|}~в~◊cite{sto77},
или~даже ◊${◊|s|[◊|e|/◊|a|]}~в~◊cite{gor88,kcr98}.

◊; TODO: точное форматирование этих клёвых операторов: например, {под,над}строчные символы?
◊; ◊indexE{-e<>@◊${◊seq{◊e^*_1, ◊ldots, ◊e^*_n}} (последовательность)}
◊; ◊indexE{-eS@◊${◊e^*_1 ◊append ◊e^*_2} (конкатенация)}
◊; ◊indexE{-ea@◊${◊e^*◊car n} (денотационный ◊ic{car})}
◊; ◊indexE{-ed@◊${◊e^*◊cdr n} (денотационный ◊ic{cdr})}
◊; ◊indexE{-el@◊${#◊e^*} (длина последовательности)}
Давайте расширим ◊${\lambda}-исчисление несколькими вспомогательными функциями.
Последовательности будем записывать в~угловых скобках: ◊${\langle}~и~◊${\rangle}.
Конкатенацию последовательностей будем обозначать знаком~◊${◊d:append}.
Извлечение ◊${i}-го элемента последовательности будем обозначать ◊${\langle{◊|e|_1, ◊|e|_2, \dots, ◊|e|_n}\rangle ◊d:car{i}}
(получая~◊${◊|e|_i}).
Отбрасывание первых ◊${i}~элементов последовательности — ◊${\langle{◊|e|_1, ◊|e|_2, \dots, ◊|e|_n}\rangle ◊d:cdr{i}}
(получая~◊${\langle{◊|e|_{i+1}, \dots, ◊|e|_n}\rangle}).
Длина последовательности~◊${◊|e|^*} записывается~◊${◊d:length{◊|e|^*}}.
Все эти определения можно было~бы привести непосредственно в~виде ◊${\lambda}-термов,
но~это стало~бы чересчур серьёзным отступлением от~темы,
поэтому, ничуть не~умаляя достоверности повествования,
мы~сходу будем использовать ◊${{}◊d:car{1}},~◊${{}◊d:cdr{1}},~◊${◊d:length{}}~и~◊${◊d:append}
как~денотационные эквиваленты ◊ic{car},~◊ic{cdr},~◊ic{length} и~◊ic{append}.

◊; ◊indexE{->*@◊${◊s[◊a^* ◊to*{*} ◊e^*]} (расширение окружения списком)}
Теперь можно коротко записать расширение памяти списком переменных.
Предполагается, что ◊${y^*} и~◊${z^*} имеют равную~длину.

◊code:denotation{
(define (extend* f y* z*)
  (if (> (length y*) 0)
      (extend (extend* f (cdr y*) (cdr z*))
              (car y*) (car z*) )
      f ) )
}
