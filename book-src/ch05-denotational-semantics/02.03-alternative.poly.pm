#lang pollen

◊subsection[#:label "denotational/semantics/ssect:conditional"]{Ветвление}

◊indexE{T@◊${◊comb{T}}, комбинатор}
◊indexE{F@◊${◊comb{F}}, комбинатор}
◊indexR{комбинаторы}
◊indexR{комбинаторы!T@◊${◊comb{T}}}
◊indexR{комбинаторы!F@◊${◊comb{F}}}
◊indexR{логические значения!в лямбда-исчислении@в ◊${\lambda}-исчислении}
◊indexR{представление!логических значений!в лямбда-исчислении@в ◊${\lambda}-исчислении}
◊; TODO: ты точно хочешь писать "◊${\lambda}-исчисление", с формулой, или всё же "λ-исчисление", чтобы оно копипастилось? (везде в книге)
Денотация условного оператора довольно стандартна и не~представляет трудностей,
если~знать, как представить булевы значения с~помощью абстракций ◊${\lambda}-исчисления.
На~самом деле это не~так сложно: мы~определим их как комбинаторы —
функции без свободных переменных:

◊$${
◊comb{T} = \lambda xy.x
\quad \text{и} \quad
◊comb{F} = \lambda xy.y
}

◊indexE{IF@◊${◊gate{IF}} (логическая операция)}
Очевидно, эти функции принимают два аргумента и выбирают один из них в~качестве результата.
Чем-то напоминает логическую операцию ◊${◊gate{IF}}, определяемую уравнениями

◊$${
◊gate{IF}(◊math-ii{истина}, p, q) = p
\quad \text{и} \quad
◊gate{IF}(◊math-ii{ложь}, p, q) = q
}

Внимание: ◊${◊gate{IF}} совсем не~аналогична специальной форме ◊ic{if} в~Scheme.
В~определении выше ничего не~говорится о~порядке вычислений или выборе между ветками —
◊${◊gate{IF}}~это просто функция, выражающая отношение между величинами.
Её~можно определить с~помощью таблицы истинности или~же через логические операции:

◊$${
◊gate{IF}(c, p, q) = (\neg\, c \lor p) \land (c \lor q)
}

◊indexR{комбинаторы!IF@◊${◊comb{IF}}}
◊indexE{IF@◊${◊comb{IF}}, комбинатор}
Выбранное нами представление булевых значений позволяет легко перенести ◊${◊gate{IF}}
в~◊${\lambda}-исчисление в~виде комбинатора:

◊$${
◊comb{IF}\ c\ p\ q = (c\ p\ q)
}

Как~и~в~логике, здесь ничего не~говорится о~порядке вычислений,
только об~отношениях между тремя значениями.
Если понимать ◊${◊gate{IF}} как функцию,
то~она возвращает второй аргумент, если первый является истиной,
а~иначе значением функции становится третий аргумент.
Вслед~за~◊cite{fw84}, мы~будем называть такую функцию~◊ic{ef},
и~на~Scheme она записывается примерно следующим образом:

◊indexC{ef}
◊indexE{if@◊ic{if}|seealso{◊ic{ef}}}
◊code:lisp{
(define (ef v v1 v2)
  (v v1 v2) )
}

Для математической записи мы позаимствуем нотацию из~◊cite{sch86}:

◊; TODO: потом придумаешь как генератор будет различать все эти if, окей?
◊; TODO: осло, v1, v2, v3? виды эпсилона? доебись до типографики здесь
◊code:denotation{
(ef e1 e2 e3)
}

◊noindent
Тогда как ◊R5RS использует чуть менее читаемую форму:

◊code:denotation{
(ef e1 e2 e3)
}

Держа всё это в~уме, определим денотацию условного оператора:

◊code:denotation{
(define ((meaning-alternative e1 e2 e3) r k s)
  ((meaning e1) r
                (lambda (v s1)
                  (ef (boolify v)
                      ((meaning e2) r k s1)
                      ((meaning e3) r k s1) ) )
                s ) )
}

◊indexE{boolify@◊${◊fn{boolify}}}
◊indexR{порядок вычислений!в лямбда-исчислении@в ◊${\lambda}-исчислении}
Функция ◊${◊fn{boolify}} сперва приводит значение к~булевому типу,
так~как в~Scheme любое значение, кроме~◊ic{#f}, считается истиной.
Условный оператор начинает работу с~вычисления условия, используя продолжение, которое затем выбирает соответствующую ветку.
Внимание: условный оператор в~◊${\lambda}-исчислении только выглядит похожим на ◊ii{if}–◊ii{then}–◊ii{else} из~Scheme —
они~отличаются очень важной деталью: порядком вычислений.
В~◊${\lambda}-исчислении порядок абсолютно произвольный —
ничто не~мешает даже параллельно вычислять все три выражения,
чтобы получить результат как можно скорее.

◊indexE{Scheme!и лямбда-исчисление@и~◊${\lambda}-исчисление}
Это очень важное замечание, так как мы не~можем считать ◊${\lambda}-исчисление —
фактически, язык реализации нового интерпретатора —
полностью эквивалентным~Scheme.
В~◊${\lambda}-исчислении порядок вычислений отсутствует в~приципе, как~концепция.
Денотация условной формы лишь означает, что форма может принять одно из двух значений,
а~какое именно — зависит от~условия.

◊indexR{порядок вычислений}
Тем не~менее, отсутствие порядка не~мешает корректности вычислений,
ведь переменные обеих веток изолированы,
а~функции ◊${\lambda}-исчисления не~имеют побочных эффектов.
Например, следующее выражение вполне успешно вычисляется,
хотя казалось~бы, если вычислять подвыражения параллельно или в~«неправильном» порядке, то~нас ожидает провал:

◊code:lisp{
(if (= 0 q) 1 (/ p q))
}

Это выражение должно проверить, равна~ли~◊ic{q} нулю, и, если это~так,
то вернуть единицу, иначе — выполнить деление ◊ic{p} на~◊ic{q} и вернуть полученное частное.
Денотация этого выражения выражает выбор между ◊${1} и~◊${p/q} в~зависимости от~того, равна~ли ◊${q}~нулю.

Из-за «плохого» порядка вычислений, принятого в~Scheme, денотацию условной формы иногда сложно понимать,
так~как от неё ожидается вычисление условия перед телом,
а~не~вычисление всего сразу вместе с~возможными вариантами подобно квантовым компьютерам.
Поэтому перепишем денотацию следующим образом:

◊code:denotation{
(define ((meaning-other-alternative e1 e2 e3) r k s)
  ((meaning e1) r
                (lambda (v s1)
                  ((ef (boolify v) (meaning e2) (meaning e3))
                   r k s1 ) )
                s ) )
}

Здесь вводится некоторый порядок вычислений.
Теперь значение условия служит только для выбора нужной ветки —
собственно вычисление значения выполняется отдельно и~единожды.

Попробуем проверить, эквивалентно~ли новое определение предыдущему.
Для этого достаточно доказать эквивалентность их денотаций.
Иными~словами, показать,~что

◊$${
(◊fn{boolify}\ ◊|e|) \to (◊Eval ◊sem{◊|p|_1}\ ◊|r|\ ◊|k|\ ◊|s|) ◊switch (◊Eval ◊sem{◊|p|_2}\ ◊|r|\ ◊|k|\ ◊|s|)
\equiv
\big((◊fn{boolify}\ ◊|e|) \to ◊Eval ◊sem{◊|p|_1} ◊switch ◊Eval ◊sem{◊|p|_2}\ ◊|r|\ ◊|k|\ ◊|s|\big)
}

Это тождество очевидно ложно в~Scheme из-за аппликативного порядка вычислений,
что вроде~бы легко доказывается контрпримером: пусть ◊${◊|p|_2} является бесконечным циклом.
Однако денотации — это~выражения ◊${\lambda}-исчисления,
и~сравнивать их следует по~законам ◊${\lambda}-исчисления.
В~таком случае мы видим простейший дистрибутивный закон.

Надеюсь, иероглифов было достаточно.
Далее мы будем использовать ещё~более читабельную запись условных выражений:

◊; TODO: тут тоже надо немного по-другому показывать условную запись
◊code:denotation{
(define ((meaning-other-alternative e1 e2 e3) r k s)
  ((meaning e1) r
                (lambda (v s1)
                  ((if (boolify v) (meaning e2) (meaning e3))
                   r k s1 ) )
                s ) )
}
