#lang pollen

◊section[#:label "denotational/sect:eval-order"]{Порядок вычисления аргументов}

◊indexR{порядок вычислений!в Scheme и Си}
Время от времени в~Интернете вспыхивают яростные ◊strike{срачи} дискуссии касательно одной из особенностей Scheme.
Все предлагаемые стандарты языка, начиная с~самого первого, не~определяют порядок вычисления термов аппликации.
Отсутствие гарантированного порядка по~идее должно предотвращать написание программ, которые зависят от определённого порядка вычислений,
однако на~практике подобные неявные зависимости очень сложно находить и~отлаживать.
Многие программы, даже за~авторством видных экспертов, неявно зависят от порядка вычислений —
особенно если они используют продолжения.
В~этой книге предпочитается порядок слева направо, так~как он соответствует направлению чтения во~многих языках,
а~также привносит хоть какую-то систематичность в~поиск~ошибок.

Среди доводов оппонентов особый интерес представляют следующие~два.
Во-первых, многие языки не~указывают порядок вычислений.
В~частности, в~язые~Си порядок вычисления аргументов функций не~определён.
Если выражение ◊nobr{◊ic{(foo (f x) (g x y))}} транслируется в~следующий код на~Си: ◊nobr{◊ic{foo(f(x), g(x, y))}},
то~нам действительно не~следует полагаться на какой-либо порядок.

Второй довод больше философский.
В~языке без предопределённого порядка вычислений можно организовать явный порядок самостоятельно с~помощью ◊ic{begin}.
Обратное~же не~верно — в~языке с~определённым порядком вычислений невозможно выразить неопределённый порядок.
Разве что использовать генератор случайных чисел,
◊seeEx{denotational/ex:truly-random}
чтобы обеспечить непредсказуемость порядка вычислений — довольное дорогое удовольствие.

На~самом~же деле, в~Си порядок вычислений не~фиксируется для того,
чтобы разрешить компилятору выбирать любой необходимый или удобный для него порядок,
например,~чтобы эффективнее распределять регистры.

Известный порядок вычислений упрощает отладку, делая одной неопределённостью меньше.
Если порядок не~определён, то~два прогона одной и той~же программы на одних и тех~же данных могут дать разные результаты.
Рассмотрим пример:
◊footnote{Функция разработана совместно с~Матиасом~Феллайзеном (◊english{Matthias~Felleisen}).}

◊indexC{dynamically-changing-evaluation-order}
◊indexC{amb}
◊code:lisp{
(define (dynamically-changing-evaluation-order?)
  (define (amb)
    (call/cc (lambda (k) ((k #t) (k #f)))) )
  (if (eq? (amb) (amb))
      (dynamically-changing-evaluation-order?)
      #t ) )
}

Функция~◊ic{amb} возвращает истину или ложь в~зависимости от порядка вычислений.
Если порядок вычислений не~фиксирован, то~функция ◊ic{dynamically-changing-evaluation-order?} рано или поздно остановится и~вернёт~◊ic{#t} —
иначе~же она навечно застрянет в~бесконечном цикле.
В~◊R5RS нет~ничего, что требовало~бы от этой программы того или~иного поведения.

◊indexR{порядок вычислений!неопределённый}
Необходимо чётко отделять семантику языка от его прагматики, от~практической реализации.
Разумеется, интерпретаторы и компиляторы вынуждены выбирать ◊emph{некоторый} порядок.
Слева~направо, или~справа~налево, как~MacScheme, или хоть в~зависимости от~текущей фазы~Луны.
Однако ни~одна из известных мне реализаций не~варьирует порядок вычисления аргументов во~время исполнения программы.
Обычно порядок определяется при компиляции и~не~изменяется при каждом вызове функции.
Неопределённость порядка вычислений следует понимать как привилегию реализации выбирать любой порядок,
а~не~обязанность поддерживать случайный.

◊indexR{результат@◊${◊Vset{Результат}}}
Вопрос теперь состоит в~том, как выразить неопределённость порядка вычислений в~семантике языка.
Предлагаемая идея заключается в~небольшом изменении структуры денотаций.
Сейчас мы используем ◊${\lambda}-термы, которые принимают окружение вместе с~продолжением и~памятью, а~в~ответ возвращают некоторый результат.
Полученный результат принадлежит домену ◊${◊Vset{Значений}} —
но~ведь на самом деле значения изменяемых объектов неразрывно связаны с~состоянием памяти:
как мы~говорили ранее, побочные эффекты — это~тоже результат работы программы.
Поэтому нам, пожалуй, стоит сделать результатом вычислений именно пару
◊${(◊math-ii{значение}, ◊math-ii{память})}.
Однако вместо философствования на тему того, что именно является результатом вычислений,
давайте просто будем считать областью значений денотаций некий домен~◊${◊Vset{Результатов}}.

◊; TODO: тут какой-то особый кернинг вокруг ◊Noir
◊indexR{порядок вычислений!неопределённый!денотация}
◊indexR{интерпретатор!N@◊${◊Noir}}
◊indexE{N@◊${◊Noir}, интерпретатор}
◊indexE{P@◊${\mathcal{P}(Q)} (множество)}
Так как вычисления могут выполняться по-разному, то~и денотации будут возвращать не~один результат,
а~множество всех возможных результатов, соответствующих различным порядкам вычислений.
Реализация~же будет выбирать из этого множества какой-нибудь один результат, руководствуясь собственными соображениями.
Следовательно, ◊${◊Eval} теперь соответствует обобщённому результату, а~конкретная реализация представляется функцией~◊${◊Noir}.
Если обозначить ◊${\mathcal{P}(Q)} множество всех подмножеств~◊${Q}, то~эти функции имеют следующие~типы:

◊; TODO: это длинная формула, её надо бы порезать на строки?
◊$${
\begin{align*}
◊Eval \colon & \quad ◊Vset{Программа}
    \to ◊Vset{Значения}^* \times ◊Vset{Окружение} \times ◊Vset{Продолжение} \times ◊Vset{Память}
    \to \mathcal{P}(◊Vset{Результаты})  \\
◊Noir \colon & \quad ◊Vset{Программа}
    \to ◊Vset{Значения}^* \times ◊Vset{Окружение} \times ◊Vset{Продолжение} \times ◊Vset{Память}
    \to ◊Vset{Результат}  \\
\end{align*}
}

◊; TODO: опять же, ◊ii vs. ◊fn (здесь и ниже по тексту с cut и forall)
◊; TODO: кернинг вокруг "oneof" и ◊Noir
◊indexE{oneof@◊ii{oneof}}
◊${◊Noir} определяется просто: она использует ◊ii{oneof}, чтобы выбрать один из возможных результатов.
Естественно, определение функции~◊ii{oneof} возлагается на~реализацию.

◊; TODO: трансляция
◊code:denotation{
(define ((new-meaning e*0*n) r k s)
  (oneof ((meaning e*0*n) r k s)) )
}

Далее необходимо переопределить аппликацию функций так, чтобы получать все возможные результаты.
Здесь нам следует задуматься о~том, что именно означает неопределённость порядка вычисления аргументов.
Аппликацию можно понимать следующим образом:
выбирается случайный терм, обозначим его~◊${◊|p|_a}, вычисление которого даёт~◊${◊|e|_a},
затем из оставшихся термов выбирается следующий терм~◊${◊|p|_b}, который вычисляется в~◊${◊|e|_b}, и~так~далее.
Наконец значения ◊${◊|e|_i \dots} переупорядочиваются так, как они шли в~исходной форме аппликации:
◊${◊|e|_0, ◊|e|_1, \dots, ◊|e|_n},
после чего первое значение-функция применяется к~последовательности из~всех остальных значений-аргументов.
Обратите внимание: порядок в~котором вычисляются значения, несколько отличается от ◊R5RS,
где~последовательность вычисления всех термов определяется до вычисления первого из~них.
Рассмотрим пример.
Следующая функция не~только выводит неопределённое число,
но~и~продолжение, которое она возвращает, также выводит неопределённое число.

◊indexC{one-two-three}
◊code:lisp{
(define (one-two-three)
  (call/cc (lambda (k)
             ((begin (display 1) (call/cc k))
              (begin (display 2) (call/cc k))
              (begin (display 3) (call/cc k)) ) )) )
}

◊indexE{forall@◊ii{forall}}
◊indexE{cut@◊ii{cut}}
◊indexR{стиль передачи продолжений (CPS)}
◊indexE{CPS, continuation passing style}
Денотация аппликации с~неопределённым порядком вычисления аргументов «реализует» неопределённость именно таким образом.
Мы~рассматриваем все возможные перестановки аргументов с~помощью функции~◊ii{forall},
которая применяет свой первый аргумент (тернарную~функцию) ко~всем возможным срезам второго аргумента (списка).
Срезы предоставляются функцией~◊ii{cut}, которая разрезает список на две~части:
первая содержит первые ◊${i}~элементов, другая — все оставшиеся;
затем~◊ii{cut} применяет свой третий аргумент (продолжение) к~обеим~частям.
Определения слегка запутанные, но~это хороший пример программирования в~стиле передачи продолжений.
(Программа разработана в~сотрудничестве ◊seeCite{alq95} с~Софи~Англад и Жан-Жаком~Лакрампом.)

◊indexE{possible-paths@◊ii{possible-paths}}
◊indexE{loop@◊ii{loop}}
◊indexE{accumulate@◊ii{accumulate}}
◊code:denotation{
(define ((meaning-orderless-application *e*0*n) r k s)
  ((possible-paths (map meaning *e*0*n))
   r
   (lambda (v* s)
     ((Value->Function (car v*)) (cdr v*) k s) )
   s ) )

(define (possible-paths m+)
  (lambda (r k s)
    (if (> (length (cdr m+)) 0)
        (forall (lambda (<m m m>)
                  (m r
                     (lambda (v ss)
                       ((possible-paths (append <m m>))
                        r
                        (lambda (v* sss)
                          (let ((q (lambda (<v v>)
                                     (k (append <v (list v) v>) sss) )))
                            (cut (length <m) v* q) ) )
                        ss ) )
                     s ) )
                m+ )
        ((car m+) r
                  (lambda (v ss) (k (list v) ss))
                  s ) ) ) )

(define (forall f l)
  (letrec ((loop (lambda (before item after)
                   (union (f before item after)
                          (if (> (length after) 0)
                              (loop (append before (list item))
                                    (car after)
                                    (cdr after) )
                              empty-set ) ) )))
    (loop (list) (car l) (cdr l)) ) )

(define union append)
(define empty-set '())

(define (cut i v* q)
  (letrec ((accumulate
            (lambda (left i right)
              (if (> i 0)
                  (accumulate (cons (car right) left)
                              (- i 1)
                              (cdr right) )
                  (q (reverse left) right) )) ))
    (accumulate (list) i v*) ) )
}

◊indexE{Scheme!параллельные вычисления}
Во~всех приведённых случаях порядок вычисления аргументов является неопределённым,
однако сами вычисления остаются строго последовательными — это~требование стандарта:
результат должен быть эквивалентен вычислению аргументов в~некоторой последовательности.
То~есть следующая программа может вернуть ◊nobr{◊ic{(3 5)}} или~◊nobr{◊ic{(4 3)}},
но~никак~не~◊nobr{◊ic{(3 3)}}:

◊code:lisp{
(let ((x 1) (y 2))
  (list (begin (set! x (+ x y)) x)
        (begin (set! y (+ x y)) y) ) )
}

Денотация следующей программы, полученная с~помощью новой ◊${◊Eval},
будет возвращать два возможных результата: ◊ic{1}~и~◊ic{2}.
Конкретная реализация сможет выбрать один из них с~помощью ◊${◊Noir} и~◊ii{oneof}.

◊; TODO: стрелочки!
◊code:lisp{
(call/cc (lambda (k) ((k 1) (k 2)))) ◊(is) {1, 2}
}
