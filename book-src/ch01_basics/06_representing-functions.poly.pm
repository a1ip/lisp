#lang pollen

◊section[#:label "basics/sect:representing-functions"]{Представление функций}

Наверное, проще всего представлять функции с~помощью функций.
Естественно, это не~тавтология и читать следует так:
«функции определяемого языка проще всего представлять функциями языка реализации».
Такое решение серьёзно упрощает механизм вызова функций:
◊ic{invoke} должна лишь проверить, действительно~ли её первый аргумент является функцией —
чем-то, что можно~вызвать.

◊indexC{invoke}
◊code:lisp[#:chunk "invoke"]{
(define (invoke fn args)
  (if (procedure? fn) (fn args)
      (wrong "Not a function" fn) ) )
}

Проще некуда.
Даже может возникнуть вопрос: зачем вообще нужна отдельная функция ◊ic{invoke},
когда весь этот код можно было встроить сразу в~◊ic{evaluate}.
Причина, по~которой так сделано, в~том, что мы показываем структуру будущих интерпретаторов,
а~в~них ◊ic{invoke} будет уже не~такой простой.
Кстати, попробуйте сейчас выполнить упражнения~◊ref{basics/ex:def-call/cc} и~◊ref{basics/ex:def-apply}.

◊indexR{аппликация!порядок вычисления термов}
◊indexR{порядок вычислений!термов аппликации}
Обратите внимание на новый тип ошибок, возникающих при попытке вызвать невызываемое.
Сейчас мы обрабатываем такие ошибки в~момент применения функции к~уже вычисленным аргументам,
но~мы могли~бы предупреждать пользователя раньше.
В~таком случае нам необходимо задать порядок вычисления элементов формы вызова~функции:

◊enumerate[#:type "1"]{
  ◊item{
    вычислить элемент на месте функции;
  }
  ◊item{
    если это не~функция, сообщить об~ошибке;
  }
  ◊item{
    вычислить аргументы слева направо;
  }
  ◊item{
    сравнить количество аргументов с~арностью функции:
    если они не~совпадают, то сообщить об~ошибке.
  }
}

Вычислять аргументы слева направо кажется логичным для людей, читающих программы слева направо,
да~и реализовать такой порядок в~общем-то проще.
Сложности могут возникнуть у~компилятора, потому что если ему захочется изменить этот порядок
(например, чтобы эффективнее использовать регистры процессора),
то~он будет вынужден доказать, что это не~изменит смысла программы.

Конечно, мы могли бы действовать эффективнее, проверяя арность ещё раньше:

◊enumerate[#:type "1"]{
  ◊item{
    вычислить элемент на месте функции;
  }
  ◊item{
    если это не~функция, то~сообщить об~ошибке,
    иначе запомнить ожидаемое количество аргументов;
  }
  ◊item{
    вычислять аргументы слева направо до тех пор, пока их количество согласуется с~арностью функции;
    в~случае проблем сообщить об~ошибке;
  }
  ◊item{
    применить функцию к~аргументам.
    ◊footnote{
      Функция могла бы потом ещё проверять правильность типов переданных аргументов,
      но это не~имеет прямого отношения к~механизму вызова функций.
    }
  }
}

Стандарт ◊(CommonLisp) требует, чтобы аргументы вычислялись строго слева направо,
но~с~целью оптимизации позволяет вычислять функциональный элемент формы до или после остальных.

Scheme~же никак не~определяет порядок вычисления элементов формы вызова функции, включая сам элемент-функцию.
Так как ограничений нет, то компилятор волен выбирать любой устраивающий его порядок.
◊seePage{denotational/sect:eval-order}
А~пользователь, в~свою очередь, не~может рассчитывать на какой-либо определённый порядок вычислений
и~должен в~случае необходимости использовать ◊ic{begin}, чтобы задать порядок~явно.

Программы, поведение которых зависит от порядка вычисления аргументов, считаются плохим стилем.
Следует избегать выражений вроде ◊ic{(f~(set!~f~◊${\pi}) (set!~f~◊${\pi'}))},
где неясно, какая~же функция будет вызвана на самом деле.
Подобные ошибки очень сложно~отлаживать.
