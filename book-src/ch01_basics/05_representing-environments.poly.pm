#lang pollen

◊section[#:label "basics/sect:repr-the-env"]{Представление окружений}

◊indexE{A-список}
◊indexE{alist}
◊indexR{А-список}
◊indexR{ассоциативный список}
Окружения связывают переменные с~их значениями.
Обычно в~Лиспе подобные связи представляются ◊term{ассоциативными списками},
также называемыми ◊nobr{◊term{А-списками}}~(◊english{alists}).

◊code:lisp{
((a . 1) (b . 2) (fact . (1 2 6 24 120)) ...)
}

Здесь переменная~◊ic{a} связана со~значением~◊ic{1},
переменная~◊ic{b} — со~значением~◊ic{2},
переменная~◊ic{fact} содержит список~◊ic{(1 2 6 24 120)},
и~так далее для всех остальных переменных, определённых в~этом окружении.

Мы~тоже будем представлять окружения как~А-списки, связывающие переменные и значения.
Для простоты имена переменных будем представлять символами.


◊subsection*{Поиск значения переменной}

Функция ◊ic{lookup} определяется элементарно:

◊indexC{lookup}
◊code:lisp[#:chunk "lookup"]{
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (cdar env)
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )
}

Тут мы видим второй тип
◊footnote{Первый — это синтаксические ошибки (см.~◊pageref{basic/atoms/para:the-first-error}).}
возможных ошибок, возникающих при попытке узнать значение неизвестной переменной.
Мы опять лишь вызовем ◊ic{wrong}, чтобы сообщить о~проблеме куда~следует.

◊indexR{автоцитирование}
Когда компьютеры были большими, а память была маленькой,
◊footnote{
  Память (вместе с~подсистемами ввода-вывода) всё ещё остаётся одной из наиболее дорогих частей компьютера, хоть и постоянно дешевеет.
}
для переменных часто применялось ◊term{автоцитирование}.
Если с~переменной не~было связано какое-либо значение, то этим значением становился символ с~именем переменной.
Было~бы очень обидно видеть, как понятия переменной и символа, которые мы так усердно разделяли, опять смешиваются и перепутываются.

Хотя это несомненно удобно — никогда не~совершать ошибок,
но если программа замалчивает ошибки программиста — она не~становится более корректной.
Наоборот, ошибки должны быть обнаружены как можно раньше, чтобы как можно быстрее их исправить.
Следовательно, использование автоцитирования — плохое решение,
потому что оно скрывает некоторые ошибки, которые могли~бы быть исправлены раньше.


◊subsection*{Изменение значения переменной}

Функция~◊ic{update!} изменяет окружение,
так что, скорее всего, тоже может обнаружить похожую ошибку в~программе:
нельзя изменить значение неизвестной переменной.
Мы~обсудим, следует~ли ей так поступать, когда будем говорить о~глобальном окружении.

◊indexC{update!}
◊code:lisp[#:chunk "update!"]{
(define (update! id env value)
  (if (pair? env)
      (if (eq? (caar env) id)
          (begin (set-cdr! (car env) value)
                 value)
          (update! id (cdr env) value) )
      (wrong "No such binding" id) ) )
}

◊indexC{set!!возвращаемое значение}
◊indexR{присваивание!возвращаемое значение}
◊indexR{возвращаемые значения!присваивания}
◊indexC{UFO@#<UFO>}
◊phantomlabel{basics/s:env/ufo}
Возвращаемое значение функции~◊ic{update!} выбрано с~учётом того, что это значение станет значением всего выражения присваивания.
В~Scheme возвращаемое значение формы присваивания не~определено.
Строго говоря, программам не~следует полагаться на какое-либо значение,
но, тем не~менее, мы вынуждены выбрать какое-нибудь значение.
Например:

◊enumerate[#:type "a"]{
  ◊item{
    только что присвоенное значение (так сделано сейчас);
  }
  ◊item{
    предыдущее значение переменной
    (могут быть проблемы с~инициализацией, первым присваиванием);
  }
  ◊item{
    объект «неопределённое значение», некий ◊ic{#<UFO>},
    используемый исключительно как индикатор неопределённого значения;
  }
  ◊item{
    значение формы с~неопределённым значением, вроде ◊ic{set-cdr!} в~Scheme.
  }
}


◊subsection*{Создание новых окружений}

◊indexR{окружение!как тип данных}
Окружения — это составной абстрактный тип данных.
Мы~уже умеем извлекать и изменять их части с~помощью соответствующих функций;
ещё остаётся научиться создавать новые окружения и добавлять в~них новые~элементы.

◊indexR{окружение!начальное}
Изначально в~окружении ничего нет.
Это записывается просто:

◊indexC{env.init}
◊code:lisp[#:chunk "env.init"]{
(define env.init '())
}

(Чуть позже, в~разделе~◊ref{basics/sect:representing-functions},
мы сделаем начальное окружение более обжитым.)

Когда вызывается функция, для неё создаётся новое окружение,
в~котором аргументы функции связаны со~своими фактическими значениями.
Функция~◊ic{extend} расширяет окружение~◊ic{env} переменными~◊ic{variables} со~значениями~◊ic{values}.

◊indexC{extend}
◊code:lisp[#:chunk "extend"]{
(define (extend env variables values)
  (cond ((pair? variables)
         (if (pair? values)
             (cons (cons (car variables) (car values))
                   (extend env (cdr variables) (cdr values)) )
             (wrong "Too few values") ) )
        ((null? variables)
         (if (null? values)
             env
             (wrong "Too many values") ) )
        ((symbol? variables) (cons (cons variables values) env)) ) )
}

◊indexR{список аргументов}
◊indexR{синтаксис!списка аргументов}
◊indexR{переменные!точечные}
◊indexR{точечные переменные}
Главная сложность состоит в~том, что нам надо проанализировать все варианты
записи ◊${<◊math-ii{списка аргументов}>}, какие разрешены в~Scheme.
◊footnote{
  Некоторые лисп-системы, вроде ◊(CommonLisp),
  поддались соблазну расширить синтаксис перечня аргументов ключевыми словами
  вроде~◊ic{&aux}, ◊ic{&key}, ◊ic{&rest}.
  Подобные возможности заметно усложняют синтаксический разбор программ и передачу аргументов.
  Иные системы позволяют даже обобщённое указание аргументов с~помощью шаблонов~◊cite{sj93}.
}
Список аргументов может быть представлен не~только обычным списком символов,
но~и точечным: заканчивающимся не~на~◊ic{()}, а~на определённый символ (◊term{точечную переменную}).
Более формально список аргументов определяется следующей грамматикой:

◊$${
\begin{align*}
<◊math-ii{список аргументов}> & ::= &  ◊math-ic{()}           \\
                              &  |  & <◊math-ii{переменная}>  \\
                              &  |  &  ◊math-ic{(}<◊math-ii{переменная}>◊math-ic{ . }<◊math-ii{список аргументов}>◊math-ic{)} \\
       <◊math-ii{переменная}> & \in &  ◊Vset{Символы}
\end{align*}
}

Когда мы расширяем окружение, количество значений переменных должно соответствовать количеству их имён.
Обычно их поровну, но если список оканчивается на точечную (или~◊term{◊${n}-арную}) переменную,
то она связывается со~списком всех оставшихся аргументов.
Здесь возможны две~ошибки: либо~значений больше, чем переменных, либо~наоборот.
