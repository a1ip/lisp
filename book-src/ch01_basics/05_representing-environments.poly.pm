#lang pollen

◊section[#:label "basics/sect:repr-the-env"]{Представление окружений}

◊indexE{A-список}
◊indexE{alist}
◊indexR{А-список}
◊indexR{ассоциативный список}
Окружения связывают переменные с~их значениями.
Обычно в~Лиспе подобные связи представляются ◊term{ассоциативными списками},
также называемыми ◊nobr{◊term{А-списками}}~(◊english{alists}).
Мы~тоже будем представлять окружения как~А-списки, связывающие переменные и значения.
Для простоты имена переменных будем представлять символами.

Таким образом, функции ◊ic{lookup} и ◊ic{update!} определяются элементарно:

◊indexC{lookup}
◊code:lisp[#:chunk "lookup"]{
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (cdar env)
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )
}

Тут мы видим второй тип
◊footnote{Первый — это синтаксические ошибки (см.~◊pageref{basic/atoms/para:the-first-error}).}
возможных ошибок, появляющихся при попытке узнать значение неизвестной переменной.
Мы опять лишь вызовем ◊ic{wrong}, чтобы сообщить о~проблеме наверх.

◊indexR{автоцитирование}
Когда компьютеры были большими, а память была маленькой,
◊footnote{
  Память (вместе с~подсистемами ввода-вывода) всё ещё остаётся одной из наиболее дорогих частей компьютера, хоть и постоянно дешевеет.
}
для переменных часто применялось ◊term{автоцитирование}.
Если с~переменной не~было связано какое-либо значение, то этим значением становился символ с~именем переменной.
Было~бы очень обидно видеть, как понятия переменной и символа, которые мы так усердно разделяли, опять смешиваются и перепутываются.

Хотя это несомненно удобно — никогда не~совершать ошибок, но такой идеальный мир имеет большой недостаток:
задача программы не~в~том, чтобы работать без ошибок, а~в~том, чтобы выполнять то, для чего она предназначена.
В~некотором смысле ошибки играют роль перил:
если программа на них натыкается, значит её понесло куда-то не~туда.
Ошибки должны быть обнаружены как можно раньше, чтобы как можно быстрее их исправить.
Следовательно, использование автоцитирования — плохое решение,
потому что оно скрывает некоторые ошибки, которые могли~бы быть исправлены раньше.

Функция~◊ic{update!} изменяет окружение,
так что, скорее всего, тоже может обнаружить похожую ошибку в~программе:
нельзя изменить значение неизвестной переменной.
Мы~обсудим, следует~ли ей так поступать, когда будем говорить о~глобальном окружении.

◊indexC{update!}
◊code:lisp[#:chunk "update!"]{
(define (update! id env value)
  (if (pair? env)
      (if (eq? (caar env) id)
          (begin (set-cdr! (car env) value)
                 value)
          (update! id (cdr env) value) )
      (wrong "No such binding" id) ) )
}

◊indexC{set!!возвращаемое значение}
◊indexR{присваивание!возвращаемое значение}
◊indexR{возвращаемые значения!присваивания}
◊indexC{UFO@#<UFO>}
◊phantomlabel{basics/s:env/ufo}
Возвращаемое значение функции~◊ic{update!} выбрано с~учётом того, что это значение станет значением всего выражения присваивания.
В~Scheme возвращаемое значение формы присваивания не~определено.
Строго говоря, программам не~следует полагаться на какое-то значение,
но, тем не~менее, мы вынуждены выбирать, что именно будем возвращать в~нашем случае.
Например:

◊enumerate{
  ◊item{
    только что присвоенное значение (так сделано сейчас);
  }
  ◊item{
    предыдущее значение переменной
    (могут быть проблемы с~инициализацией, первым присваиванием);
  }
  ◊item{
    объект «неопределённое значение», некий ◊ic{#<UFO>},
    используемый исключительно как индикатор неопределённого значения;
  }
  ◊item{
    значение формы с~неопределённым значением, вроде ◊ic{set-cdr!} в~Scheme.
  }
}

◊indexR{окружение!как тип данных}
Окружения — это составной абстрактный тип данных.
Мы уже можем извлекать и изменять их части с~помощью соответствующих функций;
но~ещё надо уметь создавать новые окружения и добавлять в~них новые~части.

◊indexR{окружение!начальное}
Изначально в~окружении ничего нет.
Это записывается просто:

◊indexC{env.init}
◊code:lisp[#:chunk "env.init"]{
(define env.init '())
}

(Чуть позже, в~разделе~◊ref{basics/sect:representing-functions}, мы сделаем его не~таким необитаемым.)

Когда вызывается функция, для неё создаётся новое окружение,
в~котором её аргументы связаны со~своими фактическими значениями.
Функция~◊ic{extend} расширяет окружение~◊ic{env} переменными~◊ic{variables} со~значениями~◊ic{values}.

◊indexC{extend}
◊code:lisp[#:chunk "extend"]{
(define (extend env variables values)
  (cond ((pair? variables)
         (if (pair? values)
             (cons (cons (car variables) (car values))
                   (extend env (cdr variables) (cdr values)) )
             (wrong "Too few values") ) )
        ((null? variables)
         (if (null? values)
             env
             (wrong "Too many values") ) )
        ((symbol? variables) (cons (cons variables values) env)) ) )
}

◊indexR{список аргументов}
◊indexR{синтаксис!списка аргументов}
◊indexR{переменные!точечные}
◊indexR{точечные переменные}
Главная сложность состоит в~том, что нам надо проанализировать все варианты
записи ◊${<\textit{списка аргументов}>}, какие разрешены в~Scheme.
◊footnote{
  Некоторые лисп-системы, вроде ◊(CommonLisp),
  поддались соблазну расширить синтаксис перечня аргументов ключевыми словами
  вроде ◊ic{&aux}, ◊ic{&key}, ◊ic{&rest}.
  Это сильно усложняет синтаксический разбор программ и передачу аргументов.
  Иные системы позволяют даже обобщённое указание аргументов с~помощью шаблонов~◊cite{sj93}.
}
Список аргументов может быть представлен не~только обычным списком символов,
но~и точечным: заканчивающимся не~на~◊ic{()}, а~на определённый символ (◊term{точечную переменную}).
Более формально список аргументов определяется следующей грамматикой:

◊$${
\begin{align*}
<\textit{список аргументов}> & ::= &  \texttt{()}           \\
                             &  |  & <\textit{переменная}>  \\
                             &  |  &  \texttt{(}<\textit{переменная}>\texttt{ . }<\textit{список аргументов}>\texttt{)} \\
       <\textit{переменная}> & \in &  \boldsymbol{Символы}
\end{align*}
}

Когда мы расширяем окружение, количество значений переменных должно соответствовать количеству их имён.
Обычно их поровну, но если список оканчивается на точечную (или~◊nobr{◊term{◊${n}-арную}}) переменную,
то она связывается со~списком всех оставшихся аргументов.
Здесь возможны две~ошибки: либо~значений больше, чем переменных, либо~наоборот.
