#lang pollen

◊subsection*{Окружение исполнения~функций}

◊indexR{окружение!исполнения тела функции}
Применение функции сводится к~вычислению выражений, составляющих её тело,
в~окружении, где аргументы функции связаны со~значениями, переданными при вызове функции.
Вспомните, что при вызове ◊ic{make-function} мы передали всё необходимое для этого,
находящееся в~распоряжении ◊ic{evaluate}.
В~оставшейся части этого раздела мы будем разбирать используемые при вычислениях окружения,
в~программах они будут набраны~◊ii{курсивом}.


◊subsubsection{Минимальное окружение}

Для начала рассмотрим минимально возможное окружение:

◊indexC{make-function}
◊code:lisp{
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend ◊ii{env.init} variables values)) ) )
}

◊indexE{K@◊comb{K}, комбинатор}
◊indexR{комбинаторы!K@◊comb{K}}
В~строгом соответствии с~данным ранее определением,
тело функции вычисляется в~окружении, где аргументы функции связаны с~переданными значениями.
Возьмём, например, комбинатор~◊comb{K}, определяемый как ◊ic{(lambda~(a~b)~a)}:

◊code:lisp{
(K 1 2) ◊(is) 1
}

Но~есть и неприятность:
функции могут использовать только свои аргументы и локальные переменные,
ведь мы определили ◊ii{env.init} как пустое окружение.
В~нём нет даже базовых функций из глобального окружения вроде ◊ic{car} или~◊ic{cons}.
