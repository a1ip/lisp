#lang pollen

◊section[#:label "basics/sect:evaluating-atoms"]{Вычисляем атомы}

Одна из ключевых особенностей Лиспа состоит в~том, что программы записываются теми~же конструкциями, что~и~данные.
Но так как любая запись подразумевает определённые условности, поговорим о~таких условностях для записи программ.
Главные соглашения: переменные записываются символами (своими именами),
а~вызовы функций — списками, где первый элемент — это вызываемая функция, а~остальные — её~аргументы.

◊indexR{атом}
Как и любой другой компилятор, ◊ic{evaluate} начинает свою работу с~синтаксического анализа,
чтобы выяснить, что именно означает программа.
По~правде говоря, название раздела не~совсем верное:
мы рассматриваем не~буквально вычисление атомов, а~интерпретацию программ, состоящих из атомов.
Сейчас важно отличать саму программу от её представления
(письмо от листа бумаги, на котором оно написано).
Функция~◊ic{evaluate} работает с~представлением программ,
по~нему она узнаёт предписываемые программой действия и выполняет~их.

◊indexC{atom?}
◊code:lisp{
(define (evaluate exp env)
  (if (atom? exp)           ; (atom? exp) ◊(eq) (not (pair? exp))
      ...
      (case (car exp)
        ...
        (else ...) ) ) )
}

Если выражение не~является списком, то это скорее всего символ, или~число, или~какая-нибудь строка.
Если это всё~же символ, то он представляет ◊term{переменную}, а~её значение хранится в~окружении:

◊code:lisp{
(define (evaluate exp env)
  (if (atom? exp)
      (if (symbol? exp) (lookup exp env) exp)
      (case (car exp)
        ...
        (else ...) ) ) )
}

Функция~◊ic{lookup}
(которая рассматривается подробнее в~разделе~◊pageref{basics/sect:repr-the-env})
знает, как отыскать значение переменной в~окружении.
Вот её прототип:

◊indexC{lookup}
◊code:lisp{
(lookup ◊ii{переменная} ◊ii{окружение}) ◊(is) ◊ii{значение}
}

◊indexR{переменные!связь с~символами}
◊indexR{символы!связь с~переменными}
Как видим, наш интерпретатор неявно преобразует символы в~переменные.
Если быть более дотошным, то вместо ◊ic{(lookup exp env)} надо записать что-то вроде:

◊code:lisp{
... (lookup (symbol->variable exp) env) ...
}

◊indexR{приведение типов}
◊indexR{объекты!второго класса}
В~таком случае мы явно говорим, что символ~◊ic{exp}, чьим значением является имя переменной, должен быть преобразован в~переменную.
Также это подчёркивает тот факт, что функция ◊ic{symbol->variable}
◊footnote{
  Лично я не~люблю называть функции приведения типов ◊nobr{◊ic{◊ii{x}->◊ii{y}}},
  потому что так сложнее понимать цепочки преобразований.
  Запись ◊nobr{◊ic{(◊ii{y}->◊ii{z}(◊ii{x}->◊ii{y} ...))}} не~так очевидна, как ◊nobr{◊ic{(◊ii{z}<-◊ii{y}(◊ii{y}<-◊ii{x} ...))}}.
  Хотя, с~другой стороны, одиночная запись ◊nobr{◊ic{◊ii{z}<-◊ii{y}}} не~так легко читается, как ◊nobr{◊ic{◊ii{y}->◊ii{z}}}.
  Приходится~выбирать.
}
вовсе не~переводит символ~◊ic{exp} сам в~себя;
наоборот, она превращает синтаксическую сущность (символ) — в~семантическую (переменную).
Имена переменных существуют лишь в~языке программирования для удобства программиста;
если переменную везде переименовать, то поведение программы не~изменится.
Способ представления имён выбран из соображений удобства, так как Лисп имеет базовый тип символов.
В~нашем случае ◊ic{symbol->variable} ничего не~делает,
хотя в~других языках может применяться какая-нибудь другая форма записи имени переменной
(например, строка, состоящая из знака доллара и имени переменной);
в~таком случае, конечно~же, ◊ic{symbol->variable} будет несколько сложнее.

Если у~переменных на самом деле нет имён, то как~же ◊ic{lookup} будет их находить в~окружении?
Вместо переменной как таковой следует использовать её программное представление,
какой-нибудь уникальный ключ, по которому ◊ic{lookup} сможет отыскать переменную в~окружении.
Так что ещё точнее было~бы записать:

◊code:lisp{
... (lookup (variable->key (symbol->variable exp)) env) ...
}

Однако, врождённая лень лисперов подсказывает, что в~качестве ключей можно использовать символы.
Получается, что ◊ic{variable->key} — это лишь обратная функция к~◊ic{symbol->variable},
а~их последовательное применение никак не~изменяет~◊ic{exp}.

◊indexR{автоцитирование}
◊indexR{механизм автоцитирования}
Если выражение атомарное (то~есть не~является списком) и~не~является символом,
то соблазнительно его считать представлением константы с~соответствующим значением.
Такое поведение называется механизмом ◊term{автоцитирования}.
Автоцитируемый объект не~требует явного цитирования и имеет собственное значение.
За~примерами можно обратиться к~◊cite{cha96}.

Но~является~ли такое поведение правильным?
Во-первых, атомарные объекты не~всегда обозначают сами себя.
Например, строка ◊ic{"a?b:c"} могла~бы означать вызов компилятора~Си,
затем исполнение получившейся программы и подстановку возвращаемого ей значения вместо этой~строки.

С~другими объектами (вроде функций) вообще не~понятно, как именно их ◊emph{вычислять}.
К~примеру, ясно, что значением переменной ◊ic{car} является функция, возвращающая левый элемент пары,
но что является значением самой ◊emph{функции~◊ii{car}}?
Чаще всего попытки вычисления значения функции считаются ошибочными.

◊indexC{()}
◊indexR{пустой список, ◊ic{()}}
Другой пример проблемного значения — пустой список~◊ic{()}.
Судя по тому, что это список, он должен означать вызов функции.
Вот только в~нём нет ни~аргументов, ни~самой функции.
Такая запись в~Scheme запрещена и считается синтаксической ошибкой.

Поэтому необходимо очень аккуратно анализировать программу
и автоцитировать только те данные, для которых это явно стоит делать,
вроде чисел, строк, знаков.
◊seePage{basics/evaluating-forms/ssect:quoting}
Так что мы записываем следующее:

◊code:lisp{
(define (evaluate exp env)
  (if (atom? exp)
      (cond ((symbol? exp) (lookup exp env))
            ((or (number? exp) (string? exp) (char? exp)
                 (boolean? exp) (vector? exp) )
             exp )
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )
}

◊indexR{ошибки!варианты обработки}
◊indexC{wrong}
◊phantomlabel{basic/atoms/para:the-first-error}
В~исполняемой программе могут быть ошибки,
которые интерпретатору надо как-то обрабатывать.
Большинство лисп-систем имеет механизмы обработки исключительных ситуаций,
но~у~каждой реализации они свои собственные и не~всегда переносимые между реализациями.
В~случае ошибки мы будем вызывать ◊ic{wrong},
◊footnote{
  Заметьте, не~«◊emph{функцию}~◊ic{wrong}».
  Варианты её реализации подробнее рассматриваются в~разделе~◊ref{compilation/sect:exception}.
}
передавая первым аргументом строку.
В~строке находится текстовое описание ошибки,
а~следующие аргументы несут дополнительную информацию о~том, что вызвало проблему.
Системы с~зачаточным механизмом обработки ошибок
в~случае проблем обычно выдают какие-то непонятные надписи вроде ◊ic{"Bus~error: core~dumped"} и~умирают.
Другие останавливают текущую работу и возвращаются к~диалоговому режиму.
А~третьи могут связывать с~вычисляемым выражением специальный обработчик исключений,
который перехватит объект, описывающий ошибку, и~будет уже по нему решать, что делать дальше.
◊seePage{compilation/sect:exception}
В~некоторых случаях даже реализуется подобие экспертной системы,
которая самостоятельно анализирует ошибку, вызвавший её код,
и выдаёт пользователю возможные варианты исправления возникшей ситуации.
Короче говоря, сложно сказать однозначно, что следует делать в~случае~ошибки,
поэтому пока~что мы будем просто вызывать~◊ic{wrong}.
