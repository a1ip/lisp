#lang pollen

◊subsubsection{Ещё~немного об~◊ic{evaluate}}

◊indexR{порядок вычислений!термов аппликации}
Рассмотренное описание языка является более-менее точным.
Мы не~разобрали лишь несколько вспомогательных функций:
◊ic{lookup} и ◊ic{update!}, отвечающие за~окружения,
и~◊ic{make-function} вместе с~◊ic{invoke}, занимающиеся функциями.
Но даже сейчас нам уже многое известно об~◊ic{evaluate}.
Например, наш диалект имеет единое пространство имён,
понятие объекта в~нём распространяется вообще на всё
(как в~◊(Lisp1) ◊seePage{chapter:lisp1-2-omega}),
в~том числе и на функции.
Но~мы до сих пор не~знаем порядок вычисления аргументов.

В~нашем случае он зависит от порядка вычисления аргументов у~◊ic{cons},
которая используется в~◊ic{evlis}.
Но~мы легко можем указать любой понравившийся нам порядок, например, слева направо:

◊code:lisp{
(define (evlis exps env)
  (if (pair? exps)
      (let ((argument1 (evaluate (car exps) env)))
        (cons argument1 (evlis (cdr exps) env)) )
      '() ) )
}

Без введения новых специальных конструкций
◊footnote{
  Как известно, ◊ic{let} — это всего лишь простой макрос:
  ◊ic{(let~((◊${x}~◊${\pi_1}))~◊${\pi_2})}
  ◊(eq)
  ◊ic{((lambda~(◊${x})~◊${\pi_2})~◊${\pi_1})}.
}
мы уточнили поведение определяемого языка.
Первая часть книги направлена именно на это:
уточнение определяемого языка с~помощью всё более ограниченных возможностей,
что снижает зависимость описания от языка, используемого для реализации.
