#lang pollen

◊subsubsection{Исправляем проблему}

Но~даже при таком определении всё ещё есть проблемы.
Рассмотрим следующий пример:

◊code:lisp{
(((lambda (a)
    (lambda (b) (list a b)) )
  1 )
 2 )
}

Функция~◊ic{(lambda~(b) (list~a~b))} создаётся в~окружении,
где~◊ic{a}~связана со~значением~◊ic{1},
но~в~момент вызова в~окружении будет присутствовать только~◊ic{b}.
Таким образом, мы опять потеряли переменную~◊ic{a}.

Внимательный читатель уже заметил, что в~определении ◊ic{d.make-function} присутствуют два~окружения:
окружение определения ◊ii{def.env} и окружение исполнения ◊ii{current.env}.
В~жизни функции можно отметить два важных события: её~создание и её~вызов(ы).
Очевидно, что создаётся функция только однажды, а~вызываться может несколько раз;
или вообще никогда не~вызываться.
Следовательно, единственное
◊footnote{
  На~самом деле, здесь можно использовать любое необходимое окружение.
  См.~про форму~◊ic{closure} на странице~◊pageref{assignement/assignement/para:closure}.
}
окружение, которое мы однозначно можем связать с~функцией, — это окружение, в~котором она была создана.
Вернёмся к~исходным определениям функций ◊ic{evaluate} и ◊ic{invoke},
но~в~этот раз функцию~◊ic{make-function} запишем следующим~образом:

◊indexC{make-function}
◊code:lisp[#:label "basics/representing-functions/fixing/src:inject-current-env" #:chunk "make-function"]{
(define (make-function variables body ◊ii{env})
  (lambda (values)
    (eprogn body (extend ◊ii{env} variables values)) ) )
}

Теперь все приведённые примеры работают нормально.
В~частности, пример выше вычисляется следующим образом:

◊code:lisp{
(((lambda (a) (lambda (b) (list a b))) 1) 2)|◊where{
                                             | ◊ii{env.global}
                                             }
◊(eq) ((lambda (b) (list a b))◊where{
                              | a ◊(is) 1
                              | ◊ii{env.global}
                              }
    2 )◊where{
       | ◊ii{env.global}
       }
◊(eq) (list a b)◊where{
                | b ◊(is) 2
                | a ◊(is) 1
                | ◊ii{env.global}
                }
}

◊indexR{абстракция!замыкание}
◊indexR{абстракция!значение}
◊indexR{возвращаемые значения!абстракций}
◊indexR{замыкания}
Форма ◊ic{(lambda~(b) (list~a~b))} создаётся в~глобальном окружении, расширенном переменной~◊ic{a}.
Когда эта функция вызывается, она расширяет окружение своего создания переменной~◊ic{b},
таким образом, тело функции будет вычисляться в~окружении, где обе переменные ◊ic{a} и~◊ic{b} присутствуют.
После того, как функция вернёт результат, исполнение продолжается в~глобальном окружении.
Такое определение абстракции называется ◊term{замыканием} (◊english{closure}),
потому что тело функции становится замкнутым в~окружении своего определения.

Стоит отметить, что сейчас ◊ic{make-function} сама использует замыкания языка определения.
Это не~является обязательным, как мы покажем далее в~третьей~главе.
◊seePage{escape/actors/ssect:functions}
Функция~◊ic{make-function} возвращает замыкания —
характерная черта функциональных языков программирования.
