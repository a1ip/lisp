#lang pollen

◊section*[#:label "basics/sect:conclusions"]{Заключение}

◊indexR{язык!и смысл программ}
Действительно~ли мы сейчас определили язык?

◊indexR{смысл программ}
◊indexR{программы!смысл}
Конечно, мы можем запустить ◊ic{evaluate}, передать ей выражение, и она вскоре вернёт результат вычислений.
Но сама функция ◊ic{evaluate} не~имеет никакого смысла без языка, на котором она реализована.
А~если у~нас нет реализации языка реализации, то все наши программы превращаются в~тыкву.

Так как каждый лиспер является дальним родственником барона Мюнхгаузена,
то, наверное, наш язык программирования сможет как-нибудь определить себя~сам.
Язык~◊${L}, определённый функцией~◊ic{evaluate}, написанной на языке~◊${L},
является решением следующего уравнения относительно~◊${L}:

◊$${
\begin{equation*}
  \forall\pi \in ◊Vset{Программы}\colon L◊ic{(evaluate (quote ◊${\pi}) env.global)} \equiv L\pi
\end{equation*}
}

Исполнение любой программы~◊${\pi}, написанной на~◊${L} (обозначается как~◊${L\pi}),
должно вести себя так~же (то~есть давать тот~же результат или никогда не~завершаться),
как и~вычисление выражения~◊ic{(evaluate (quote~◊${\pi}) env.global)} на том~же языке~◊${L}.
Одним из занимательных следствий этого утверждения является то, что ◊ic{evaluate} способна
◊footnote{
  После того, как мы раскроем все используемые макросы и сокращения
  вроде ◊ic{let}, ◊ic{case}, ◊ic{define}, и~т.~д.
  Потом надо будет ещё поместить в~глобальное окружение функции ◊ic{evaluate}, ◊ic{evlis}, и~прочие.
}
проинтерпретировать сама себя.
Следовательно, следующие выражения эквивалентны:

◊$${
\begin{equation*}
◊left{◊ic{(evaluate (quote ◊${\pi}) env.global)} \equiv {}} \\
◊right{{} \equiv ◊ic{(evaluate (quote (evaluate (quote ◊${\pi}) env.global)) env.global)}}
\end{equation*}
}

Есть~ли ещё решения приведённого выше уравнения?
Да, и~их великое множество!
Например, как мы видели раньше, определение ◊ic{evaluate} не~указывает порядок вычислений.
Множество других свойств языка, используемого для реализации, бессознательно ◊emph{наследуются} определяемым языком.
Мы ничего не~можем о~них сказать по~сути, но все эти варианты удовлетворяют нашему уравнению.
Вместе с~многочисленными тривиальными решениями.
Рассмотрим, к~примеру, язык~◊${L_{2001}}, любая программа на котором возвращает~◊${2001}.
Даже такой язык удовлетворяет этому уравнению.
Так что для определения настоящих языков необходимы другие методы;
их~мы рассмотрим в~следующих главах.
