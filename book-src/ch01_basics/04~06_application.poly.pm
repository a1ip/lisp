#lang pollen

◊subsection[#:label "basics/evaluating-forms/ssect:application"]{Аппликация}

◊indexR{аппликация}
◊indexR{комбинация}
◊indexR{терм!функциональный}
◊indexR{функциональный терм}
Если первый элемент списка не~является специальным оператором,
то~такой список обозначает применение функции,
которое в~◊${\lambda}-исчислении называется ◊term{аппликацией} или ◊term{комбинацией}.
Функция, полученная в~результате вычисления первого элемента, применяется к~аргументам,
которые мы получим, вычислив остальные элементы списка.
Эти манипуляции описываются следующим~кодом:

◊code:lisp{
... (case (car e)
      (else (invoke (evaluate (car e) env)
                    (evlis (cdr e) env) )) ) ...
}

Вспомогательная функция~◊ic{evlis} принимает список выражений
и~возвращает список соответствующих им значений.
Она определяется~так:

◊indexC{evlis}
◊code:lisp[#:chunk "evlis"]{
(define (evlis exps env)
  (if (pair? exps)
      (cons (evaluate (car exps) env)
            (evlis (cdr exps) env) )
      '() ) )
}

После неё отрабатывает функция~◊ic{invoke},
которая применяет свой первый аргумент (функцию; если это не~так, она сообщает об~ошибке)
— ко~второму (списку её аргументов) и возвращает результат вычислений.
В~общем, ◊ic{invoke} похожа на привычную ◊ic{apply},
только требует явного указания окружения.
(Далее в~разделе~◊ref{basics/sect:representing-functions}
◊seePage{basics/sect:representing-functions}
мы~рассмотрим подробнее непростые взаимоотношения функций и~окружений.)
