◊section{Вычисления}◊label{basics/sect:evaluation}

◊indexC{eval}
◊indexR{вычислитель}
Важнейшая часть интерпретатора Лиспа находится в~одной функции, вокруг которой
крутится все остальное. Эта функция, называемая ◊ic{eval}, принимает на вход
программу, а на выходе даёт результат её исполнения. Явное наличие исполнителя
кода отнюдь не~случайно, а, наоборот, является характерной и намеренно
реализованной чертой Лиспа.

◊indexR{язык!универсальный}
◊indexR{универсальный язык}
◊indexR{машина Тьюринга}◊indexR{Тьюринга, машина}
Язык программирования называется ◊term{универсальным}, если он не~уступает
в~выразительных возможностях машине Тьюринга. Так как машина Тьюринга довольно
примитивна, то несложно разработать язык, который~бы удовлетворял этому условию;
действительно, сложнее будет придумать язык, который был~бы полезным, но при
этом не~был~бы полным по~Тьюрингу.

◊indexR{тезис Чёрча}◊indexR{Чёрча, тезис}
В~соответствии с~тезисом Чёрча, любая вычислимая функция может быть записана на
любом тьюринг-полном языке. Интерпретатор Лиспа можно представить как такую
функцию, которая принимает программы и возвращает результаты их исполнения. Так
что если такая функция вообще существует, её можно записать на любом
тьюринг-полном языке. Следовательно, функцию-вычислитель Лиспа ◊ic{eval} можно
записать в~частности на том~же самом Лиспе. В~этом нет никаких противоречий,
точно так~же, к~примеру, можно реализовать Фортран на~Фортране.

Но~что делает Лисп уникальным (и~оправдывает явное описание ◊ic{eval}), так это
небольшой размер кода интерпретатора: обычно от~одной до~двадцати страниц
в~зависимости от детализации.◊footnote*{Интерпретатор, описываемый в~этой главе,
занимает около 150~строк.} Это результат желания сделать язык последовательным,
с~минимальным количеством исключений из правил, и, что самое главное, с~простым,
но выразительным синтаксисом.

◊indexCS{eval}{свойства}
Сам факт существования ◊ic{eval}, а также возможность её описания на Лиспе
имеют несколько интересных следствий.
◊begin{itemize}
  ◊item Можно изучить Лисп или прочитав руководство (в~котором описываются
        все доступные функции), или изучив собственно функцию~◊ic{eval}.
        Второй подход сложен тем, что надо уже знать Лисп для того, чтобы
        понять описание ◊ic{eval}; но ведь знание Лиспа по~идее должно быть
        ◊emph{следствием} изучения ◊ic{eval}, нежели ◊emph{предпосылкой} для
        него. На~самом деле, достаточно знать лишь ту часть Лиспа, которая
        используется для описания ◊ic{eval}. Кроме того, язык, определяемый
        одной ◊ic{eval}, не~является всем Лиспом: он есть лишь сутью языка,
        в~нём реализованы только специальные формы и немного примитивных
        функций.

        Тем не~менее, в~возможности изучать язык двумя разными, но всё~же
        связанными путями лежит несомненный плюс Лиспа.

  ◊item Тот факт, что ◊ic{eval} написана на Лиспе, значит также и то, что
        среда разработки является составной частью языка и не~требует
        значительных накладных расходов. Под средой разработки понимаются
        такие вещи как отладчик, трассировщик или возможность обратного
        хода ◊cite{lie87}. Практически, реализация таких инструментов —
        это лишь доработка ◊ic{eval}, к~примеру, чтобы она выводила
        сообщения при вызове функций, приостанавливала вычисления
        в~интересующих местах и~так~далее.

        Долгое время среда разработки с~такими возможностями была уникальной
        для Лиспа. Но и сегодня то, что ◊ic{eval} может быть описана на самом
        Лиспе, даёт возможность легко экспериментировать с~новыми вариантами
        реализации вычислений или~отладки.

  ◊item Наконец, сама по себе ◊ic{eval} способна быть инструментом
        программирования. Достаточно спорным инструментом, так как
        использование ◊ic{eval} требует присутствия в~памяти целого
        интерпретатора или компилятора во~время исполнения кода; но ещё
        более серьёзной проблемой является невозможность применения в~таком
        случае некоторых оптимизаций. Другими словами, использование
        ◊ic{eval} имеет свою цену. В~некоторых случаях её использование
        полностью оправдано, к~примеру, когда Лисп используется для описания
        и реализации метаязыков.

        Кроме ощутимой стоимости использования, семантика ◊ic{eval} часто
        неоднозначна. Именно поэтому она вообще не~входила в~стандарт до
        ревизии ◊RnRS~◊cite{cr91b,kcr98}. ◊seePage[chapter:reflection]
◊end{itemize}


◊section{Базовый вычислитель}◊label{basics/sect:basic-evaluator}

◊indexR{переменные!свободные}◊indexR{переменные!связанные}
◊indexR{свободные переменные}
◊indexR{связывающие формы}◊indexR{форма!связывающая}
◊indexR{окружение}
◊indexC{evaluate}
Будем различать в~программе ◊term{свободные} и ◊term{связанные переменные}.
Переменная свободна, если ни~одна связывающая форма (вроде ◊ic{let} или
◊ic{lambda}) не~связывает её с~каким-либо значением. В~противном случае она
называется связанной. Соответственно, свободные переменные могут иметь любое
значение, и нельзя определённо сказать, какое именно, не~выходя за рамки
функции. Структура данных, которая связывает переменные с~их значениями,
называется ◊term{окружением}. Таким образом, функция ◊ic{evaluate}◊footnote{Как
вы знаете, «родная» функция-вычислитель Scheme называется ◊ic{eval}. Чтобы их
не~путать, нашу функцию мы назовём ◊ic{evaluate}. По тем~же причинам местный
аналог ◊ic{apply} будет называться ◊ic{invoke}. Меньше перекрытий имён —
меньше проблем.} имеет два аргумента: программу и окружение, в~котором она
должна быть исполнена:

◊begin{code:lisp}
(define (evaluate exp env) ... )
◊end{code:lisp}


◊section{Вычисляем атомы}◊label{basics/sect:evaluating-atoms}

Одна из ключевых особенностей Лиспа состоит в~том, что программы записываются
теми~же конструкциями, что и остальные данные. Но так как любая запись
подразумевает определённые условности, поговорим о~таких условностях для записи
программ. Главные соглашения: переменные записываются символами (своими
именами), а вызовы функций — списками, где первый элемент — это вызываемая
функция, а остальные — её аргументы.

◊indexR{атом}
Как и любой другой компилятор, ◊ic{evaluate} начинает свою работу
с~синтаксического анализа переданного ей выражения, чтобы выяснить, что именно
оно означает. В~этом смысле, название раздела не~совсем правильное: мы
рассматриваем не~буквально вычисление атомов, а интерпретацию программ,
состоящих из атомов. Сейчас важно отличать саму программу от её представления
(письмо от листа бумаги, на котором оно написано). Функция~◊ic{evaluate}
работает с~представлением программ, по нему она узнаёт предписываемые программой
действия и выполняет~их.

% ◊ForLayout{display}
◊begin{minipage}{◊textwidth - ◊parindent}
◊indexC{atom"?}
◊begin{code:lisp}
(define (evaluate exp env)
  (if (atom? exp)   ; ◊ic{(atom? exp)} {◊equals} ◊ic{(not (pair? exp))}
      ...
      (case (car exp)
        ...
        (else ...) ) ) )
◊end{code:lisp}
◊end{minipage}

Если выражение не~является списком, то это скорее всего символ, или число, или
какая-нибудь строка. Если это всё~же символ, то он представляет
◊term{переменную}, а её значение хранится в~окружении:

◊begin{code:lisp}
(define (evaluate exp env)
  (if (atom? exp)
      (if (symbol? exp) (lookup exp env) exp)
      (case (car exp)
        ...
        (else ...) ) ) )
◊end{code:lisp}

Функция~◊ic{lookup} (которая рассматривается подробнее на
странице~◊pageref{basics/sect:repr-the-env}) знает, как отыскать значение
переменной в~окружении. Вот её прототип:

◊indexC{lookup}
◊begin{code:lisp}
(lookup |◊ii{переменная}| |◊ii{окружение}|) |◊is| |◊ii{значение}|
◊end{code:lisp}

◊indexR{переменные!связь с~символами}
◊indexR{символы!связь с~переменными}
Как видим, здесь происходит неявное преобразование символа в~переменную. Если
быть более дотошным, тогда вместо ◊ic{(lookup exp env)} надо записать что"~то
вроде:

◊begin{code:lisp}
... (lookup (symbol->variable exp) env) ...
◊end{code:lisp}

◊indexR{приведение типов}
◊indexR{объекты!второго класса}
В~таком случае мы явно говорим, что символ~◊ic{exp}, чьим значением является имя
переменной, должен быть превращён в~переменную. Также это подчёркивает тот факт,
что функция ◊ic{symbol->variable}◊footnote{Лично я не~люблю называть функции
приведения типов ◊ic{◊ii{x}"~>◊ii{y}}, потому что так сложнее понимать цепочки
преобразований. Запись ◊ic{(◊ii{y}"~>◊ii{z}(◊ii{x}"~>◊ii{y} ...))} не~так
очевидна, как ◊ic{(◊ii{z}<"~◊ii{y}(◊ii{y}<"~◊ii{x} ...))}. Хотя, с~другой
стороны, одиночная запись ◊ic{◊ii{z}<"~◊ii{y}} не~так легко читается, как
◊ic{◊ii{y}"~>◊ii{z}}. Приходится выбирать.} вовсе не~переводит ◊ic{exp} сам
в~себя; она превращает синтаксическую сущность (символ) в~семантическую
(переменную). В~действительности, переменные — это лишь воображаемые объекты,
которым язык и программист дали какие"~то имена, и которые ради удобства
используются в~форме имён. Способ представления имён также выбран из соображений
удобства, так как Лисп имеет базовый тип символов. В~данном случае
◊ic{symbol->variable} ничего не~делает, хотя на самом деле могла бы применяться
какая-нибудь другая форма записи имени переменной, например: строка, состоящая
из знака доллара и имени переменной; в~этом случае, конечно~же,
◊ic{symbol->variable} будет сложнее.

Если бы переменные действительно были лишь воображаемыми, то ◊ic{lookup}
не~знала~бы как обрабатывать свой первый аргумент, так как она ожидает нечто
«материальное». Так что нам надо преобразовать переменную в~её программное
представление, какой-нибудь уникальный ключ, по которому ◊ic{lookup} сможет
отыскать переменную в~окружении. Так что ещё точнее было~бы записать:

◊ForLayout{display}{◊begingroup
◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊begin{code:lisp}
... (lookup (variable->key (symbol->variable exp)) env) ...
◊end{code:lisp}

◊ForLayout{display}{◊endgroup}

Однако, врождённая лень лисперов настаивает на использовании символов для
ключей. Так что ◊ic{variable"~>key} — это лишь обратная функция
к~◊ic{symbol◊discretionary{->}{}{->}variable}, и их последовательное применение
никак не~изменяет~◊ic{exp}.

◊indexR{автоцитирование}◊indexR{механизм автоцитирования}
Если выражение атомарное (то~есть не~является списком) и не~является символом,
то соблазнительно его считать представлением какой-нибудь константы
с~соответствующим значением. Такое поведение называется механизмом
◊term{автоцитирования}. Автоцитируемый объект не~требует явного цитирования и
имеет собственное значение. За примерами можно обратиться к~◊cite{cha96}.

Но является~ли такое поведение правильным? Во-первых, не~всегда атомарные
объекты обозначают сами себя. Например, строка ◊ic{"a?b:c"} могла~бы означать
вызов компилятора~Си, затем вызов получившейся программы и подстановку
возвращаемого ей значения вместо этой строки.

С~другими объектами (вроде функций) вообще не~понятно, как именно их
◊emph{вычислять}. К~примеру, ясно, что значением переменной ◊ic{car} является
функция, возвращающая левый элемент пары, но что является значением самой
функции ◊ii{car}? Чаще всего попытки вычисления значения функции считаются
ошибочными.

◊indexC{()}◊indexR{пустой список, ◊protect◊ic{()}}
Другой пример проблемного значения — пустой список~◊ic{()}. Судя по тому, что
это список, он должен означать вызов функции. Вот только в~нём нет
ни~аргументов, ни~самой функции. Такая запись в~Scheme запрещена и является
синтаксической ошибкой.

Поэтому необходимо очень аккуратно анализировать программу и автоцитировать
только те данные, для которых это явно стоить делать, например: числа, строки
и~знаки. ◊seePage[basics/evaluating-forms/ssect:quoting] Так что мы записываем
следующее:

◊ForLayout{display}{◊begingroup
◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊begin{code:lisp}
(define (evaluate exp env)
  (if (atom? exp)
      (cond ((symbol? exp) (lookup exp env))
            ((or (number? exp) (string? exp) (char? exp)
                 (boolean? exp) (vector? exp) )
             exp )
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )
◊end{code:lisp}

◊ForLayout{display}{◊endgroup}

◊indexR{ошибки!варианты обработки}
◊indexC{wrong}
◊phantomlabel{basic/atoms/para:the-first-error}
В~этом фрагменте кода виден первый случай, когда могут возникнуть ошибки.
Большая часть лисп-систем имеет свои собственные механизмы обработки
исключительных ситуаций, которые непросто сделать переносимыми. В~случае ошибки
мы вызываем ◊ic{wrong}◊footnote{Заметьте, не~«функцию ◊ic{wrong}». Варианты её
реализации подробнее рассматриваются в~разделе~◊ref{compilation/sect:exception}.}
и передаём ей первым аргументом строку. В~строке находится текстовое описание
ошибки, а следующие за ней аргументы несут дополнительную информацию о~том, что
вызвало проблему. Системы с~зачаточным механизмом обработки ошибок обычно
в~случае проблем выдают какие"~то непонятные надписи вроде ◊ic{"Bus error: core
dumped"} и умирают. Другие останавливают текущие вычисления и возвращаются
к~диалоговому режиму. А~третьи могут связывать с~вычисляемым выражением
специальный обработчик исключений, который перехватит брошенный объект,
описывающий ошибку, и будет уже по нему решать, что делать дальше.
◊seePage[compilation/sect:exception] В~некоторых случаях даже реализуется
подобие экспертной системы, которая анализирует ошибку, вызвавший её код и
выдаёт пользователю варианты её исправления. В~общем, сложно сказать однозначно,
что следует делать в~случае ошибки.


◊section{Вычисляем формы}◊label{basics/sect:evaluating-forms}

◊indexR{специальные формы}
◊indexR{форма!специальная}
◊indexR{Лисп!специальные формы}
Каждый язык имеет некоторое количество «неприкасаемых» синтаксических
конструкций: их нельзя адекватно переопределить и вообще не~стоит трогать.
В~Лиспе такие конструкции называются ◊term{специальными формами}. Они
представляются списками, где первый элемент — это определённый символ,
принадлежащий множеству ◊term{специальных операторов} (или синтаксических
ключевых слов, как их называют в~Scheme).

◊indexR{функции!примитивы}
◊indexR{примитивы}
◊indexR{диалекты Лиспа}
Конкретный диалект Лиспа характеризуется набором специальных форм и библиотекой
примитивных функций (эти функции нельзя определить на самом диалекте, так как
они тесно связаны с~реализацией; например, для Scheme это~◊ic{call/cc}).

В~некотором понимании, Лисп является лишь прикладным $◊lambda$"=исчислением
вместе с~расширяющим его набором специальных форм. Специфика каждого конкретного
диалекта Лиспа лежит только в~этом наборе. В~Scheme используется минимальный
набор специальных операторов (◊ic{quote}, ◊ic{if}, ◊ic{set!} и~◊ic{lambda}),
тогда как {◊CommonLisp} (CLtL2~◊cite{ste90}) определяет более тридцати, описывая
таким образом случаи, когда может быть сгенерирован высокоэффективный машинный
код.

Так как специальные формы записываются буквально, то их синтаксический анализ
прост, хватит одного ◊ic{case}-выражения: надо лишь смотреть на первый элемент
списка. Если форма начинается не~со специального оператора, то она означает
применение функции. В~данный момент мы ограничимся лишь небольшим подмножеством
специальных форм: ◊ic{quote}, ◊ic{if}, ◊ic{begin}, ◊ic{set!} и ◊ic{lambda}.
(В~следующих главах мы введём другие, более специализированные формы.)

◊ForLayout{display}{◊begingroup
◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊indexC{evaluate}
◊begin{code:lisp}
(define (evaluate e env)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) ) e)
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (evaluate (cadr e) env)
                      (evaluate (caddr e) env)
                      (evaluate (cadddr e) env) ))
        ((begin)  (eprogn (cdr e) env))
        ((set!)   (update! (cadr e) env (evaluate (caddr e) env)))
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else     (invoke (evaluate (car e) env)
                          (evlis (cdr e) env) )) ) ) )
◊end{code:lisp}

◊ForLayout{display}{◊endgroup}

◊indexR{синтаксис!if@◊protect◊ic{if}}
Чтобы упростить определение, синтаксический анализ оставлен минимальным: мы
не~проверяем, правильно~ли записаны цитаты, действительно~ли ◊ic{if} передано
три аргумента◊footnote{◊ic{if} не~обязательно принимает условие и ровно две
альтернативы. К~примеру, в~Scheme и {◊CommonLisp} ◊ic{if} может принимать как
два, так и три аргумента; ◊ic{if} в~{◊EuLisp} и {◊ISLisp} исключительно
тернарный; {◊LeLisp} в~случае, если условие ложно, вычисляет остаток
формы~◊ic{if}, обернув его в~◊ic{begin}.} и~так~далее. Мы априори считаем
интерпретируемые программы синтаксически корректными.


◊subsection{Цитирование}◊label{basics/evaluating-forms/ssect:quoting}

◊indexC{quote}
◊indexE{M-выражения}◊indexE{S-выражения}
◊indexR{программы!как данные}◊indexR{значения!как программы}
◊indexR{цитаты}
Специальная форма ◊ic{quote} позволяет записать значение, которое без
цитирования было бы~спутано с~каким-нибудь выражением. Такой механизм необходим,
если программы тоже являются типом данных в~языке — надо~же как"~то
различать, где записана программа, а где данные. Если~бы был выбран другой
синтаксис, то эта проблема~бы не~возникла. К~примеру, изначально в~Лиспе
планировались M"=выражения ◊cite{mcc60} для записи действий над данными, а сами
данные должно были записываться S"=выражениями. Это решило~бы проблему
разделения кода и данных, но сделало~бы невозможными вменяемые макросы —
очень полезную вещь для расширения синтаксиса. Как~бы то ни~было, M"=выражения
долго не~прожили ◊cite{mcc78a}, программы и данные стали записываться
исключительно S"=выражениями. Поэтому в~Лиспе есть специальная форма ◊ic{quote},
служащая для разделения кода и данных.

Суть цитирования состоит в~возврате выражения, следующего за ключевым словом,
«как~есть», без его вычисления. Это чётко видно в~следующем фрагменте кода:

◊begin{code:lisp}
... (case (car e)
      ((quote) (cadr e)) ... ) ...
◊end{code:lisp}

◊indexR{цитаты!явные и неявные}
Также интересен вопрос: а есть~ли разница между явным и неявным цитированием,
например, между ◊ic{33} и ◊ic{'33}, или между◊footnote{Напомним: в~Scheme
запись ◊ic{◊#(...)} означает процитированный вектор.} ◊ic{◊#(fa do sol)} и
◊ic{'◊#(fa do sol)}? Если первое сравнение происходит между непосредственными
значениями и тут вроде~бы всё очевидно, то во~втором случае сравниваются
составные объекты (хоть для Лиспа они и являются формально атомами). Можно легко
придумать несколько возможных трактовок данного выражения. Цитирование
возвращает аргумент как значение, но сама запись ◊ic{◊#(fa do sol)} могла~бы
возвращать каждый раз новый вектор из трёх символов. Другими словами, ◊ic{◊#(fa
do sol)} могла~бы быть просто сокращённой записью выражения ◊ic{(vector 'fa 'do
'sol)}, которое, конечно~же, будет означать совсем иное, нежели ◊ic{'◊#(fa do
sol)}, и тем более ◊ic{(vector fa do sol)}. Мы вернёмся к~этой проблеме позже
◊seePage[assignment/sect:quotation], потому что, как видите, не~так просто
определиться, какой именно смысл придавать цитированию.


◊subsection{Ветвление}◊label{basics/evaluating-forms/ssect:alternatives}

◊indexC{if}
Вспомним, как работает условный оператор ◊ic{if}: эта форма вычисляет свой
первый аргумент (◊term{условие}), затем в~зависимости от результата вычислений
выбирает, возвращать значение второго аргумента (◊term{следствия}) или третьего
(◊term{альтернативы}). Эта идея выражается следующим кодом:

◊begin{code:lisp}
... (case (car e)
      ((if) (if (evaluate (cadr e) env)
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env) )) ... ) ...
◊end{code:lisp}

◊indexR{представление!логических значений}
◊indexR{логические значения}
Эта программа не~совсем точно учитывает представление логических значений. Явно
видно, что здесь смешиваются два языка: Scheme (или хотя бы что"~то неотличимо
похожее на него) и Scheme (или что"~то довольно похожее). Причём мы определяем
второй в~терминах первого. Так что между ними присутствуют примерно те~же
отношения, что и между Паскалем (на котором написана первая реализация~◊TeX) и
самой системой~{◊TeX} ◊cite{knu84}. Соответственно, нет ни~единого повода
считать способы представления логических значений в~этих языках одинаковыми.

Функция ◊ic{evaluate} возвращает значения определяемого языка. Они априори никак
не~связаны с~логическими значениями языка, используемого для реализации. Следуя
соглашению о~том, что любой объект, не~равный логической ◊term{лжи}, должен
считаться логической ◊term{истиной}, мы запишем:

◊begin{code:lisp}
... (case (car e)
      ((if) (if (not (eq? (evaluate (cadr e) env) the-false-value))
                (evaluate (caddr e) env)
                (evaluate (cadddr e) env) )) ... ) ...
◊end{code:lisp}

◊indexC{the-false-value}
Здесь считается, что переменная~◊ic{the-false-value} хранит значение ◊term{лжи}
определяемого языка, выраженное в~терминах определяющего. Вариантов выбора
такого представления много, например, сделаем так:

◊begin{code:lisp}
(define the-false-value (cons "false" "boolean"))
◊end{code:lisp}

В~этом случае всё будет замечательно, так как ◊ic{eq?} в~Scheme сравнивает
не~значения, а адреса, и, соответственно, любое другое значение никак нельзя
будет спутать со~значением переменной ◊ic{the-false-value}.

◊indexC{()}◊indexC{NIL}◊indexR{пустой список, ◊protect◊ic{()}}
Вопрос представления логических значений вовсе не~тривиален. В~истории Лиспа
полно споров на тему различий между булевым значением ◊term{ложь}, пустым
списком~◊ic{()} и символом~◊ic{NIL}. Наиболее чёткая позиция по этому вопросу:
◊term{ложь} это не~◊ic{()} (в~конце концов, это всего лишь пустой список), и они
оба тем более не~имеют никакого отношения к~символу, составленному из букв
◊ic{N}, ◊ic{I} и~◊ic{L}.

Такую позицию занимает и Scheme; об~этом всё~же смогли договориться за пару
недель до принятия стандарта~IEEE ◊cite{iee91}.

Так что в~Scheme теперь всё хорошо (разве что ◊ic{()} по-английски всё ещё
читается как~◊emph{nil}!). В~изначальном Лиспе ◊term{ложь}, ◊ic{()} и~◊ic{NIL}
— это один и тот~же символ. В~{◊LeLisp} ◊ic{NIL} это переменная со
значением~◊ic{()}, а пустой список (вместе с~пустым символом~◊ic{||})
используется в~качестве~◊term{лжи}.


◊subsection{Последовательность}◊label{basics/evaluating-forms/ssect:sequence}

◊indexC{begin}◊indexC{progn}
Существует специальная форма, позволяющая вычислить группу форм последовательно
и в~определённом порядке. Как и старые~добрые блоки ◊ic{begin ... end} из
семейства языков Алгола, в~Scheme эта форма называется ◊ic{begin}; в~других
Лиспах она обычно зовётся ◊ic{progn} — обобщенная версия ◊ic{prog1},
◊ic{prog2} {◊itd} Собственно организацию последовательности мы перепоручаем
функции~◊ic{eprogn}.

◊indexC{eprogn}
◊begin{code:lisp}
... (case (car e)
      ((begin) (eprogn (cdr e) env)) ... ) ...

(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env) )
          (evaluate (car exps) env) )
      '() ) )
◊end{code:lisp}

Такое определение последовательных вычислений не~допускает разночтений. Стоит
обратить внимание на хвостовую рекурсию при вычислении последней формы
последовательности. Вычисления построены так, что последний вызов ◊ic{evaluate}
заменяет собой всю рекурсивную цепочку вызовов ◊ic{eprogn}. (О~хвостовой
рекурсии мы позже поговорим подробнее.
◊seePage[escape/pr-cont/ssect:tail-recusion])

◊indexCS{begin}{возвращаемое значение}
◊indexR{возвращаемые значения!формы (begin)@формы ◊protect◊ic{(begin)}}
◊indexC{empty-begin}
Ещё одним интересным моментом является то, чт◊'{о} возвращается при вычислении
формы ◊ic{(begin)}. Сейчас это пустой список. Но почему именно ◊ic{()}, почему
не~что"~то другое, вроде ◊ic{:3} или ◊ic{(◊nya)}? Мы выбрали пустой список по
привычке, доставшейся в~наследство от Лиспа: в~любой непонятной ситуации
возвращай ◊ic{nil}. Но в~мире, где ◊term{ложь}, ◊ic{nil} и~◊ic{()} — это
совершенно различные вещи, что из них лучше подходит на роль ◊emph{ничего}?
Поэтому пусть в~нашем языке вычисление ◊ic{(begin)} будет возвращать специальное
значение ◊ic{empty-begin}, которое определяется как (почти) случайное число
◊ic{813}~◊cite{leb05}.

◊indexC{eprogn}◊indexC{empty-begin}
◊begin{code:lisp}
(define (eprogn exps env)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (evaluate (car exps) env)
                 (eprogn (cdr exps) env) )
          (evaluate (car exps) env) )
      empty-begin ) )

(define empty-begin 813)
◊end{code:lisp}

◊indexR{синтаксис!begin@◊ic{(begin)}}
◊indexC*{unspecified}{◊#<unspecified>}
Корни нашей проблемы в~том, что ◊ic{begin} ◊emph{обязана} вернуть какое"~то
значение. Как и Scheme, определяемый язык может не~придавать какого-либо смысла
форме ◊ic{(begin)}; мы можем или допускать такое написание и возвращать любое
удобное значение, или~же не~допускать и считать ошибкой. Идеальный вариант:
вообще не~использовать ◊ic{begin} без аргументов, так как не~определено, что
именно получится в~результате. Некоторые реализации имеют специальный объект:
◊ic{◊#<unspecified>}, который возвращается в~случае, когда нет ничего более
подходящего. Обычно единственное, что с~ним можно сделать — это вывести на
печать. (Не~следует путать этот объект с~псевдозначением у~неопределённых
переменных. ◊seePage[lisp1-2-omega/recusion/ssect:uninitialized])

◊bigskip

◊indexR{язык!чисто функциональный}
◊indexR{побочные эффекты}
Последовательное вычисление выражений бесполезно в~чисто функциональных языках
(где функции не~имеют побочных эффектов). Действительно, какой в~таком случае
смысл что"~то вычислять и не~использовать возвращаемые значения? Но иногда
в~этом может быть смысл. Представим себе игру, написанную на чисто
функциональном языке; очевидно, что вычисления занимают какое"~то время
вне~зависимости от того, используются~ли их результаты или нет; и нас может
интересовать именно этот «побочный эффект» — замедление работы, — а
не~получаемые результаты. Тогда можно последовательно что"~то вычислять,
например, чтобы скорость игры была адекватна рефлексам игрока (если только
компилятор не~посчитает себя самым умным и не~удалит «бесполезный» код).

◊indexCS{begin}{необходимость}
Так как в~Scheme есть операции ввода-вывода, которые имеют побочные эффекты, то
для нас есть смысл пользоваться формой ◊ic{begin}, потому как очевидно, что
лучше сначала задать вопрос (с~помощью ◊ic{display}), а потом прочитать ответ
(с~помощью ◊ic{read}), чем сделать наоборот. Здесь"~то как раз и нужно
упорядочить вычисления. Но не~только ◊ic{begin} может их упорядочивать.
Например, условный оператор может:

◊begin{code:lisp}
(if |$◊alpha$| |$◊beta$| |$◊beta$|) |◊eq| (begin |$◊alpha$| |$◊beta$|)
◊end{code:lisp}

◊phantomlabel{basics/forms/sequence/par:gensym-puzzle}
◊noindent
И~◊ic{lambda} тоже может◊footnote{Переменная ◊ii{void} не~должна быть свободной
в~$◊beta$. Это условие выполняется, если ◊ii{void} никогда не~встречается
в~$◊beta$. Обычно в~таком случае используется ◊ic{gensym}, чтобы получить
гарантированно уникальное имя переменной. ◊seeEx[basics/ex:no-gensym]}:

◊begin{code:lisp}
(begin |$◊alpha$| |$◊beta$|) |◊eq| ((lambda (|◊ii{void}|) |$◊beta$|) |$◊alpha$|)
◊end{code:lisp}

Как видно из этого примера, в~Scheme ◊ic{begin} не~является необходимой
специальной формой, так как её поведение можно проэмулировать с~помощью
функций благодаря тому, что при вызове функции её аргументы вычисляются перед
исполнением тела (передача аргументов ◊term{по значению}).


◊subsection{Присваивание}◊label{basics/evaluating-forms/ssect:assignment}

◊indexC{set"!}
◊indexR{присваивание}
◊indexR{соглашения именования!побочных эффектов}
Как и во~многих других языках, в~нашем диалекте значения переменных можно
менять. Изменение значения переменной называется ◊term{присваиванием}. Так как
значение переменной надо изменять в~её окружении, то мы оставляем эту проблему
функции~◊ic{update!}.◊footnote*{В~соответствии с~принятым в~Scheme соглашением,
имена функций с~побочными эффектами оканчиваются на восклицательный знак.} Её
настоящая суть объясняется позже, на
странице~◊pageref{assignment/implementation/ssect:environment}.

◊begin{code:lisp}
... (case (car e)
      ((set!) (update! (cadr e) env
                       (evaluate (caddr e) env))) ... ) ...
◊end{code:lisp}

Присваивание выполняется в~два шага: сначала вычисляется новое значение, потом
новое значение заменяет старое. Стоит заметить, что обновлённая переменная
не~является значением данной формы. Мы ещё вернёмся к~вопросу о~возвращаемом
значении операции присваивания. ◊seePage[chapter:assignment] Пока только
запомните, что стандартом оно не~определено.


◊subsection{Абстракция}◊label{basics/evaluating-forms/ssect:abstraction}

◊indexR{абстракция}
Функции (также называемые ◊term{процедурами} в~Scheme) являются результатом
вычисления специальной формы ◊ic{lambda}, чьё имя ссылается на понятие
◊term{абстракции} в~$◊lambda$"=исчислении. Работу по созданию функции мы
поручаем функции~◊ic{make-function}, которой передаём всё необходимое: список
аргументов, тело функции и текущее окружение.

◊begin{code:lisp}
... (case (car e)
      ((lambda) (make-function (cadr e) (cddr e) env)) ... ) ...
◊end{code:lisp}


◊subsection{Аппликация}◊label{basics/evaluating-forms/ssect:application}

◊indexR{аппликация}
◊indexR{комбинация}
◊indexR{терм!функциональный}
◊indexR{функциональный терм}
Если первый элемент списка не~является специальным оператором, то такой список
означает применение функции, которое в~$◊lambda$"=исчислении называется
◊term{аппликацией} или ◊term{комбинацией}. Функция, полученная в~результате
вычисления первого элемента, применяется к~аргументам, которые мы получим,
вычислив остальные элементы списка. Эти действия описываются следующим кодом:

◊begin{code:lisp}
... (case (car e)
      (else (invoke (evaluate (car e) env)
                    (evlis (cdr e) env) )) ) ...
◊end{code:lisp}

Вспомогательная функция~◊ic{evlis} принимает список выражений и возвращает
список соответствующих им значений. Она определяется следующим образом:

◊indexC{evlis}
◊begin{code:lisp}
(define (evlis exps env)
  (if (pair? exps)
      (cons (evaluate (car exps) env)
            (evlis (cdr exps) env) )
      '() ) )
◊end{code:lisp}

Далее работает функция~◊ic{invoke}, которая применяет свой первый аргумент
(функцию; если это не~так, она сообщает об~ошибке) ко~второму (списку её
аргументов) и возвращает результат вычислений. В~общем, ◊ic{invoke} похожа на
привычную ◊ic{apply}, разве что требует явного указания окружения. (Далее
в~разделе~◊ref{basics/sect:representing-functions}
◊seePage[basics/sect:representing-functions] мы рассмотрим подробнее непростые
взаимоотношения функций и~окружений.)


◊subsubsection{◊texorpdfstring{Ещё~немного об~◊protect◊ic{evaluate}}%
{Ещё немного об evaluate}}

◊indexR{порядок вычислений!термов аппликации}
Рассмотренное описание языка является более-менее точным. Мы не~разобрали лишь
несколько вспомогательных функций: ◊ic{lookup} и ◊ic{update!}, отвечающие за
окружения, и ◊ic{make-function} вместе с~◊ic{invoke}, занимающиеся функциями.
Но даже сейчас нам уже многое известно об~◊ic{evaluate}. Например, наш диалект
имеет единое пространство имён, понятие объекта в~нём распространяется вообще
на всё (как в~◊Lisp1 ◊seePage[chapter:lisp1-2-omega]), в~том числе и на функции.
Но мы до сих пор не~знаем порядок вычисления аргументов.

В~нашем случае он зависит от порядка вычисления аргументов у~◊ic{cons}, которая
используется в~◊ic{evlis}. Но мы легко можем указать любой понравившийся нам
порядок, например, слева направо:

◊begin{code:lisp}
(define (evlis exps env)
  (if (pair? exps)
      (let ((argument1 (evaluate (car exps) env)))
        (cons argument1 (evlis (cdr exps) env)) )
      '() ) )
◊end{code:lisp}

Без введения новых специальных конструкций◊footnote{Как известно, ◊ic{let} —
это всего лишь простой макрос: ◊ic{(let (($x$ $◊pi_1$)) $◊pi_2$)} {◊eq}
◊ic{((lambda ($x$) $◊pi_2$) $◊pi_1$)}.} мы уточнили поведение определяемого
языка. Первая часть книги направлена именно на это: уточнение определяемого
языка с~помощью всё более ограниченных возможностей, что снижает зависимость
описания от языка, используемого для определения.


◊section{Представление окружений}◊label{basics/sect:repr-the-env}

◊indexE{A-список}◊indexR{А-список}
◊indexR{ассоциативный список}
Окружения связывают переменные с~их значениями. Обычно в~Лиспе подобные связи
представляются ◊term{ассоциативными списками}, также называемыми
◊term{А-списками}. Мы тоже будем представлять окружения как~А-списки,
связывающие переменные и значения. Для простоты имена переменных будем
представлять символами.

Таким образом, функции ◊ic{lookup} и ◊ic{update!} определяются элементарно:

◊ForLayout{display}{◊begingroup
◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊indexC{lookup}
◊begin{code:lisp}
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (cdar env)
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )
◊end{code:lisp}

Тут мы видим второй тип◊footnote{Первый — это синтаксические ошибки
(стр.~◊pageref{basic/atoms/para:the-first-error}).} возможных ошибок,
появляющихся при попытке узнать значение неизвестной переменной. Мы опять лишь
вызовем ◊ic{wrong}, чтобы сообщить о~проблеме наверх.

◊indexR{автоцитирование}
Когда компьютеры были большими, а память была маленькой,◊footnote*{Память
(вместе с~подсистемами ввода-вывода) всё ещё остаётся одной из наиболее дорогих
частей компьютера, хоть и постоянно дешевеет.} для переменных часто применялось
◊term{автоцитирование}. Если с~переменной не~было связано какое-либо значение,
то этим значением становился символ с~именем переменной. Было~бы очень обидно
видеть, как понятия переменной и символа, которые мы так усердно разделяли,
опять смешиваются и перепутываются.

Хотя это несомненно удобно — никогда не~вызывать ошибок, но такой идеальный
мир имеет большой недостаток: задача программы не~в~том, чтобы работать без
ошибок, а в~том, чтобы выполнять то, для чего она предназначена. В~этом смысле
ошибки играют роль перил: если мы на них натыкаемся, то это значит, мы идём
куда"~то не~туда. Ошибки должны быть обнаружены как можно раньше, чтобы как
можно быстрее их исправить. Следовательно, использование автоцитирования —
плохое решение, потому что оно скрывает некоторые ошибки, которые могли~бы быть
исправлены раньше.

Функция~◊ic{update!} изменяет окружение, так что, скорее всего, тоже может
вызвать такую~же ошибку: нельзя изменить значение неизвестной переменной. Мы
обсудим, следует~ли ей так поступать, когда будем говорить о~глобальном
окружении.

◊indexC{update"!}
◊begin{code:lisp}
(define (update! id env value)
  (if (pair? env)
      (if (eq? (caar env) id)
          (begin (set-cdr! (car env) value)
                 value)
          (update! id (cdr env) value) )
      (wrong "No such binding" id) ) )
◊end{code:lisp}

◊ForLayout{display}{◊endgroup}

◊indexCS{set"!}{возвращаемое значение}
◊indexR{присваивание!возвращаемое значение}
◊indexR{возвращаемые значения!присваивания}
Возвращаемое значение функции~◊ic{update!} выбрано с~учётом того, что это
значение станет значением всего выражения присваивания. В~Scheme это значение
не~определено. Строго говоря, программам не~следует полагаться на какое"~то
значение, но, тем не~менее, мы вынуждены выбирать, что именно будем возвращать
в~нашем случае. Например:

◊begin{enumerate}
  ◊item только что присвоенное значение (так сделано сейчас);

  ◊item предыдущее значение переменной (могут быть проблемы
        с~инициализацией, первым присваиванием);

  ◊item ◊indexC*{UFO}{◊#<UFO>}◊label{basics/s:env/ufo}
        объект «неопределённое значение», некий ◊ic{◊#<UFO>},
        используемый исключительно как индикатор неопределённого
        значения;

  ◊item значение формы с~неопределённым значением, вроде
        ◊ic{set-cdr!} в~Scheme.
◊end{enumerate}

◊indexR{окружение!как тип данных}
Окружения — это составной абстрактный тип данных. Мы уже можем извлекать и
изменять их части с~помощью соответствующих функций; но ещё надо уметь
создавать новые окружения и добавлять в~них новые части.

◊indexR{окружение!начальное}
Изначально в~окружении ничего нет. Это записывается просто:

◊indexC{env.init}
◊begin{code:lisp}
(define env.init '())
◊end{code:lisp}

(Чуть позже, в~разделе~◊ref{basics/sect:representing-functions}, мы сделаем его
не~таким необитаемым.)

Когда вызывается функция, для неё создаётся новое окружение, в~котором её
аргументы связаны со~своими фактическими значениями. Функция~◊ic{extend}
расширяет окружение~◊ic{env} переменными~◊ic{variables} с~соответствующими
значениями~◊ic{values}.

◊indexC{extend}
◊begin{code:lisp}
(define (extend env variables values)
  (cond ((pair? variables)
         (if (pair? values)
             (cons (cons (car variables) (car values))
                   (extend env (cdr variables) (cdr values)) )
             (wrong "Too few values") ) )
        ((null? variables)
         (if (null? values)
             env
             (wrong "Too many values") ) )
        ((symbol? variables) (cons (cons variables values) env)) ) )
◊end{code:lisp}

◊indexR{список аргументов}
◊indexR{синтаксис!списка аргументов}
◊indexR{переменные!точечные}
◊indexR{точечные переменные}
Главная сложность состоит в~том, что нам надо проанализировать все варианты
записи <◊ii{списка аргументов}>, какие разрешены в~Scheme.◊footnote*{Некоторые
лисп-системы, вроде ◊CommonLisp, поддались соблазну расширить синтаксис перечня
аргументов ключевыми словами вроде ◊ic{◊&aux}, ◊ic{◊&key}, ◊ic{◊&rest}. Но это
сильно усложняет синтаксический разбор и связывание. Иные системы позволяют даже
обобщённое указание аргументов с~помощью шаблонов~◊cite{sj93}.} Список
аргументов может быть представлен не~только обычным списком символов, но и
точечным: заканчивающимся не~на~◊ic{()}, а на определённый символ
(◊term{точечную переменную}). Более формально список аргументов описывается
следующей грамматикой:

◊begin{center}◊setlength{◊tabcolsep}{2pt}◊begin{tabular}{rcl}
  <◊ii{список аргументов}> &  ::=  & ◊ic{()}                                  ◊◊
                           &   |   & <◊ii{переменная}>                        ◊◊
                           &   |   & ◊ic{({◊normalfont<◊ii{переменная}>}
                                    . {◊normalfont<◊ii{список аргументов}>})} ◊◊
         <◊ii{переменная}> & $◊in$ & ◊Vset{Символы}
◊end{tabular}◊end{center}

Когда мы расширяем окружение, количество значений переменных должно
соответствовать количеству их имён. Обычно их поровну, но если список
оканчивается на точечную (или~◊term{n"~арную}) переменную, то она связывается
со~списком всех оставшихся аргументов. Как~бы то ни~было, возможны две ошибки:
или значений больше, чем переменных, или наоборот.


◊section{Представление функций}◊label{basics/sect:representing-functions}

Наверное, проще всего представлять функции с~помощью функций. Естественно, это
не~тавтология, и читать следует так: «функции определяемого языка проще всего
представлять функциями языка определения». Это сильно упрощает механизм вызова:
функция~◊ic{invoke} должна лишь проверить, действительно~ли её первый аргумент
является функцией: чем"~то, что можно вызвать.

◊indexC{invoke}
◊begin{code:lisp}
(define (invoke fn args)
  (if (procedure? fn) (fn args)
      (wrong "Not a function" fn) ) )
◊end{code:lisp}

Проще некуда. Даже может возникнуть вопрос, зачем вообще нужна отдельная
функция, когда весь этот код можно было встроить сразу в~◊ic{evaluate}. Причина,
по которой так сделано, в~том, что мы показываем структуру будущих
интерпретаторов, а в~них ◊ic{invoke} будет уже не~такой простой. Кстати,
попробуйте сейчас выполнить упражнения~◊ref{basics/ex:def-call/cc}
и~◊ref{basics/ex:def-apply}.

◊indexR{аппликация!порядок вычисления термов}
◊indexR{порядок вычислений!термов аппликации}
Также у~нас появляется новый тип ошибок, возникающих при попытке вызвать
невызываемое. Сейчас мы обрабатываем такие ошибки в~момент применения функции
к~уже вычисленным аргументам, но мы могли~бы предупреждать пользователя раньше.
В~таком случае нам необходимо задать порядок вычисления элементов формы вызова
функции:

◊begin{enumerate}
  ◊item вычислить элемент на месте функции;

  ◊item если это не~функция, сообщить об~ошибке;

  ◊item вычислить аргументы слева направо;

  ◊item сравнить количество аргументов с~арностью функции
        и, если они не~совпадают, то сообщить об~ошибке.
◊end{enumerate}

Вычислять аргументы слева направо кажется логичным для людей, читающих слева
направо. Это и запрограммировать легче, в~итоге порядок прост и понятен.
Сложности возникают только у~компилятора, потому что если ему захочется поменять
этот порядок (например, чтобы эффективнее использовать регистры процессора), то
он будет вынужден доказать, что это не~изменит смысла программы.

Конечно, мы могли бы действовать эффективнее, проверяя арность ещё раньше:

◊begin{enumerate}
  ◊item вычислить элемент на месте функции;

  ◊item если это не~функция, сообщить об~ошибке, иначе запомнить ожидаемое
        количество аргументов;

  ◊item вычислять аргументы слева направо до тех пор, пока их количество
        согласуется с~арностью функции, в~случае проблем сообщить об~ошибке;

  ◊item применить функцию к~аргументам.◊footnote*{Функция могла бы потом
        ещё проверять на правильность типы переданных аргументов, но это
        не~имеет отношения к~механизму вызова.}
◊end{enumerate}

Стандарт {◊CommonLisp} требует, чтобы аргументы вычислялись строго слева
направо, но с~целью оптимизации позволяет вычислять функциональный элемент
списка до или после остальных.

Scheme~же не~накладывает условий на порядок вычисления всех элементов формы
вызова функции, включая сам элемент-функцию. Так как ограничений нет, то
компилятор волен выбирать любой устраивающий его порядок.
◊seePage[denotational/sect:eval-order] А~пользователь, в~свою очередь, не~может
рассчитывать на какой-либо определённый порядок вычислений и должен использовать
◊ic{begin}, чтобы задать необходимый порядок явно.

Считается плохим стилем использовать вызовы функций, чтобы получить побочные
эффекты в~нужной последовательности. Поэтому следует избегать выражений вроде
◊ic{(f (set! f $◊pi$) (set! f $◊pi'$))}, где неясно, какая~же функция будет
вызвана на самом деле. Ошибки, возникающие в~подобных случаях, очень сложно
отлавливать.


◊subsection*{Окружение исполнения~функций}

◊indexR{окружение!исполнения тела функции}
Применение функции сводится к~вычислению выражений, составляющих её тело,
в~окружении, где аргументы функции связаны со~значениями, переданными при вызове
функции. Вспомните, что при вызове ◊ic{make-function} мы передали всё
необходимое для этого, находящееся в~распоряжении ◊ic{evaluate}. В~оставшейся
части этого раздела мы будем разбирать используемые при вычислениях окружения,
в~программах они будут набраны ◊ii{курсивом}.


◊subsubsection{Минимальное окружение}

Для начала рассмотрим минимально возможное окружение:

◊indexC{make-function}
◊begin{code:lisp}
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend |◊ii{env.init}| variables values)) ) )
◊end{code:lisp}

◊indexE{K@◊protect◊comb{K}, комбинатор}
◊indexR{комбинаторы!K@◊protect◊comb{K}}
В~строгом соответствии с~ранее описанным соглашением, тело функции вычисляется
в~окружении, где аргументы функции связаны с~переданными значениями. Например,
получив в~результате вызова ◊ic{make-function} комбинатор~◊comb{K}, определяемый
как ◊ic{(lambda (a~b) a)}, мы можем его вызвать следующим образом:

◊begin{code:lisp}
(K 1 2) |◊is| 1
◊end{code:lisp}

Но есть и неприятность: функция может использовать только свои аргументы и
локальные переменные, потому что мы определили ◊ii{env.init} как пустое
окружение. В~нём нет даже базовых функций из глобального окружения вроде
◊ic{car} или ◊ic{cons}.


◊subsubsection{Улучшенное окружение}

Хорошо, попробуем улучшить наше определение следующим образом:

◊begin{code:lisp}
(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend |◊ii{env.global}| variables values)) ) )
◊end{code:lisp}

Замечательно, теперь наши функции имеют доступ к~глобальному окружению и всем
его функциям. А~что если мы попробуем определить взаимно рекурсивные функции?
Также, какой результат даст программа слева (справа она~же с~раскрытыми
макросами)?

{◊def◊E{◊hbox to 0pt{◊kern0.3em$◊equals$}}
◊begin{code:lisp}
(let ((a 1))            ((lambda (a)
  (let ((b (+ 2 a)))       ((lambda (b)
    (list a b) ) )   |◊E|         (list a b) )
                            (+ 2 a) ) )
                         1 )
◊end{code:lisp}}

Давайте рассмотрим по шагам, как вычисляется это выражение:

◊begin{code:lisp}
((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)|◊begin{where}
                                                   ◊- ◊ii{env.global}
                                                   ◊end{where}|
|◊equals| ((lambda (b) (list a b)) (+ 2 a))|◊begin{where}
                                            ◊- a {◊is} 1
                                            ◊- ◊ii{env.global}
                                            ◊end{where}|
|◊equals| (list a b)|◊begin{where}
                     ◊- b {◊is} 3
                     ◊- ◊ii{env.global}
                     ◊end{where}|
◊end{code:lisp}

Тело внутренней функции ◊ic{(lambda (b) (list a~b))} выполняется в~окружении,
полученном расширением глобального окружения переменной~◊ic{b}. Всё верно. Но
в~этом окружении нет необходимой переменной~◊ic{a}!


◊subsubsection{Улучшенное окружение (вторая~попытка)}

Так как нам надо видеть переменную~◊ic{a} во~внутренней функции, то достаточно
будет передать ◊ic{invoke} текущее окружение, а она в~свою очередь передаст его
вызываемой функции. Чтобы реализовать эту идею, надо немного подправить
◊ic{evaluate} и ◊ic{invoke}; чтобы не~путать эти определения с~предыдущими,
пусть они начинаются на~◊ic{d.}:

◊indexC{d.evaluate}
◊indexC{d.invoke}
◊indexC{d.make-function}
◊begin{code:lisp}
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )

(define (d.make-function variables body |◊ii{def.env}|)
  (lambda (values |◊ii{current.env}|)
    (eprogn body (extend |◊ii{current.env}| variables values)) ) )
◊end{code:lisp}

В~этом определении стоит заметить, что передача окружения определения ◊ic{env}
через переменную~◊ii{def.env} бессмысленна, так как при вызове используется лишь
текущее окружение ◊ii{current.env}.

◊indexR{стек!вызовов}
Давайте теперь ещё раз рассмотрим пример, приведённый выше. Сейчас переменные
не~пропадают:

◊begin{code:lisp}
((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)|◊begin{where}
                                                   ◊- ◊ii{env.global}
                                                   ◊end{where}|
|◊equals| ((lambda (b) (list a b)) (+ 2 a))|◊begin{where}
                                            ◊- a {◊is} 1
                                            ◊- ◊ii{env.global}
                                            ◊end{where}|
|◊equals| (list a b)|◊begin{where}
                     ◊- b {◊is} 3
                     ◊- a {◊is} 1
                     ◊- ◊ii{env.global}
                     ◊end{where}|
◊end{code:lisp}

Заодно мы явно видим ◊emph{стек вызовов}: каждая связывающая форма сначала
укладывает свои новые переменные поверх текущего окружения, а потом убирает их
оттуда после окончания вычислений.


◊subsubsection{Исправляем проблему}

Но даже при таком определении всё ещё есть проблемы. Рассмотрим следующий
пример:

◊begin{code:lisp}
(((lambda (a)
     (lambda (b) (list a b)) )
  1 )
 2 )
◊end{code:lisp}

Функция~◊ic{(lambda (b) (list a~b))} создаётся в~окружении, где ◊ic{a} связана
со~значением~◊ic{1}, но в~момент вызова в~окружении будет присутствовать
только~◊ic{b}. Таким образом, мы опять потеряли переменную~◊ic{a}.

Без сомнения, вы заметили, что в~определении ◊ic{d.make-function} присутствуют
два окружения: окружение определения ◊ii{def.env} и окружение исполнения
◊ii{current.env}. В~жизни функции есть два важных события: её создание и
её~вызов(ы). Очевидно, что создаётся функция только однажды, а вызываться может
несколько раз; или вообще никогда не~вызываться. Следовательно,
единственное◊footnote{На~самом деле, здесь можно использовать любое необходимое
окружение. См.~про форму~◊ic{closure} на
странице~◊pageref{assignement/assignement/para:closure}.} окружение, которое мы
однозначно можем связать с~функцией, — это окружение, в~котором она была
создана. Вернёмся к~исходным определениям функций ◊ic{evaluate} и ◊ic{invoke},
но в~этот раз функцию~◊ic{make-function} запишем следующим образом:

◊indexC{make-function}
◊begin{code:lisp}[label=basics/representing-functions/fixing/src:inject-current-env]
(define (make-function variables body |◊ii{env}|)
  (lambda (values)
    (eprogn body (extend |◊ii{env}| variables values)) ) )
◊end{code:lisp}

Теперь все приведённые примеры работают нормально. В~частности, пример выше
вычисляется следующим образом:

◊begin{code:lisp}
(((lambda (a) (lambda (b) (list a b))) 1) 2)|◊begin{where}
                                             ◊- ◊ii{env.global}
                                             ◊end{where}|
|◊equals| ((lambda (b) (list a b))|◊begin{where}
                                   ◊- a {◊is} 1
                                   ◊- ◊ii{env.global}
                                   ◊end{where}|
    2 )|◊begin{where}
        ◊- ◊ii{env.global}
        ◊end{where}|
|◊equals| (list a b)|◊begin{where}
                     ◊- b {◊is} 2
                     ◊- a {◊is} 1
                     ◊- ◊ii{env.global}
                     ◊end{where}|
◊end{code:lisp}

◊indexR{абстракция!замыкание}
◊indexR{абстракция!значение}
◊indexR{возвращаемые значения!абстракций}
◊indexR{замыкания (closures)}
Форма ◊ic{(lambda (b) (list a~b))} создаётся в~глобальном окружении, расширенном
переменной~◊ic{a}. Когда эта функция вызывается, она расширяет окружение своего
создания переменной~◊ic{b}, таким образом, тело функции будет вычисляться
в~окружении, где обе переменные ◊ic{a} и~◊ic{b} присутствуют. После того, как
функция вернёт результат, исполнение продолжается в~глобальном окружении. Мы
будем называть значение абстракции ◊term{замыканием} (closure), потому что при
создании этого значения тело функции становится замкнутым в~окружении своего
определения.

Стоит отметить, что сейчас ◊ic{make-function} сама использует замыкания языка
определения. Это не~является обязательным, как мы покажем далее в~третьей главе.
◊seePage[escape/actors/ssect:functions] Функция~◊ic{make-function} возвращает
замыкания, а это — характерная черта функциональных языков программирования.


◊subsection{Динамическая и~лексическая области~видимости}%
◊label{basics/representing-functions/ssect:dynamic-and-lexical-binding}

Из~этого разговора об~окружениях можно сделать два вывода. Во-первых, ясно,
что с~окружениями не~всё так просто. Любое вычисление всегда производится
в~каком"~то окружении, следовательно, необходимо эффективно реализовывать их
использование. В~третьей главе рассматриваются более сложные вещи вроде
раскрутки стека и соответствующей формы~◊ic{unwind-protect}, которые потребуют
от нас ещё более точного контроля над окружениями.

◊indexR{лексическое связывание}◊indexR{динамическое связывание}
◊indexR{связывание!лексическое}◊indexR{связывание!динамическое}
◊indexR{Лисп!лексический}◊indexR{Лисп!динамический}
Второй момент связан с~двумя рассмотренными в~предыдущем разделе вариантами,
которые являются примерами ◊term{лексического} и ◊term{динамического
связывания}◊footnote{В~объектно"=ориентированных языках под динамическим
связыванием обычно понимается механизм выбора метода объекта на основе его
реального типа во~время исполнения программы, в~противоположность статическому
связыванию, при котором метод выбирается компилятором исходя из типа переменной,
которая хранит рассматриваемый объект.} (также применяются термины лексическая и
динамическая область видимости). В~◊emph{лексическом} Лиспе функция выполняется
в~окружении своего определения, расширенном собственными переменными, тогда как
в~◊emph{динамическом} — расширяет текущее окружение, окружение своего вызова.

Сейчас в~моде лексическое связывание, но это не~значит, что у~динамического нет
будущего. С~одной стороны, именно динамическое связывание применяется
в~некоторых довольно популярных языках вроде ◊TeX~◊cite{knu84},
Emacs~Lisp◊trnote{Начиная с~Emacs~Lisp v.◊,24 и Perl~5, эти языки имеют и
лексические переменные.}~◊cite{llst93}, Perl~◊cite{ws91}.

С~другой стороны, сама идея динамической области видимости является важной
концепцией программирования. Она соответствует установке связей перед
выполнением вычислений и гарантированному автоматическому удалению этих связей
после завершения вычислений.

◊indexR{исключения}
◊indexR{поиск с возвратом}
Такую стратегию можно эффективно применять, например, в~искусственном
интеллекте. В~этом случае сначала выдвигается некая гипотеза, затем из неё
вырабатываются следствия. Как только система натыкается на противоречие, то
гипотезу следует отвергнуть и перейти к~следующей. Это называется ◊term{поиском
с~возвратом}. Если следствия гипотез хранятся без использования побочных
эффектов, например, в~А-списках, то отвержение гипотезы автоматически и без
проблем утилизирует и все её следствия. Но если для этого используются
глобальные переменные, массивы {◊itd}, то тогда за ненужной гипотезой
приходится долго убирать, вспоминая, каким~же было состояние памяти в~момент
формулировки гипотезы и какие его части можно откатить до старых значений, чтобы
ничего не~сломать! Динамическая область видимости позволяет гарантировать
существование переменной с~определённым значением на~время и только во~время
вычислений, независимо от того, будут они успешны или нет. Это свойство также
широко используется при обработке исключений.

◊indexR{область видимости}
◊term{Область видимости} переменной — это, можно сказать, географическое
понятие в~программе: местность, где переменная встречается и её можно
использовать. В~чистом Scheme (не~обременённом полезными, но не~абсолютно
необходимыми вещами вроде~◊ic{let}) есть только одна связывающая форма:
◊ic{lambda}. Это единственная форма, вводящая новые переменные и предоставляющая
им область видимости в~рамках определяемой функции. В~динамическом~же Лиспе
область видимости в~принципе не~может быть ограничена функцией. Рассмотрим
следующий пример:

◊begin{code:lisp}
(define (foo x) (list x y))
(define (bar y) (foo 1991))
◊end{code:lisp}

В~лексическом Лиспе переменная~◊ic{y} в~◊ic{foo}◊footnote{О~происхождении
◊emph{foo} см.~◊cite{ray91}.} — это всегда ссылка на глобальную
переменную~◊ic{y}, которая не~имеет никакого отношения к~◊ic{y} внутри~◊ic{bar}.
В~динамическом~же Лиспе переменная~◊ic{y} из ◊ic{bar} будет видима в~◊ic{foo}
внутри ◊ic{bar}, потому что в~момент вызова ◊ic{foo} переменная~◊ic{y} уже
находилась в~текущем окружении. Следовательно, если мы дадим глобальной ◊ic{y}
значение~◊ic{0}, то получим следующие результаты:

◊begin{code:lisp}
(define y 0)
(list (bar 100) (foo 3)) |◊is| ((1991 0) (3 0))   ; в~лексическом Лиспе
(list (bar 100) (foo 3)) |◊is| ((1991 100) (3 0)) ; в~динамическом Лиспе
◊end{code:lisp}

◊indexR{свободные переменные!и области видимости}
Заметьте, что в~динамическом Лиспе ◊ic{bar} понятия не~имеет о~том, что
в~◊ic{foo} используется её~же локальная переменная~◊ic{y}, а~◊ic{foo} не~знает
о~том, в~каком именно окружении следует искать значение своей свободной
переменной~◊ic{y}. Просто ◊ic{bar} при вызове положила в~текущее окружение
переменную~◊ic{y}, а внутренняя функция ◊ic{foo} нашла её в~своём
текущем окружении. Непосредственно перед выходом ◊ic{bar} уберёт свою~◊ic{y} из
окружения, и глобальная переменная~◊ic{y} снова станет видна.

Конечно, если не~использовать свободные переменные, то нет особой разницы между
динамической и лексической областями видимости.

Лексическое связывание получило своё имя потому, что в~данном случае достаточно
иметь только код функции, чтобы с~уверенностью отнести каждую используемую в~ней
переменную к~одному из двух классов: или переменная находится внутри связывающей
формы и является локальной, или~же это глобальная переменная. Это чрезвычайно
просто: достаточно взять исходный код, взять карандаш (или мышку) и поставить
его кончик на переменную, значение которой нас интересует, после чего следует
вести карандаш справа налево, снизу вверх до тех пор, пока не~встретим первую
связывающую форму. Динамическое~же связывание названо в~честь концепции
◊term{динамического времени жизни} переменных, которую мы будем рассматривать
позже. ◊seePage[escape/forms/ssect:dynamic]

Scheme поддерживает только лексические переменные. {◊CommonLisp} поддерживает
оба типа с~одинаковым синтаксисом. Синтаксис {◊EuLisp} и {◊ISLisp} разделяет эти
два типа переменных, и они находятся в~отдельных пространствах имён.
◊seePage[lisp1-2-omega/sect:namespaces]

◊indexR{область видимости!конфликт имён}
◊indexR{переменные!сокрытие имён}
◊indexR{сокрытие переменных}
◊indexR{сокрытие переменных|seealso{области видимости}}
Область видимости переменной может прерываться. Такое случается, когда одна
переменная ◊term{скрывает} другую из"~за того, что обе имеют одинаковое имя.
Лексические области видимости вкладываются друг в~друга, скрывая переменные
с~совпадающими именами из внешних областей. Этот известный «блокирующий»
порядок разрешения конфликтов унаследован от Алгола~60.

Под влиянием $◊lambda$"=исчисления, в~честь которого названа специальная
форма ◊ic{lambda}~◊cite{per79}, ◊LISP~1.0 был сделан динамическим, но вскоре
Джон~Маккарти осознал, что он ожидал получить от следующего выражения
◊ic{(2~3)}, а не~◊ic{(1~3)}:

◊begin{code:lisp}
(let ((a 1))
  ((let ((a 2)) (lambda (b) (list a b)))
   3 ) )
◊end{code:lisp}

◊indexCS{function}{для замыканий}
◊indexCS{lambda}{как ключевое слово}
Эта аномалия (не~осмелюсь назвать её ошибкой) была исправлена введением новой
специальной формы~◊ic{function}. Она принимала ◊ic{lambda}-форму и создавала
◊term{замыкание} — функцию, связанную с~окружением, в~котором она определена.
При вызове замыкания вместо текущего окружения расширялось окружение
определения, замкнутое внутри него. Вместе с~изменениями ◊ic{d.evaluate} и
◊ic{d.invoke}, форма~◊ic{function}◊footnote{Наша имитация не~совсем точна, так
как существует немало диалектов Лиспа (вроде CLtL1~◊cite{ste84}), где
◊ic{lambda} — это не~специальный оператор, а только ключевое слово-маркер
вроде ◊ic{else} внутри ◊ic{cond} и ◊ic{case}. В~этом случае ◊ic{d.evaluate}
может вообще не~знать ни~о~какой ◊ic{lambda}. Иногда даже накладываются
ограничения на положение ◊ic{lambda}-форм, разрешающие им находиться только
внутри ◊ic{function} и в~определениях функций.} выражается так:

◊indexC{d.invoke}◊indexC{d.make-function}◊indexC{d.make-closure}
◊begin{code:lisp}[label=basics/repr-func/dyn-and-lex-bind/src:closure-eval]
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((function)   ; Синтаксис: ◊ic{(function (lambda ◊ii{аргументы} ◊ii{тело}))}
         (let* ((f   (cadr e))
                (fun (d.make-function (cadr f) (cddr f) env)) )
           (d.make-closure fun env) ) )
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )

(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )

(define (d.make-function variables body env)
  (lambda (values current.env)
    (eprogn body (extend current.env variables values)) ) )

(define (d.make-closure fun env)
  (lambda (values current.env)
    (fun values env) ) )
◊end{code:lisp}

◊indexR{переменные!специальные}
◊indexC{special}
Но это ещё не~конец всей истории. ◊ic{function} — это лишь костыль, на
который опиралась хромая реализация Лиспа. С~созданием первых компиляторов стало
ясно, что с~точки зрения производительности у~лексической области видимости есть
(ожидаемое при компиляции) преимущество: можно сгенерировать код для более-менее
прямого доступа к~любой переменной, а не~динамически отыскивать её значение
заново каждый раз. Тогда по умолчанию стали делать все переменные лексическими,
за исключением тех, которые были явно помечены как динамические или, как тогда
их называли, ◊term{специальные}. Выражение ◊ic{(declare (special~◊ii{x}))}
являлось командой компиляторам ◊LISP~1.5, ◊CommonLisp, Maclisp и~других,
говорившей, что переменная~◊ii{x} ведёт себя «особенно».

◊indexR{ссылочная прозрачность}
Эффективность была не~единственной причиной принятия такого решения. Другой
причиной была потеря ◊term{ссылочной прозрачности} (◊english{referential
transparency}). Ссылочная прозрачность — это свойство языка, заключающееся
в том, что замена в~программе любого выражения его эквивалентом никак не~изменит
поведение этой программы (оба варианта программы или вернут одно и то~же
значение, или вместе застрянут в~бесконечном цикле). Например:

◊begin{code:lisp}
(let ((x (lambda () 1))) (x)) |◊eq| ((let ((x (lambda () 1))) x)) |◊eq| 1
◊end{code:lisp}

В~общем случае ссылочная прозрачность теряется, если язык позволяет побочные
эффекты. Чтобы она сохранилась и при наличии побочных эффектов, необходимо
точнее определить понятие эквивалентных выражений. Scheme обладает ссылочной
прозрачностью, если не~использовать присваивания, функции с~побочными эффектами
и продолжения. ◊seeEx[escape/ex:crazy-cc] Это свойство желаемо и в~наших
программах, если мы хотим сделать их по-настоящему повторно используемыми, как
можно менее зависимыми от контекста использования.

◊indexR{переменные!безымянные}
◊indexR{альфа@$◊alpha$-конверсия}
Локальные переменные функций вроде ◊ic{(lambda (u) (+~u~u))} иногда называются
◊emph{безымянными}. Их имена ничего не~значат и могут быть абсолютно
произвольными. Функция ◊ic{(lambda (n347) (+~n347~n347))} — это та~же
самая◊footnote{В~терминах $◊lambda$"=исчисления подобная замена имён называется
$◊alpha$"=конверсией.} функция, что и ◊ic{(lambda (u) (+~u~u))}.

Мы ожидаем, что в~языке будет сохраняться этот инвариант. Но это невозможно
в~динамическом Лиспе. Рассмотрим следующий пример:

◊indexC{map}
◊begin{code:lisp}
(define (map fn l)  ; или ◊ic{mapcar}, как кому нравится
  (if (pair? l)
      (cons (fn (car l)) (map fn (cdr l)))
      '() ) )

(let ((l '(a b c)))
  (map (lambda (x) (list-ref l x))
       '(2 1 0)))
◊end{code:lisp}

(Функция~◊ic{(list-ref $◊ell$ ◊ii{n})} возвращает ◊ii{n}"~й~элемент
списка~$◊ell$.)

В~Scheme мы~бы получили ◊ic{(c b a)}, но в~динамическом Лиспе результатом будет
◊ic{(0 0 0)}! Причина: свободная переменная~◊ic{l} в~функции ◊ic{(lambda (x)
(list-ref l x))}, имя которой уже занято локальной переменной~◊ic{l}
в~◊ic{map}.

Это затруднение можно решить, просто изменив конфликтующие имена. Например,
достаточно будет переименовать какую-нибудь из двух~◊ic{l}. Например, ту,
которая внутри ◊ic{map}, потому что это более разумно. Но какое имя выбрать,
чтобы эта проблема не~возникла снова? Если приписывать спереди к~имени каждой
переменной номер паспорта программиста, а сзади — текущее ◊UNIX-время, то
это, конечно, значительно снизит вероятность коллизий, но читабельность программ
будет оставлять желать лучшего.

В~начале восьмидесятых годов сложилась довольно неприятная ситуация: студентов
учили Лиспу на примере интерпретаторов, но их понимание областей видимости
отличалось от понимания компиляторов. В~1975~году Scheme ◊cite{ss75} показал,
что интерпретатор и компилятор возможно примирить, поместив обоих в~мир, где все
переменные лексические. {◊CommonLisp} забил последний гвоздь в~гроб этой
проблемы, постановив, что ◊emph{хорошее} понимание — это понимание
компилятора, а для него удобнее лексические переменные. Интерпретатор должен
был подчиниться новым правилам. Растущий успех Scheme и других функциональных
языков, вроде~ML и компании, популяризовал новый подход сначала в~языках
программирования, а затем и в~умах людей.


◊subsection{Дальнее~и~ближнее связывание}%
◊label{basics/representing-functions/ssect:deep-or-shallow}

◊indexR{дальнее (deep) связывание}
◊indexR{связывание!дальнее (deep)}
◊indexCS{lookup}{стоимость}
Но не~всё так просто заканчивается. Разработчики языков нашли способы ускорить
поиск значений динамических переменных. Если окружения представлены
ассоциативными списками, то время на поиск значения переменной (стоимость вызова
◊ic{lookup}) линейно зависит от длины списка.◊footnote*{К~счастью, статистика
показывает, что переменные, располагающиеся ближе к~началу списка, используются
чаще тех, что находятся глубоко внутри. Кстати, ещё стоит отметить, что
лексические окружения в~среднем меньше по размеру, чем динамические, так как
последним необходимо хранить все переменные, участвующие в~вычислениях, включая
одноимённые ◊cite{bak92a}.} Такой подход называется ◊term{глубоким} или
◊term{дальним связыванием} (deep binding), так как значения динамических
переменных обычно располагаются на некотором удалении от текущего локального
окружения.

◊indexR{ближнее (shallow) связывание}
◊indexR{связывание!ближнее (shallow)}
◊indexE{Cval}
Существует и другой метод, называемый ◊term{поверхностным} или ◊term{ближним
связыванием} (shallow binding). Суть его в~том, что переменная напрямую связана
с~местом, где хранится её значение в~текущий момент, без привязки к~окружению.
Проще всего это реализовать, положив это значение в~специальное поле символа,
соответствующего этой переменной; это поле называют ◊ic{Cval} или ◊term{ячейкой
значения} (value cell). В~таком случае стоимость ◊ic{lookup} постоянна или около
того: требуется лишь одна косвенная адресация и, может быть, сдвиг. Так как
бесплатный сыр бывает только в~мышеловке, то стоит отметить, что вызов функции
при использовании этого метода выходит дороже, потому что требуется сначала
где"~то сохранить старые значения аргументов, затем записать новые значения
в~поля соответствующих символов. А~потом, что самое важное, после выхода из
функции старые значения в~символах необходимо восстановить обратно, а это может
помешать оптимизации хвостовой рекурсии. (Хотя есть варианты: ◊cite{sj93}.)

Изменив структуру окружений, мы сможем частично проэмулировать◊footnote{Здесь мы
не~реализуем присваивание переменным, захваченным замыканиями. Об~этом можно
почитать в~◊cite{bcsj86}.} ближнее связывание. Но с~оговорками: список
аргументов не~может быть точечным (так будет легче его разбирать) и мы не~будем
проверять арность функций. Новые функции будем обозначать префиксом ◊ic{s.},
чтобы не~путать их с~другими.

◊indexC{s.make-function}
◊indexC{s.lookup}
◊indexC{s.update"!}
◊begin{code:lisp}
(define (s.make-function variables body env)
  (lambda (values current.env)
    (let ((old-bindings
           (map (lambda (var val)
                  (let ((old-value (getprop var 'apval)))
                    (putprop var 'apval val)
                    (cons var old-value) ) )
                variables
                values ) ))
      (let ((result (eprogn body current.env)))
        (for-each (lambda (b) (putprop (car b) 'apval (cdr b)))
                  old-bindings )
        result ) ) ) )

(define (s.lookup id env)
  (getprop id 'apval) )

(define (s.update! id env value)
  (putprop id 'apval value) )
◊end{code:lisp}

◊indexC{putprop}◊indexC{getprop}
В~Scheme функции ◊ic{putprop} и ◊ic{getprop} не~входят в~стандарт, так как здесь
не~любят неэффективные глобальные побочные эффекты, но тем не~менее, даже
в~◊cite{as85} есть аналогичные ◊ic{put} и~◊ic{get}.
◊seeEx[lisp1-2-omega/ex:write-put/get-prop]

◊indexR{списки свойств}
◊indexR{символы!списки свойств}
◊indexE{P-список}
◊indexR{хеш-таблицы}
С~помощью этих функций мы эмулируем наличие у~символов поля,◊footnote*{Это поле
названо в~честь ◊ic{apval} из~◊cite{mae+62}. ◊seePage[lisp1-2-omega/par:apval]
Тогда значения полей действительно хранились в~наивных P"~списках.} где хранится
значение одноимённой переменной. Независимо от их настоящей реализации,%
◊footnote*{Эти функции проходят по списку свойств символа (его P"~списку,
от~property) до тех пор, пока не~найдут нужное. Скорость поиска, соответственно,
линейно зависит от длины списка, если только не~применяются хеш-таблицы.} будем
считать, что они выполняются за постоянное время.

Заметьте, что в~этой реализации абсолютно не~используется окружение определения
◊ic{env}. Поэтому для поддержки замыканий нам потребуется изменить реализацию
◊ic{make-closure}, так как она теперь не~имеет доступа к~окружению определения
(ввиду его отсутствия). При создании замыкания необходимо просмотреть тело
функции, выделить все свободные переменные и правильно их сохранить внутри
замыкания. Мы реализуем это позже.

◊indexE{rerooting}
Дальнее связывание облегчает смену окружений и многозадачность, теряя в~скорости
поиска переменных. Ближнее связывание ускоряет поиск переменных, но теряет
в~скорости вызова функций. Генри~Бейкеру ◊cite{bak78} удалось объединить эти два
подхода в~технику под названием ◊term{rerooting}.

Наконец, не~забывайте, что ближнее и дальнее связывание — это лишь способы
реализации, они никак не~влияют на само понятие связывания.


◊section{Глобальное окружение}◊label{basics/sect:global-environment}

◊indexR{библиотека!функций}
◊indexR{Лисп!примитивы}
Пустое глобальное окружение — это печально, поэтому большинство лисп-систем
предоставляют ◊emph{библиотеки} функций. Например, в~глобальном окружении
{◊CommonLisp} (CLtL1) около 700~функций, у~{◊LeLisp} их более~1500,
у~{◊ZetaLisp} — более~10◊,000. Без библиотек Лисп был~бы лишь прикладным
$◊lambda$"=исчислением, в~котором нельзя даже распечатать полученные результаты.
Библиотеки очень важны для конечного пользователя. Специальные формы — это
строительные кирпичики для разработчиков интерпретаторов, но для конечного
пользователя такими кирпичиками являются функции библиотек. По"~видимому, именно
отсутствие в~чистом Лиспе таких банальных вещей вроде библиотеки
тригонометрических функций прочно укоренило мысль о непригодности Лиспа для
«серьёзных программ». Как говорится в~◊cite{sla61}, возможность символьного
интегрирования или дифференцирования — это, конечно, замечательно, но кому
нужен язык, где нет даже синуса или тангенса?

Мы ожидаем, что все привычные функции вроде ◊ic{cons}, ◊ic{car} {◊itp} будут
доступны в~глобальном окружении. Также можно туда поместить несколько простых
констант вроде логических значений и пустого списка.

Для этого мы определим пару макросов. Исключительно для удобства, потому что мы
о~них ещё даже не~говорили.◊footnote*{Согласитесь, было~бы странным втискивать
всю книгу в~первую главу.} Макросы — это довольно сложная и важная вещь сами
по себе, так что им посвящена собственная глава. ◊seePage[chapter:macros]

Эти два макроса облегчат наполнение глобального окружения. Само глобальное
окружение является расширением начального окружения ◊ic{env.init}.

◊ForLayout{display}{◊begingroup
◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊indexC{env.global}
◊indexC{definitial}
◊indexC{defprimitive}
◊begin{code:lisp}
(define env.global env.init)
|◊ForLayout{display}{◊vskip-0.4◊baselineskip}|
(define-syntax definitial
  (syntax-rules ()
    ((definitial name)
     (begin (set! env.global (cons (cons 'name 'void) env.global))
            'name ) )
    ((definitial name value)
     (begin (set! env.global (cons (cons 'name value) env.global))
            'name ) ) ) )
|◊ForLayout{display}{◊vskip-0.4◊baselineskip}|
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial name
        (lambda (values)
          (if (= arity (length values))
              (apply value values)      ; Родная ◊ic{apply} Scheme
              (wrong "Incorrect arity" (list 'name values)|◊:|)|◊:|)|◊:|)|◊:|)|◊:|)|◊:|)|◊:|)
◊end{code:lisp}

◊indexC{the-false-value}
Несмотря на то, что стандарт Scheme этого не~требует, мы определим несколько
полезных констант. Заметим, что ◊ic{t} — это переменная в~определяемом Лиспе,
а ◊ic{◊#t} — это значение из определяющего Лиспа. Оно подходит, так как любое
значение, не~совпадающее с~◊ic{the-false-value}, является ◊term{истиной}.

◊begin{code:lisp}
(definitial t #t)
(definitial f the-false-value)
(definitial nil '())
◊end{code:lisp}

◊ForLayout{display}{◊endgroup}

◊indexR{синтаксис!для ◊protect◊ic{◊#t} и~◊ic{◊#f}}
◊indexR{логические значения}
Хотя это удобно — иметь глобальные переменные с~настоящими объектами для
данных сущностей, но есть и другое решение: особый синтаксис. Scheme использует
◊ic{◊#t} и ◊ic{◊#f}, подставляя вместо них логические ◊term{истину} и
◊term{ложь}. В~этом есть определённый смысл:

◊begin{enumerate}
  ◊item Они всегда видимы: ◊ic{◊#t} означает ◊term{истину} в~любом
        контексте, даже тогда, когда локальная переменная
        названа~◊ic{t}.

  ◊item Значение~◊ic{◊#t} невозможно изменить, но многие интерпретаторы
        позволят изменить значение глобальной переменной~◊ic{t}.
◊end{enumerate}

Например, выражение~◊ic{(if t 1 2)} вернёт~◊ic{2}, если оно вычисляется
в~следующем окружении: ◊ic{(let ((t ◊#f)) (if t 1 2))}.

◊indexC{eq?}
Существует много способов ввести такой синтаксис. Наиболее простой способ —
это вшить значения ◊ic{t} и~◊ic{f} в~вычислитель:

◊begin{code:lisp}
(define (evaluate e env)
  (if (atom? e)
      (cond ((eq? e 't) #t)
            ((eq? e 'f) #f)
            ...
            ((symbol? e) (lookup e env))
            ...
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )
◊end{code:lisp}

◊indexR{инлайнинг!функций}
◊indexR{встраивание!функций}
◊indexR{функции!встраиваемые}
◊indexR{связывание!изменяемое}
◊indexR{связывание!неизменяемое}
Также мы могли~бы ввести понятия ◊term{изменяемого} и ◊term{неизменяемого}
связывания. Неизменяемые переменные отвергаются присваиванием. Ничто и никогда
не~сможет изменить значение неизменяемой переменной. Такая концепция существует,
хоть и не~всегда явно, во~многих системах. Например, существуют так называемые
◊term{инлайн-функции} (также известные как ◊term{подставляемые} или
◊term{встраиваемые}), вызов которых можно полностью заменить прямой подстановкой
их тела. ◊seePage[fast/fast/integrating/par:inlining]

Чтобы можно было спокойно подставить вместо ◊ic{(car~x)} код функции,
возвращающей левый элемент точечной пары~◊ic{x}, необходимо быть абсолютно
уверенным в~том, что значение глобальной переменной~◊ic{car} никогда не~менялось
и не~поменяется в~будущем. Посмотрите, какая беда случается, если это не~так:

◊begin{code:lisp}
(set! my-global (cons 'c 'd))
   |◊is| (c . d)
(set! my-test (lambda () (car my-global)))
   |◊is| #<MY-TEST procedure>
(begin (set! car cdr)
       (set! my-global (cons 'a 'b))
       (my-test) )
   |◊is| |◊ii{?????}|
◊end{code:lisp}

К~счастью, в~результате может получиться только ◊ic{a} или~◊ic{b}. Если
◊ic{my-test} использует значение~◊ic{car} на~момент определения, то мы
получим~◊ic{a}. Если~же ◊ic{my-test} будет использовать текущее
значение~◊ic{car}, то ответом будет~◊ic{b}. Полезным будет также сравнить в~этом
аспекте ◊ic{my-test} и ◊ic{my-global}: обычно первый вариант поведения ожидается
от ◊ic{my-test} при использовании компилятора, тогда как для ◊ic{my-global}
нормальным считается именно второй вариант.
◊seePage[lisp1-2-omega/recusion/simple/code:redefine]

◊indexC{foo}◊indexC{bar}◊indexC{fib}◊indexC{fact}
Также мы добавим несколько рабочих переменных◊footnote{К~сожалению, сейчас они
ещё и инициализируются. Эта ошибка будет исправлена позже.} в~глобальное
окружение, так как сейчас у~нас нет способа динамически создавать переменные.
По статистике, предлагаемые имена составляют приблизительно {96,037◊,◊%}
используемых при тестировании свеженаписанных интерпретаторов.

%◊ForLayout{display}{◊begingroup
%◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊begin{code:lisp}
(definitial foo)
(definitial bar)
(definitial fib)
(definitial fact)
◊end{code:lisp}

%◊ForLayout{display}{◊endgroup}

Наконец, определим несколько примитивных функций (не~все, потому что такие
полные списки — это хорошее снотворное). Главная сложность состоит
в~соединении механизмов вызова функций определяемого и определяющего языков.
Зная, что аргументы собираются нашим интерпретатором в~список, достаточно просто
применить
к~нему ◊ic{apply}.◊footnote*{Можно только порадоваться за наш выбор не~называть
◊ic{invoke} «◊ic{apply}».} Заметьте, что арность функций будет соблюдаться,
так как мы включили проверку в~определение макроса~◊ic{defprimitive}.

◊begin{code:lisp}
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive set-cdr! set-cdr! 2)
(defprimitive + + 2)
(defprimitive eq? eq? 2)
(defprimitive < < 2)
◊end{code:lisp}


◊section{Запускаем интерпретатор}◊label{basics/sect:starting-the-interpreter}

Нам осталось показать только одну вещь: дверь в~наш новый мир.

◊indexC{chapter1-scheme}
◊begin{code:lisp}
(define (chapter1-scheme)
  (define (toplevel)
    (display (evaluate (read) env.global))
    (toplevel) )
  (toplevel) )
◊end{code:lisp}

Поскольку наш интерпретатор ещё мал и неопытен, но подаёт большие надежды,
предлагаем вам в~качестве упражнения написать функцию, позволяющую из него
выйти.


◊section{Заключение}◊label{basics/sect:conclusions}

◊indexR{язык!и смысл программ}
Действительно~ли мы сейчас определили язык?

◊indexR{смысл программ}
◊indexR{программы!смысл}
Нет никаких сомнений в~том, что мы можем запустить ◊ic{evaluate}, передать ей
выражение, и она вскоре вернёт результат вычислений. Но сама функция
◊ic{evaluate} не~имеет никакого смысла без языка своего определения, а если
у~нас нет определения языка определения, то мы вообще ни~в~чём не~можем
быть уверены. Так как каждый лиспер является дальним родственником барона
Мюнхгаузена, то, наверное, будет достаточно взять в~качестве языка определения
тот, который мы только что определили. Следовательно, у~нас есть язык~$L$,
определённый функцией~◊ic{evaluate}, написанной на языке~$L$. Такой язык
является решением следующего уравнения относительно~$L$:
%
◊begin{equation*}
  ◊forall◊pi ◊in ◊Vset{Программы}◊colon
    L◊text{◊ic{(evaluate (quote $◊pi$) env.global)}} ◊equiv L◊pi
◊end{equation*}

Исполнение любой программы~$◊pi$, написанной на~$L$ (обозначается как~$L◊pi$),
должно вести себя так~же (то~есть давать тот~же результат или никогда
не~завершаться), как и выражение~◊ic{(evaluate (quote~$◊pi$) env.global)} на
том~же языке~$L$. Одним из занимательных следствий этого утверждения является
то, что ◊ic{evaluate} способна◊footnote{После того, как мы раскроем все
используемые макросы и сокращения вроде ◊ic{let}, ◊ic{case}, ◊ic{define}
{◊itd} Потом надо будет ещё поместить в~глобальное окружение функции
◊ic{evaluate}, ◊ic{evlis} и~др.} проинтерпретировать сама себя. Следовательно,
следующие выражения эквивалентны:

◊begin{code:lisp}
(evaluate (quote |$◊pi$|) env.global) |◊eq|
  |◊eq| (evaluate (quote (evaluate (quote |$◊pi$|) env.global)) env.global)
◊end{code:lisp}

Есть~ли ещё решения приведённого уравнения? Да, и их великое множество! Как мы
видели раньше, определение ◊ic{evaluate} вовсе не~обязательно указывает порядок
вычислений. Множество других свойств языка, используемого для определения,
бессознательно ◊emph{наследуются} определяемым языком. Мы, по~сути, ничего
не~можем о~них сказать, но все эти варианты претендуют на решение указанного
уравнения. Вместе с~многочисленными тривиальными решениями. Рассмотрим,
к~примеру, язык~$L_{2001}$, любая программа на котором возвращает~$2001$. Даже
такой язык удовлетворяет этому уравнению. Поэтому для определения настоящих
языков необходимы другие методы, их мы рассмотрим в~следующих главах.


◊section{Упражнения}◊label{basics/sect:exercises}

◊begin{exercise}◊label{basics/ex:tracer}
◊indexR{трассировка}
Модифицируйте функцию ◊ic{evaluate} так, чтобы она стала трассировщиком. Все
вызовы функций должны выводить на экран фактические аргументы и возвращаемый
результат. Легко представить себе дальнейшее развитие этого инструмента
в~пошаговый отладчик, вдобавок позволяющий изменять порядок выполнения
отлаживаемой программы.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:excess-recursion}
Если функции~◊ic{evlis} передаётся список из одного выражения, она делает
один лишний рекурсивный вызов. Придумайте способ, как избавиться от него.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:new-extend}
Предположим, новая функция~◊ic{extend} определена так:

◊indexC{extend}
◊begin{code:lisp}
(define (extend env names values)
  (cons (cons names values) env) )
◊end{code:lisp}

Определите соответствующие функции ◊ic{lookup} и ◊ic{update!}. Сравните их
с~ранее рассмотренными.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:racks}
◊indexR{ближнее (shallow) связывание}
◊indexR{связывание!ближнее (shallow)}
◊indexE{rack}
В~работе~◊cite{ss80} предлагается другой механизм ближнего связывания, названный
◊term{rack}. Символ связывается с~полем, хранящим не~единственное значение, а
стек значений. В~каждый момент времени значением переменной является находящаяся
на вершине стека величина. Перепишите функции ◊ic{s.make-function},
◊ic{s.lookup} и~◊ic{s.update!} для реализации этой идеи.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:liar-liar!}
◊indexR{представление!логических значений}
Если вы ещё не~заметили, то в~определение функции ◊ic{<} вкралась ошибка! Ведь
эта функция должна возвращать логические значения определяемого языка, а
не~определяющего. Исправьте это досадное недоразумение.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-list}
Определите функцию~◊ic{list}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-call/cc}
Для обожающих продолжения: определите ◊ic{call/cc}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-apply}
Определите функцию ◊ic{apply}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-end}
Определите функцию~◊ic{end}, позволяющую выйти из интерпретатора, разработанного
в~этой главе.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:slowpoke}
◊indexR{уровни интерпретации}
◊indexR{интерпретация!уровневая}
Сравните скорость Scheme и ◊ic{evaluate}. Затем сравните скорость ◊ic{evaluate}
и ◊ic{evaluate}, интерпретируемой с~помощью ◊ic{evaluate}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:no-gensym}
Ранее мы смогли успешно определить ◊ic{begin} через ◊ic{lambda}
◊seePage[basics/forms/sequence/par:gensym-puzzle], но для этого нам
потребовалось использовать функцию ◊ic{gensym}, чтобы избежать коллизий имён
переменных. Переопределите ◊ic{begin} в~таком же духе, но без использования
◊ic{gensym}.
◊end{exercise}


◊section*{Рекомендуемая литература}

Все работы по интерпретаторам, приведённые в~начале этой главы, являются
довольно интересными, но если вы не~можете столько читать, то вот наиболее
стоящие из них:
◊begin{itemize}
  ◊item среди «$◊lambda$"~papers»:~◊cite{ss78a};

  ◊item самая короткая в~мире статья, которая содержит полный интерпретатор
        Лиспа:~◊cite{mcc78b};

  ◊item «нестрого формальное» описание интерпретации:~◊cite{rey72};

  ◊item местная книга Бытия:~◊cite{mae+62}.
◊end{itemize}
