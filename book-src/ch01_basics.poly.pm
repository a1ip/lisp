◊section{Глобальное окружение}◊label{basics/sect:global-environment}

◊indexR{библиотека!функций}
◊indexR{Лисп!примитивы}
Пустое глобальное окружение — это печально, поэтому большинство лисп-систем
предоставляют ◊emph{библиотеки} функций. Например, в~глобальном окружении
{◊CommonLisp} (CLtL1) около 700~функций, у~{◊LeLisp} их более~1500,
у~{◊ZetaLisp} — более~10◊,000. Без библиотек Лисп был~бы лишь прикладным
$◊lambda$"=исчислением, в~котором нельзя даже распечатать полученные результаты.
Библиотеки очень важны для конечного пользователя. Специальные формы — это
строительные кирпичики для разработчиков интерпретаторов, но для конечного
пользователя такими кирпичиками являются функции библиотек. По"~видимому, именно
отсутствие в~чистом Лиспе таких банальных вещей вроде библиотеки
тригонометрических функций прочно укоренило мысль о непригодности Лиспа для
«серьёзных программ». Как говорится в~◊cite{sla61}, возможность символьного
интегрирования или дифференцирования — это, конечно, замечательно, но кому
нужен язык, где нет даже синуса или тангенса?

Мы ожидаем, что все привычные функции вроде ◊ic{cons}, ◊ic{car} {◊itp} будут
доступны в~глобальном окружении. Также можно туда поместить несколько простых
констант вроде логических значений и пустого списка.

Для этого мы определим пару макросов. Исключительно для удобства, потому что мы
о~них ещё даже не~говорили.◊footnote*{Согласитесь, было~бы странным втискивать
всю книгу в~первую главу.} Макросы — это довольно сложная и важная вещь сами
по себе, так что им посвящена собственная глава. ◊seePage[chapter:macros]

Эти два макроса облегчат наполнение глобального окружения. Само глобальное
окружение является расширением начального окружения ◊ic{env.init}.

◊ForLayout{display}{◊begingroup
◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊indexC{env.global}
◊indexC{definitial}
◊indexC{defprimitive}
◊begin{code:lisp}
(define env.global env.init)
|◊ForLayout{display}{◊vskip-0.4◊baselineskip}|
(define-syntax definitial
  (syntax-rules ()
    ((definitial name)
     (begin (set! env.global (cons (cons 'name 'void) env.global))
            'name ) )
    ((definitial name value)
     (begin (set! env.global (cons (cons 'name value) env.global))
            'name ) ) ) )
|◊ForLayout{display}{◊vskip-0.4◊baselineskip}|
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial name
        (lambda (values)
          (if (= arity (length values))
              (apply value values)      ; Родная ◊ic{apply} Scheme
              (wrong "Incorrect arity" (list 'name values)|◊:|)|◊:|)|◊:|)|◊:|)|◊:|)|◊:|)|◊:|)
◊end{code:lisp}

◊indexC{the-false-value}
Несмотря на то, что стандарт Scheme этого не~требует, мы определим несколько
полезных констант. Заметим, что ◊ic{t} — это переменная в~определяемом Лиспе,
а ◊ic{◊#t} — это значение из определяющего Лиспа. Оно подходит, так как любое
значение, не~совпадающее с~◊ic{the-false-value}, является ◊term{истиной}.

◊begin{code:lisp}
(definitial t #t)
(definitial f the-false-value)
(definitial nil '())
◊end{code:lisp}

◊ForLayout{display}{◊endgroup}

◊indexR{синтаксис!для ◊protect◊ic{◊#t} и~◊ic{◊#f}}
◊indexR{логические значения}
Хотя это удобно — иметь глобальные переменные с~настоящими объектами для
данных сущностей, но есть и другое решение: особый синтаксис. Scheme использует
◊ic{◊#t} и ◊ic{◊#f}, подставляя вместо них логические ◊term{истину} и
◊term{ложь}. В~этом есть определённый смысл:

◊begin{enumerate}
  ◊item Они всегда видимы: ◊ic{◊#t} означает ◊term{истину} в~любом
        контексте, даже тогда, когда локальная переменная
        названа~◊ic{t}.

  ◊item Значение~◊ic{◊#t} невозможно изменить, но многие интерпретаторы
        позволят изменить значение глобальной переменной~◊ic{t}.
◊end{enumerate}

Например, выражение~◊ic{(if t 1 2)} вернёт~◊ic{2}, если оно вычисляется
в~следующем окружении: ◊ic{(let ((t ◊#f)) (if t 1 2))}.

◊indexC{eq?}
Существует много способов ввести такой синтаксис. Наиболее простой способ —
это вшить значения ◊ic{t} и~◊ic{f} в~вычислитель:

◊begin{code:lisp}
(define (evaluate e env)
  (if (atom? e)
      (cond ((eq? e 't) #t)
            ((eq? e 'f) #f)
            ...
            ((symbol? e) (lookup e env))
            ...
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )
◊end{code:lisp}

◊indexR{инлайнинг!функций}
◊indexR{встраивание!функций}
◊indexR{функции!встраиваемые}
◊indexR{связывание!изменяемое}
◊indexR{связывание!неизменяемое}
Также мы могли~бы ввести понятия ◊term{изменяемого} и ◊term{неизменяемого}
связывания. Неизменяемые переменные отвергаются присваиванием. Ничто и никогда
не~сможет изменить значение неизменяемой переменной. Такая концепция существует,
хоть и не~всегда явно, во~многих системах. Например, существуют так называемые
◊term{инлайн-функции} (также известные как ◊term{подставляемые} или
◊term{встраиваемые}), вызов которых можно полностью заменить прямой подстановкой
их тела. ◊seePage[fast/fast/integrating/par:inlining]

Чтобы можно было спокойно подставить вместо ◊ic{(car~x)} код функции,
возвращающей левый элемент точечной пары~◊ic{x}, необходимо быть абсолютно
уверенным в~том, что значение глобальной переменной~◊ic{car} никогда не~менялось
и не~поменяется в~будущем. Посмотрите, какая беда случается, если это не~так:

◊begin{code:lisp}
(set! my-global (cons 'c 'd))
   |◊is| (c . d)
(set! my-test (lambda () (car my-global)))
   |◊is| #<MY-TEST procedure>
(begin (set! car cdr)
       (set! my-global (cons 'a 'b))
       (my-test) )
   |◊is| |◊ii{?????}|
◊end{code:lisp}

К~счастью, в~результате может получиться только ◊ic{a} или~◊ic{b}. Если
◊ic{my-test} использует значение~◊ic{car} на~момент определения, то мы
получим~◊ic{a}. Если~же ◊ic{my-test} будет использовать текущее
значение~◊ic{car}, то ответом будет~◊ic{b}. Полезным будет также сравнить в~этом
аспекте ◊ic{my-test} и ◊ic{my-global}: обычно первый вариант поведения ожидается
от ◊ic{my-test} при использовании компилятора, тогда как для ◊ic{my-global}
нормальным считается именно второй вариант.
◊seePage[lisp1-2-omega/recusion/simple/code:redefine]

◊indexC{foo}◊indexC{bar}◊indexC{fib}◊indexC{fact}
Также мы добавим несколько рабочих переменных◊footnote{К~сожалению, сейчас они
ещё и инициализируются. Эта ошибка будет исправлена позже.} в~глобальное
окружение, так как сейчас у~нас нет способа динамически создавать переменные.
По статистике, предлагаемые имена составляют приблизительно {96,037◊,◊%}
используемых при тестировании свеженаписанных интерпретаторов.

%◊ForLayout{display}{◊begingroup
%◊lstset{aboveskip=◊smallskipamount, belowskip=◊smallskipamount}}

◊begin{code:lisp}
(definitial foo)
(definitial bar)
(definitial fib)
(definitial fact)
◊end{code:lisp}

%◊ForLayout{display}{◊endgroup}

Наконец, определим несколько примитивных функций (не~все, потому что такие
полные списки — это хорошее снотворное). Главная сложность состоит
в~соединении механизмов вызова функций определяемого и определяющего языков.
Зная, что аргументы собираются нашим интерпретатором в~список, достаточно просто
применить
к~нему ◊ic{apply}.◊footnote*{Можно только порадоваться за наш выбор не~называть
◊ic{invoke} «◊ic{apply}».} Заметьте, что арность функций будет соблюдаться,
так как мы включили проверку в~определение макроса~◊ic{defprimitive}.

◊begin{code:lisp}
(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive set-cdr! set-cdr! 2)
(defprimitive + + 2)
(defprimitive eq? eq? 2)
(defprimitive < < 2)
◊end{code:lisp}


◊section{Запускаем интерпретатор}◊label{basics/sect:starting-the-interpreter}

Нам осталось показать только одну вещь: дверь в~наш новый мир.

◊indexC{chapter1-scheme}
◊begin{code:lisp}
(define (chapter1-scheme)
  (define (toplevel)
    (display (evaluate (read) env.global))
    (toplevel) )
  (toplevel) )
◊end{code:lisp}

Поскольку наш интерпретатор ещё мал и неопытен, но подаёт большие надежды,
предлагаем вам в~качестве упражнения написать функцию, позволяющую из него
выйти.


◊section{Заключение}◊label{basics/sect:conclusions}

◊indexR{язык!и смысл программ}
Действительно~ли мы сейчас определили язык?

◊indexR{смысл программ}
◊indexR{программы!смысл}
Нет никаких сомнений в~том, что мы можем запустить ◊ic{evaluate}, передать ей
выражение, и она вскоре вернёт результат вычислений. Но сама функция
◊ic{evaluate} не~имеет никакого смысла без языка своего определения, а если
у~нас нет определения языка определения, то мы вообще ни~в~чём не~можем
быть уверены. Так как каждый лиспер является дальним родственником барона
Мюнхгаузена, то, наверное, будет достаточно взять в~качестве языка определения
тот, который мы только что определили. Следовательно, у~нас есть язык~$L$,
определённый функцией~◊ic{evaluate}, написанной на языке~$L$. Такой язык
является решением следующего уравнения относительно~$L$:
%
◊begin{equation*}
  ◊forall◊pi ◊in ◊Vset{Программы}◊colon
    L◊text{◊ic{(evaluate (quote $◊pi$) env.global)}} ◊equiv L◊pi
◊end{equation*}

Исполнение любой программы~$◊pi$, написанной на~$L$ (обозначается как~$L◊pi$),
должно вести себя так~же (то~есть давать тот~же результат или никогда
не~завершаться), как и выражение~◊ic{(evaluate (quote~$◊pi$) env.global)} на
том~же языке~$L$. Одним из занимательных следствий этого утверждения является
то, что ◊ic{evaluate} способна◊footnote{После того, как мы раскроем все
используемые макросы и сокращения вроде ◊ic{let}, ◊ic{case}, ◊ic{define}
{◊itd} Потом надо будет ещё поместить в~глобальное окружение функции
◊ic{evaluate}, ◊ic{evlis} и~др.} проинтерпретировать сама себя. Следовательно,
следующие выражения эквивалентны:

◊begin{code:lisp}
(evaluate (quote |$◊pi$|) env.global) |◊eq|
  |◊eq| (evaluate (quote (evaluate (quote |$◊pi$|) env.global)) env.global)
◊end{code:lisp}

Есть~ли ещё решения приведённого уравнения? Да, и их великое множество! Как мы
видели раньше, определение ◊ic{evaluate} вовсе не~обязательно указывает порядок
вычислений. Множество других свойств языка, используемого для определения,
бессознательно ◊emph{наследуются} определяемым языком. Мы, по~сути, ничего
не~можем о~них сказать, но все эти варианты претендуют на решение указанного
уравнения. Вместе с~многочисленными тривиальными решениями. Рассмотрим,
к~примеру, язык~$L_{2001}$, любая программа на котором возвращает~$2001$. Даже
такой язык удовлетворяет этому уравнению. Поэтому для определения настоящих
языков необходимы другие методы, их мы рассмотрим в~следующих главах.


◊section{Упражнения}◊label{basics/sect:exercises}

◊begin{exercise}◊label{basics/ex:tracer}
◊indexR{трассировка}
Модифицируйте функцию ◊ic{evaluate} так, чтобы она стала трассировщиком. Все
вызовы функций должны выводить на экран фактические аргументы и возвращаемый
результат. Легко представить себе дальнейшее развитие этого инструмента
в~пошаговый отладчик, вдобавок позволяющий изменять порядок выполнения
отлаживаемой программы.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:excess-recursion}
Если функции~◊ic{evlis} передаётся список из одного выражения, она делает
один лишний рекурсивный вызов. Придумайте способ, как избавиться от него.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:new-extend}
Предположим, новая функция~◊ic{extend} определена так:

◊indexC{extend}
◊begin{code:lisp}
(define (extend env names values)
  (cons (cons names values) env) )
◊end{code:lisp}

Определите соответствующие функции ◊ic{lookup} и ◊ic{update!}. Сравните их
с~ранее рассмотренными.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:racks}
◊indexR{ближнее (shallow) связывание}
◊indexR{связывание!ближнее (shallow)}
◊indexE{rack}
В~работе~◊cite{ss80} предлагается другой механизм ближнего связывания, названный
◊term{rack}. Символ связывается с~полем, хранящим не~единственное значение, а
стек значений. В~каждый момент времени значением переменной является находящаяся
на вершине стека величина. Перепишите функции ◊ic{s.make-function},
◊ic{s.lookup} и~◊ic{s.update!} для реализации этой идеи.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:liar-liar!}
◊indexR{представление!логических значений}
Если вы ещё не~заметили, то в~определение функции ◊ic{<} вкралась ошибка! Ведь
эта функция должна возвращать логические значения определяемого языка, а
не~определяющего. Исправьте это досадное недоразумение.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-list}
Определите функцию~◊ic{list}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-call/cc}
Для обожающих продолжения: определите ◊ic{call/cc}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-apply}
Определите функцию ◊ic{apply}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:def-end}
Определите функцию~◊ic{end}, позволяющую выйти из интерпретатора, разработанного
в~этой главе.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:slowpoke}
◊indexR{уровни интерпретации}
◊indexR{интерпретация!уровневая}
Сравните скорость Scheme и ◊ic{evaluate}. Затем сравните скорость ◊ic{evaluate}
и ◊ic{evaluate}, интерпретируемой с~помощью ◊ic{evaluate}.
◊end{exercise}

◊begin{exercise}◊label{basics/ex:no-gensym}
Ранее мы смогли успешно определить ◊ic{begin} через ◊ic{lambda}
◊seePage[basics/forms/sequence/par:gensym-puzzle], но для этого нам
потребовалось использовать функцию ◊ic{gensym}, чтобы избежать коллизий имён
переменных. Переопределите ◊ic{begin} в~таком же духе, но без использования
◊ic{gensym}.
◊end{exercise}


◊section*{Рекомендуемая литература}

Все работы по интерпретаторам, приведённые в~начале этой главы, являются
довольно интересными, но если вы не~можете столько читать, то вот наиболее
стоящие из них:
◊begin{itemize}
  ◊item среди «$◊lambda$"~papers»:~◊cite{ss78a};

  ◊item самая короткая в~мире статья, которая содержит полный интерпретатор
        Лиспа:~◊cite{mcc78b};

  ◊item «нестрого формальное» описание интерпретации:~◊cite{rey72};

  ◊item местная книга Бытия:~◊cite{mae+62}.
◊end{itemize}
