#lang pollen

◊subsection[#:label "escape/implementation/ssect:call/cc"]{Реализация ◊ic{call/cc}}

◊indexC{call/cc!реализация}
Функция ◊ic{call/cc} берёт текущее продолжение~◊ii{k},
превращает его в~объект, который можно вызывать как функцию,
и~вызывает свой аргумент — унарную функцию — передавая ей продолжение как аргумент.
Следующий код чуть~ли не~буквально записывает это определение:

◊indexC{call/cc}
◊code:lisp{
(definitial call/cc
  (make-primitive
   'call/cc
   (lambda (v* r k)
     (if (= 1 (length v*))
         (invoke (car v*) (list k) r k)
         (wrong "Incorrect arity" 'call/cc v*) ) ) ) )
}

Реализация очень простая, но немного пояснений будут нелишними.
◊ic{call/cc} — это функция, но мы определяем её с~помощью ◊ic{defprimitive},
так~как это единственный способ для функции получить доступ к~продолжению~◊ii{k}.
Переменная ◊ic{call/cc} связывается с~объектом класса ◊ic{primitive} (кстати, теперь вы понимаете, что мы реализуем~◊Lisp-1).
Протокол вызова примитивов требует «адрес» функции,
которому в~нашем интерпретаторе соответствуют замыкания вида ◊nobr{◊ic{(lambda (v* r k) ...)}}.
После проверки на арность первый аргумент ◊ic{call/cc} применяется к~захваченному продолжению.
Само продолжение мы никак не~преобразуем, оно остаётся объектом языка реализации.
Так~как «сырые» продолжения будут впоследствии переданы ◊ic{invoke}, то~её необходимо научить обращаться с~продолжениями:

◊indexC{invoke!◊ic{continuation}}
◊code:lisp{
(define-method (invoke (f continuation) v* r k)
  (if (= 1 (length v*))
      (resume f (car v*))
      (wrong "Continuations expect one argument" v* r k) ) )
}
