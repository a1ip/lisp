#lang pollen

◊subsection[#:label "escape/actors/ssect:alternatives"]{Ветвление}

Условный оператор использует два продолжения:
текущее продолжение — всей формы ◊ic{if}, —
а~также продолжение работы после вычисления условия.
Для второго продолжения мы заведём отдельный класс, где будет храниться всё необходимое:
обе ветви исполнения, между которыми мы выбираем;
окружение в~котором следует вычислять выбранную ветвь;
и~наконец продолжение, которому следует передать полученный результат.
Таким~образом:

◊indexC{if-cont}
◊indexC{evaluate-if}
◊indexC{resume!◊ic{if-cont}}
◊code:lisp{
(define-class if-cont continuation (et ef r))

(define (evaluate-if ec et ef r k)
  (evaluate ec r (make-if-cont k et ef r)) )

(define-method (resume (k if-cont) v)
  (evaluate (if v (if-cont-et k) (if-cont-ef k))
            (if-cont-r k)
            (if-cont-k k) ) )
}

Форма вначале вычисляет условие~◊ic{ec} в~своём окружении~◊ic{r}, но~с~новым продолжением.
Как только мы заканчиваем вычислять условие, результат~◊ic{v} передаётся ◊ic{resume},
которая вызывает специализацию для нашего класса продолжений.
В~этом продолжении мы выполняем собственно выбор,
вычисляем одну их сохранённых ветвей в~сохранённом окружении
и передаём результат сохранённому продолжению всей условной формы.
◊footnote{
  С~точки зрения реализации можно считать, что ◊ic{make-if-cont} кладёт в~стек ◊ic{et}, ◊ic{ef}, а~также~◊ic{r}.
  Под~ними в~стеке находится, собственно, продолжение~◊ic{k}.
  А~вызовы вроде ◊ic{(if-cont-et k)} лишь снимают со~стека нужные данные.
}
