#lang pollen

◊subsection[#:label "escape/pr-cont/ssect:tail-recusion"]{Хвостовая рекурсия}

В~примере с~вычислением факториала с~помощью продолжений
вызов~◊ic{fact} в~конце концов приводил к~ещё одному вызову~◊ic{fact}.
Если мы проследим за вычислением ◊nobr{◊ic{(fact 3 list)}},
то,~отбрасывая очевидные шаги, получим следующую картину:

◊; TOOD: ◊(eq) vs ◊(is)
◊code:lisp{
(fact 3 list)

≡ (fact 2 (lambda (r) (k (* n r))))◊where{
                                   | n ◊(is) 3
                                   | k ◊(eq) list
                                   }
≡ (fact 1 (lambda (r) (k (* n r))))◊where{
                                   | n ◊(is) 2
                                   | k ◊(is) (lambda (r) (k (* n r)))◊where{
                                                                     | n ◊(is) 3
                                                                     | k ◊(eq) list
                                                                     }
                                   }
≡ (k (* n 1))◊where{
             | n ◊(is) 2
             | k ◊(is) (lambda (r) (k (* n r)))◊where{
                                               | n ◊(is) 3
                                               | k ◊(eq) list
                                               }
             }
≡ (k (* n 2))◊where{
             | n ◊(is) 3
             | k ◊(eq) list
             }
≡ (6)
}

◊indexR{рекурсия!хвостовая}
◊indexR{хвостовые вызовы!рекурсивные}
◊indexR{вызов!хвостовой}
Когда ◊ic{fact} вызывает ◊ic{fact}, вторая функция вычисляется с~тем~же продолжением, что и~первая.
Такое явление называется ◊term{хвостовой рекурсией} — почему рекурсия понятно,
а~хвостовая, потому что этот вызов выполняется в~«хвосте» вычислений:
сразу~же после него следует выход из~функции.
Хвостовая рекурсия — это частный случай хвостового вызова.
Хвостовой вызов происходит тогда, когда текущее вычисление может быть полностью заменено вызываемым.
То~есть вызов происходит из~◊term{хвостовой позиции}, если он выполняется с~◊emph{неизменным продолжением}.

В~примере с~вычислением коэффициентов~Безу функция ◊ic{bezout} вызывает ◊ic{divide} из хвостовой позиции.
Функция ◊ic{divide} вызывает своё продолжение из хвостовой позиции.
Это~продолжение рекурсивно вызывает ◊ic{bezout} опять-таки из хвостовой позиции.

Но~в~классическом факториале ◊ic{(*~n (fact (-~n~1)))} рекурсивный вызов ◊ic{fact} не~является хвостовым.
Говорят, что он~◊emph{завёрнут} в~продолжение, так как значение~◊ic{(fact (-~n~1))} ещё ожидается для умножения на~◊ic{n}.
Вызов~◊ic{fact} не~является последней выполняемой операцией, остаток вычислений нельзя свести к~нему.

Хвостовые вызовы позволяют отбрасывать ненужные окружения и продолжения,
так как при таких вызовах они больше никогда не~будут использоваться.
Следовательно, их можно не~сохранять, экономя таким образом драгоценную стековую память.
Подобные оптимизации были детально изучены французским лисп-сообществом:
например,~◊cite{gre77,cha80,sj87},
что позволило значительно ускорить интерпретаторы.
См.~также~◊cite{han90}.

◊bigskip

◊indexC{evaluate-begin!хвостовая рекурсия}
Хвостовая рекурсия оказывается очень полезной не~только в~прикладном программировании,
но~и для реализации самих интерпретаторов.
Оптимизация хвостовой рекурсии требует изменений всего в~одном месте — определении последовательных вычислений.
До~сих~пор мы определяли ◊ic{begin} следующим образом:

◊code:lisp{
(define (evaluate-begin e* r k)
  (if (pair? e)
      (if (pair? (cdr e*))
          (evaluate (car e*) r (make-begin-cont k e* r))
          (evaluate (car e*) r k) )
      (resume k empty-begin-value) ) )

(define-method (resume (k begin-cont) v)
  (evaluate-begin (cdr (begin-cont-e* k))
                  (begin-cont-r k)
                  (begin-cont-k k) ) )
}

Заметьте, здесь каждый вызов является хвостовым.
Можно было~бы написать проще:

◊code:lisp{
(define (evaluate-begin e* r k)
  (if (pair? e*)
      (evaluate (car e*) r (make-begin-cont k e* r))
      (resume k empty-begin-value) ) )

(define-method (resume (k begin-cont) v)
  (let ((e* (cdr (begin-cond-e* k))))
    (if (pair? e*)
        (evaluate-begin e* (begin-cont-r k) (begin-cont-k k))
        (resume (begin-cont-k k) v) ) ) )
}

Однако первый вариант реализации предпочтительнее,
так как в~этом случае при вычислении последнего оставшегося выражения
не~создаётся лишнее продолжение ◊nobr{◊ic{(make-begin-cont k e* r)}},
которое фактически равно~◊ic{k}.
Вместо этого мы сразу переходим к~нужному продолжению.
Конечно, в~Лиспе есть сборщик мусора,
но~это не~означает, что можно мусорить ненужными объектами на~каждом шагу.
Это~небольшая, но важная оптимизация — ведь каждая форма ◊ic{begin} когда-нибудь заканчивается!

◊indexC{evaluate-arguments!хвостовая рекурсия}
Аналогично можно оптимизировать и вычисление аргументов функции, переписав его следующим образом:

◊code:lisp{
(define-class no-more-argument-cont continuation ())

(define (evaluate-arguments e* r k)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (evaluate (car e*) r (make-argument-cont k e* r))
          (evaluate (car e*) r (make-no-more-argument-cont k)) )
      (resume k no-more-arguments) ) )

(define-method (resume (k make-no-more-argument-cont) v)
  (resume (no-more-argument-cont-k k) (list v)) )
}

Новый класс продолжений, означающий конец списка аргументов,
позволяет не~хранить окружение~◊ic{r} дольше, чем необходимо.
Этот приём изобрели Митчелл~Уонд и Дэниел~Фридман в~◊cite{wan80b}.
