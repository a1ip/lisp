#lang pollen

◊subsection[#:label "escape/forms/ssect:catch-vs-block"]{Сравнение ◊ic{catch}~и~◊ic{block}}

◊indexC{catch!в~сравнении с~◊ic{block}}
◊indexC{block!в~сравнении с~◊ic{catch}}
С~одной стороны, ◊ic{catch} и ◊ic{block} очень похожи:
захватываемые ими продолжения имеют динамическое время жизни —
переходы можно выполнять только внутри соответствующих блоков.
С~другой стороны, ◊ic{return-from} может ссылаться на продолжение сколь угодно долго,
тогда как ◊ic{throw} ссылается лишь на метку, а~продолжением управляет именно ◊ic{catch}.
Форма ◊ic{block} более эффективна, так как ◊ic{return-from} не~требуется проверять,
действительно~ли существует парный ему ◊ic{block} — это гарантируется синтаксисом.
Тем не~менее, ей приходится проверять, можно~ли воспользоваться сохранённым продолжением,
хотя чаще всего это тоже легко проверяется по исходному коду.
Видна явная параллель между динамическими и лексическими метками с~одной стороны
и динамическими и лексическими переменными с~другой:
возникающие проблемы схожи в~обоих случаях.

◊indexR{конфликт имён}
◊indexR{область видимости!конфликт имён}
Динамические метки могут конфликтовать между собой — лексические~же в~принципе невозможно перепутать.
Взять хотя~бы возможность использовать динамические метки где угодно:
одна функция может случайно (или~намеренно) перехватить то, что предназначалось другой.
Например:

◊code:lisp{
(define (foo)
  (catch 'foo (* 2 (bar))) )

(define (bar)
  (+ 1 (throw 'foo 5)) )

(foo) ⟹ 5
}

Независимо от времени жизни соответствующего продолжения,
◊ic{block} ограничивает область видимости метки строго своим телом,
тогда как ◊ic{catch} отзывается на подходящий ◊ic{throw} из любого уголка программы.
Поэтому можно выполнить ◊nobr{◊ic{(throw 'foo ...)}} где угодно в~процессе вычисления ◊nobr{◊ic{(* 2 (bar))}} и~это сработает.
Использование ◊nobr{“◊ic{catch 'foo}”} вместо ◊nobr{“◊ic{block foo}”} естественно приведёт к~ошибке,
так как ◊ic{return-from} понятия не~имеет о~◊nobr{◊ic{(block foo ...)}} в~функциях, которые вызывают~◊ic{bar}.
Но~это ещё безобидный пример.
Рассмотрим следующую ситуацию:

◊code:lisp[#:label "escape/forms/catch-vs-block/p:better-map"]{
(catch 'not-a-pair
  (better-map (lambda (x)
                (or (pair? x)
                    (throw 'not-a-pair x) ) )
              (hack-and-return-list) ) )
}

Предположим, вы услышали от коллеги, что ◊ic{better-map} гораздо лучше ◊ic{map}.
Конечно~же необходимо использовать именно эту функцию, чтобы эффективно проверить,
действительно~ли ◊ic{(hack-and-return-list)} возвращает список, состоящий из пар.
Вы не~знаете, как именно реализована ◊ic{better-map}, хотя на самом деле она выглядит вот~так:

◊indexC{better-map}
◊code:lisp{
(define (better-map f L)
  (define (loop L1 L2 flag)
    (if (pair? L1)
        (if (eq? L1 L2)
            (throw 'not-a-pair L)
            (cons (f (car L1))
                  (loop (cdr L1)
                        (if flag (cdr L2) L2)
                        (not flag) ) ) ) ) )
  (loop L (cons 'ignore L) #t) )
}

Функция ◊ic{better-map} интересна тем, что в~отличие от обычной ◊ic{map}
она не~зацикливается на замкнутых списках.
Если ◊ic{(hack-and-return-list)} возвращает список ◊nobr{◊ic{#1=((foo . hack) . #1#)}},
◊footnote{
  Здесь используется нотация ◊CommonLisp для рекурсивных структур данных.
  Такой список в~Scheme возвращает выражение
  ◊code:lisp{
  (let ((p (list (cons 'foo 'hack))))
    (set-cdr! p p)
    p )
  }
}
то~◊ic{better-map} прыгнет на ближайшую метку ◊ic{not-a-pair}
и таким образом избегает бесконечного цикла.
Но~вот незадача:
одноимённую метку использует и замыкание, которое передаётся в~◊ic{better-map}.
Естественно, если в~документации к~◊ic{better-map} будет написано, что она использует такую метку,
то конфликт имён можно предотвратить, использовав какое-нибудь другое имя для своих целей.
Благо, в~случае ◊ic{catch} можно использовать что угодно в~качестве метки;
в~частности, специально собранный для этого случая список:

◊code:lisp{
(let ((tag (list 'not-a-pair)))
  (catch tag
    (better-map (lambda (x)
                  (or (pair? x)
                      (throw tag x) ) )
                (hack-and-return-list) ) ) )
}

Наконец, рассмотрим, как можно проэмулировать ◊ic{block} с~помощью ◊ic{catch}
(конечно, выигрыша в~производительности мы не~получим).
Для этого достаточно обеспечить лексичность используемых меток:

◊indexC{block!определение через ◊ic{catch}}
◊indexC{return-from!определение через ◊ic{throw}}
◊code:lisp{
(define-syntax block
  (syntax-rules ()
    ((block label . body)
     (let ((label (list 'label)))
       (catch label . body) ) ) ) )

(define-syntax return-from
  (syntax-rules ()
    ((return-from label value)
     (throw label value) ) ) )
}

Макрос ◊ic{block} создаёт уникальную метку и лексически связывает её с~одноимённой переменной.
Этим мы гарантируем, что нужную метку будут видеть только те ◊ic{return-from},
которые лексически находятся внутри формы ◊ic{block}.
Правда, для этого используется переменная ◊ic{label}, что может быть неожиданным.
Конечно, можно воспользоваться чем-то вроде ◊ic{gensym},
но необходимо удостовериться, что ◊ic{catch} и ◊ic{throw} используют одинаковые~имена.
