#lang pollen

◊section[#:label "escape/sect:comparing"]{Сравнение ◊ic{call/cc}~и~◊ic{catch}}

◊; TODO: "благодаря объектам" очень косноязыно
Благодаря объектам, продолжения выглядят как связный список блоков.
Некоторые из~этих блоков доступны прямо через лексическое окружение;
до~других необходимо пробираться, проходя через несколько промежуточных продолжений;
третьи вызывают выполнение определённых действий, когда через них проходят.

◊indexR{продолжения (continuations)!время жизни!динамическое}
В~языках вроде Лиспа, где продолжения обладают динамическим временем жизни,
стек вызовов и продолжения являются синонимами.
Когда выполняется ◊ic{(evaluate~ec~r (make-if-cont~k~et~ef~r))},
в~стек вызовов помещается блок кода, который продолжит работу со~значением условия ◊nobr{◊ic{if}-формы}.
Аналогично, когда выполняется ◊ic{(evaluate-begin (cdr~(begin-cont-e*~k)) (begin-cont-r~k) (begin-cont-k~k))},
то~текущий блок~◊ic{k} отбрасывается, а~вместо него продолжается ◊ic{(begin-cont-k~k)}.
Отброшенные блоки никогда не~исполняются —
в~языках с~динамическим временем жизни продолжений только текущее состояние стека вызовов может быть исполнено.
Когда блок исполняется или отбрасывается, все указывающие на него продолжения становятся недействительными.
Такие продолжения обычно реализуются именно с~помощью стека, или нескольких стеков, согласованных между собой,
а~переходы между ними компилируются в~примитивы языка~Си: ◊ic{setjmp}/◊ic{longjmp}.
◊seePage{cc/sect:call/cc}
◊; TODO: строка не должна разбиваться на слеше, никогда

◊indexC{let/cc}
В~диалекте ◊EuLisp ◊seeCite{pe92} присутствует специальная форма ◊ic{let/cc} со~следующим синтаксисом:

◊code:lisp[#:dialect EuLisp]{
(let/cc ◊ii{переменная} ◊ii{формы}...)
}

◊indexC{bind-exit}
◊phantomlabel{escape/comparing/par:bind-exit}
◊noindent
В~диалекте Dylan ◊seeCite{app92b} тоже есть похожая форма:

◊code:lisp[#:dialect "Dylan"]{
(bind-exit (◊ii{переменная}) ◊ii{формы}...)
}

◊noindent
Здесь текущее продолжение связывается с~◊ii{переменной},
которая имеет область видимости, ограниченную телом ◊ic{let/cc} или~◊ic{bind-exit}.
Продолжение представляется полноценным объектом, который выглядит как унарная функция.
Однако ◊emph{полезное} время жизни этого объекта динамическое —
продолжением можно воспользоваться лишь во~время вычисления тела формы ◊ic{let/cc} или ◊ic{bind-exit}.
Точнее, само продолжение, хранящееся в~◊ii{переменной}, имеет неограниченное время жизни,
но~становится бесполезным при выходе из связывающей формы.
Это характерная черта ◊EuLisp и Dylan, которая отсутствует как в~Scheme, где продолжения истинно неограниченны,
так и в~◊CommonLisp, где они вообще не~объекты.
Тем не~менее, форму ◊EuLisp можно легко проэмулировать в~Scheme:

◊code:lisp{
(define-syntax let/cc
  (syntax-rules ()
    ((let/cc variable . body)
     (block variable
       (let ((variable (lambda (x) (return-from variable x))))
         . body ) ) ) ) )
}

◊; TODO ◊indexR{стек-кактус}
◊indexR{продолжения (continuations)!варианты представления}
В~Scheme продолжения больше нельзя считать неявной частью стека вызовов, так как они могут храниться в~произвольных структурах данных.
Здесь приходится применять другую модель: древовидную, которую иногда называют ◊term{стек-кактус} или ◊term{спагетти-стек}.
Наиболее простой способ её реализовать — это вообще не~пользоваться аппаратным стеком, размещая блоки продолжений в~куче.

◊; TODO: кадры, не фреймы -- кадры, везде
Такой подход унифицирует выделение памяти под структуры данных,
что, по~мнению~◊cite{as94}, облегчает портирование реализаций между архитектурами.
Однако взамен снижается локальность размещения структур данных в~памяти,
а~также требуется явно хранить и обновлять ссылки между блоками продолжений.
(Хотя~в~◊cite{mb93} приведено несколько вариантов решения этих проблем.)
Как~правило, ради эффективности разработчики стараются размещать в~стеке как можно больше данных,
так что каноническая реализация ◊ic{call/cc} делает снимки стека и сохраняет в~куче именно~их.
Конечно, существуют и другие варианты реализации, например~◊cite{cho88, hdb90},
где используются разделяемые копии, отложенное копирование, частичное копирование, и~т.~д.
Естественно, каждый из этих вариантов имеет свои преимущества (и~недостатки).

◊bigskip

◊; TODO: index: call/ep, expit procedure
Форма ◊ic{call/cc} больше похожа на~◊ic{block}, чем~на~◊ic{catch}.
Оба типа продолжений имеют лексическую область видимости, они отличаются только временем жизни.
В~некоторых диалектах, вроде~◊cite{im89}, есть урезанный вариант ◊ic{call/cc},
который называется ◊ic{call/ep} (◊english{◊term{call with exit procedure}}).
Сравните её с~◊ic{block}/◊ic{return-from} и~особенно с~◊ic{let/cc}.
Интерфейс~◊ic{call/ep} аналогичен~◊ic{call/cc}:

◊indexC{call/ep}
◊code:lisp{
(call/ep (lambda (exit) ...))
}

◊; TODO: так класса или сорта всё же?
◊indexR{объекты!второго класса}
Переменная~◊ic{exit} связывается с~продолжением формы ◊ic{call/ep} на~время вычисления тела функции.
Схожесть с~◊ic{block} налицо,
разве что мы используем обычное окружение переменных, а~не~отдельное окружение лексических меток.
Основное отличие в~том, что ◊ic{call/ep} делает продолжение полноценным объектом,
который можно использовать так~же, как любой другой объект вроде чисел, замыканий или списков.
В~случае с~◊ic{block}, функционально аналогичный объект необходимо создавать вручную,
написав ◊ic{(lambda~(x) (return-from~◊ii{метка}~x))}.
Однако все возможные места выхода из~◊ic{block} известны статически — это соответствующие формы ◊ic{return-from}.
С~формой ◊ic{call/ep} всё сложнее: по~выражению ◊ic{(call/ep foo)} нельзя понять, может~ли произойти переход или нет.
Единственный способ это узнать — проанализировать значение~◊ic{foo},
но~эта функция может быть определена в~совершенно другом месте, а~то и вовсе генерироваться динамически.
Следовательно, функция ◊ic{call/ep} более сложна для компилятора чем специальная форма~◊ic{block}.

Продолжая сравнивать ◊ic{call/ep} и~◊ic{block}, мы замечаем больше отличий.
Например, для формы ◊ic{call/ep}, в~которой аргумент записан в~виде явной ◊ic{lambda}-формы, можно не~создавать замыкание.
Следовательно, эффективный компилятор будет обрабатывать случай ◊ic{(call/ep (lambda~...))} отдельно.
Это похоже на специальные формы, так как они тоже трактуются компилятором по-особенному.
В~Scheme принято использовать функции как основной инструмент построения абстракций,
тогда как специальные формы являются чем-то вроде подсказок компилятору.
Они часто одинаково выразительны, вопрос лишь в~балансе сложности — кому важнее облегчить жизнь: пользователю или, наоборот, разработчику~языка.

◊bigskip

Подводя итог, если вам нужна мощь за соответствующую цену, то~◊ic{call/cc} к~вашим услугам —
◊ic{call/cc} позволяет реализовать все мыслимые управляющие конструкции:
переходы, сопрограммы, частичные продолжения, и~так~далее.
Если~же вам достаточно «нормальных» возможностей
(а~Лисп уже не~раз показывал, что можно писать удивительные программы и~без~◊ic{call/cc}),
то~используйте управляющие формы ◊CommonLisp — они просто компилируются в~эффективный машинный~код.
◊; TODO: так управляющие формы или конструкции? или *здесь* -- формы?
