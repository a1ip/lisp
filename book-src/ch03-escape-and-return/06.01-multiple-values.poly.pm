#lang pollen

◊subsection[#:label "escape/pr-cont/ssect:multiple"]{Множественные значения}

◊indexR{возвращаемые значения!множественные}
◊indexR{множественные значения}
Продолжения очень удобно использовать для обработки нескольких значений.
Существуют вычисления, результатом которых является не~одна величина, а~множество.
Например, в~◊CommonLisp целочисленное деление (◊ic{truncate}) одновременно возвращает частное и~остаток.
Пусть у~нас тоже есть подобная функция — назовём её ◊ic{divide}, —
которая принимает два числа и продолжение, вычисляет частное и остаток от~деления,
а~затем применяет переданное продолжение к~этим величинам.
Например, вот~так можно проверить правильность выполнения деления этой функцией:

◊code:lisp{
(let* ((p (read)) (q (read)))
  (divide p q (lambda (quotient remainder)
                (= p (+ (* quotient q) remainder)) )) )
}

Менее тривиальный пример — вычисление коэффициентов~Безу.
◊footnote{
  Ура, наконец-то мне удалось опубликовать эту~функцию!
  Она с~1981~года пылится у~меня~в~столе.
}
Соотношение Безу утверждает, что для любых целых чисел ◊${n}~и~◊${p} можно найти такую пару целых ◊${u}~и~◊${v}, что ◊${un + vp = ◊|GCD|(n, p)}.
Для вычисления коэффициентов ◊${u}~и~◊${v} можно использовать расширенный алгоритм~Евклида.

◊; TODO: перепроверь математику и реализацию; я помню, ты проверял, но всё же сделай это ещё раз
◊indexC{bezout}
◊code:lisp{
(define (bezout n p k)  ; пусть ◊${n > p}
  (divide n p
   (lambda (q r)
     (if (= r 0)
         (k 0 1)        ; так как ◊${0 \cdot qp + 1 \cdot p = p}
         (bezout p r
          (lambda (u v)
            (k v (- u (* v q))) ) ) ) ) ) )
}

Функция ◊ic{bezout} делит~◊ic{n} на~◊ic{p} с~помощью ◊ic{divide}, получая частное~◊ic{q} и~остаток~◊ic{r}.
Если~◊${n} делится нацело на~◊${p}, то~очевидно, что их наибольший общий делитель равен~◊${p} —
и~есть тривиальное решение: ◊${0}~и~◊${1}.
◊; TODO: ◊(dots)? или автозамена .... на "правильное" многоточие
Если~же остаток не~равен нулю, то... попробуйте доказать корректность этого алгоритма самостоятельно;
для этого не~надо быть экспертом в~теории чисел, достаточно знать свойства~НОД.
А~здесь мы ограничимся простой проверкой:

◊code:lisp{
(bezout 1991 1960 list) ◊(is) (-569 578)
}
