#lang pollen

◊subsection[#:label "lisp1-2-omega/recusion/ssect:uninitialized"]{Объявление неинициализированных~привязок}

◊indexR{привязки (bindings)!неинициализированные}
Официально семантика Scheme считает ◊ic{letrec} производной формой — удобным сокращением, но не~специальной формой.
Соответственно, любую ◊ic{letrec}-форму можно записать с~помощью примитивных форм Scheme.
Чуть раньше мы попробовали это сделать, временно связывая переменные ◊ic{letrec} со~значением ◊ic{'void}.
К~сожалению, это тоже инициализация, так что обращения к~неинициализированным переменным подобным образом отловить нельзя.
Наша ситуация усугубляется тем, что ни~одна из четырёх специальных форм Scheme не~позволяет создавать неинициализированные привязки.

◊indexC{UFO@#<UFO>}
В~первом приближении можно было~бы решить проблему, используя некий объект ◊ic{#<UFO>} вместо~◊ic{'void}.
◊seePage{basics/s:env/ufo}
С~ним ничего нельзя сделать: ни~прибавить к~нему число, ни~взять его~◊ic{car}.
При этом ◊ic{#<UFO>} — это всё~же полноценный объект, так что его можно передать как аргумент в~◊ic{cons},
а~значит, следующая программа не~будет ошибочной и вернёт ◊ic{#<UFO>}:

◊code:lisp{
(letrec ((foo (cons 'foo foo))) (cdr foo))
}

Дело в~том, что неинициализированность — это свойство самой переменной, а~не~её значения.
Следовательно, мы не~сможем решить проблему с~помощью полноценных объектов первого~класса.

◊(bigskip)

◊indexC{uninitialized@#<uninitialized>}
И~всё~же, многие реализации дают неинициализированным переменным специальное значение.
Давайте назовём его ◊ic{#<uninitialized>} и предположим, что это полноценный объект.
Любая переменная с~таким значением считается неинициализированной.
Следовательно, используя вместо ◊ic{'void} значение ◊ic{#<uninitialized>}, мы получаем желаемую возможность обнаружить ошибку.
Однако, эта возможность чересчур явная: ничто не~запрещает передавать ◊ic{#<uninitialized>} в~функцию как аргумент,
а~значит, больше нельзя предполагать, что все аргументы функции имеют значения.
Мы будем вынуждены каждый раз проверять, действительно~ли это так:

◊code:lisp{
(define (fact n)
  (if (eq? n #<uninitialized>)
      (wrong "Uninitialized n")
      (if (= n 0) 1
          (* n (fact (- n 1))) ) ) )
}

Вставлять подобные проверки повсюду — это слишком большая плата за ◊ic{letrec}.
Так что ◊ic{#<uninitialized>} нельзя делать полноценным объектом,
это должно быть особое внутреннее значение реализации языка, которое нельзя использовать в~программах —
в~частности, в~нашем интерпретаторе.

◊(bigskip)

Третий вариант решения состоит во~введении специальной формы, создающей неинициализированные привязки.
Например, ◊(CommonLisp) поддерживает альтернативный синтаксис~◊ic{let}:

◊code:lisp{
(let (◊ii{переменная} ...)
  ... )
}

Если имя переменной указано само по себе, без начального значения, то привязка к~этому имени не~будет инициализирована.
При обращении к~этой переменной необходимо явно проверять, была~ли она инициализирована или нет.
Теперь можно будет написать нормальную реализацию ◊ic{letrec}.
В~следующем коде переменные ◊ii{temp◊sub{i}} являются ◊term{гигиеничными} —
гарантированно не~конфликтуют ни с~именами ◊ii{переменных◊sub{i}},
ни со~свободными переменными ◊ii{тела}~◊ic{letrec}.

◊code:lisp{
(letrec ((◊ii{переменная◊sub{1}} ◊ii{выражение◊sub{1}})
          ...
         (◊ii{переменная◊sub{n}} ◊ii{выражение◊sub{n}}) )
  ◊ii{тело} )
}

◊(eq) ◊; TODO: таблица

◊code:lisp{
(let (◊ii{переменная◊sub{1}} ... ◊ii{переменная◊sub{n}})
  (let ((◊ii{temp◊sub{1}} ◊ii{выражение◊sub{1}})
         ...
        (◊ii{temp◊sub{n}} ◊ii{выражение◊sub{n}}) )
    (set! ◊ii{переменная◊sub{1}} ◊ii{temp◊sub{1}})
     ...
    (set! ◊ii{переменная◊sub{n}} ◊ii{temp◊sub{n}})
    ◊ii{тело} ) )
}

◊indexC{let!специальная форма}
Итого, проблема решена с~приемлемой эффективностью:
лишь неинициализированные переменные вызывают накладные расходы.
Однако теперь форма~◊ic{let} не~является просто синтаксическим сахаром,
теперь это полноценная специальная форма, которую должен обрабатывать интерпретатор.
Добавляем соответствующий код в~◊ic{evaluate}:

◊code:lisp{
...
((let)
 (eprogn (cddr e)
         (extend env
                 (map (lambda (binding)
                        (if (symbol? binding) binding
                            (car binding) ) )
                      (cadr e) )
                 (map (lambda (binding)
                        (if (symbol? binding) the-uninitialized-marker
                            (evaluate (cadr binding) env) ) )
                      (cadr e) ) ) ) ) ...
}

Переменная ◊ic{the-uninitialized-marker} считается деталью реализации.
Пусть в~нашем интерпретаторе это будет

◊indexC{the-uninitialized-marker}
◊code:lisp{
(define the-uninitialized-marker (cons 'not 'initialized))
}

Конечно, теперь необходимо добавить поддержку этого особенного значения в~функцию ◊ic{lookup}.
Функция ◊ic{update!} в~изменениях не~нуждается по очевидным причинам.
Вызовы~◊ic{wrong} отвечают за два различных типа ошибок:
обращение к~несуществующей привязке и получение значения неинициализированной привязки.

◊indexC{lookup}
◊code:lisp{
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (let ((value (cdar env)))
            (if (eq? value the-uninitialized-marker)
                (wrong "Uninitialized binding" id)
                value ) )
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )
}

После блужданий по пустыне~семантики и синтаксиса,
у~нас наконец-то получилась форма ◊ic{letrec},
позволяющая определять локальные взаимно рекурсивные функции.
