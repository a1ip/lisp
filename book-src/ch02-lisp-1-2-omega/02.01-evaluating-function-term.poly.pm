#lang pollen

◊subsection[#:label "lisp1-2-omega/lisp2/ssect:eval-func-term"]{Вычисляем функции}

Возможности окружения функций далеки от возможностей окружения переменных (окружения параметров).
В~частности, как вы видели, мы не~можем вычислить вызываемую функцию.
Традиционный трюк, существующий ещё со~времён Maclisp, заключается в~том,
что если ◊ic{evaluate-application} натыкается на что-то непонятное, то она передаёт его функции ◊ic{f.evaluate}:

◊indexC{evaluate-application}
◊code:lisp{
(define (evaluate-application2 fn args env fenv)
  (cond ((symbol? fn)
         ((lookup fn fenv) args) )
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv ) )
        ;; Не прокатило:
        (else (evaluate-application2
               (f.evaluate fn env fenv) args env fenv)) ) )
}

Теперь наше затруднение решается следующим образом:

◊code:lisp{
(if ◊ii{условие} (+ 3 4) (* 3 4)) ◊(eq) ((if ◊ii{условие} '+ '*) 3 4)
}

Не~особо элегантно из-за этих непонятных кавычек, но по~крайней мере работает.
Настолько хорошо работает, что иногда даже возвращаться не~хочется:

◊code:lisp{
('''''''''''''1789 ◊ii{аргументы})
}

Выражение ◊ic{'''''''''''''1789} сначала будет вычислено тринадцать раз подряд,
пока ◊ic{evaluate-application2} не~доберётся до числа~1789,
которое очевидно не~является функцией —
то есть его надо передать ◊ic{f.evaluate}, чтобы, разумеется, получить число~1789,
которое очевидно не~является функцией◊(dots)
Короче~говоря, надо тщательнее следить за тем, что мы передаём ◊ic{f.evaluate}.

Иногда интерпретатор реализуют другим образом, который, тем не~менее, подвержен той~же проблеме:

◊code:lisp{
(define (evaluate-application3 fn args env fenv)
  (cond
    ((symbol? fn)
     (let ((fun (lookup fn fenv)))
       (if fun (fun args)
           (evaluate-application3 (lookup fn env) args env fenv) ) ) )
    ...
) )
}

Если символ отсутствует в~функциональном окружении, то поиск повторяется уже в~окружении переменных.
Допустим, функция ◊ic{foo} не~определена, тогда что насчёт следующей программы?

◊code:lisp{
(let ((foo 'foo))
  (foo ◊ii{аргументы}) )
}

Нет, можно, конечно, встроить в~◊ic{evaluate-application} защиту и~от этого,
проверяя, совпадает~ли значение переменной с~её именем.
Но, как~говорится, на каждый хитрый~болт:

◊code:lisp{
(let ((flip 'flop)
      (flop 'flip) )
  (flip) )
}

Единственный вариант, который нам пока не~удалось одурачить —
это самый первый на~странице~◊pageref{lisp1-2-omega/lisp2/src:erroneous-eval-application}.
Похоже, для вычисления функций придётся придумать какой-то другой подход.
