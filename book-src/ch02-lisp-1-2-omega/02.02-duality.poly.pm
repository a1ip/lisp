#lang pollen

◊subsection[#:label "lisp1-2-omega/lisp2/ssect:duality"]{Двойственность миров}

Обобщая рассмотренные затруднения, можно сказать,
что существуют вычисления, принадлежащие миру параметров,
которые мы хотим перенести в~мир функций, и~наоборот.
Точнее говоря, мы хотим иметь возможность возвращать функции как результат вычислений
и~использовать функции как параметры других функций.

◊indexC{funcall}
Если абсолютно необходимо, чтобы на месте функции стояло имя функции,
но~в~то~же время мы хотим иметь возможность вычислять необходимую функцию,
то~будет достаточно предопределённой функции, которая знает, как применять функции к~аргументам.
Назовём её ◊ic{funcall} (от~◊english{◊term{function~call}}).
Она применяет свой первый аргумент (который обязан быть функцией) к~остальным.
С~её помощью наша проблема решается следующим образом:

◊code:lisp{
(if ◊ii{условие} (+ 3 4) (* 3 4)) ≡ (funcall (if ◊ii{условие} + *) 3 4)
}

Все аргументы — включая~первый — вычисляются обычной ◊ic{f.evaluate}.
Функция~◊ic{funcall} только берёт всё готовое и выполняет вызов.
Мы~легко можем определить примитив ◊ic{funcall} следующим образом:

◊indexC{funcall}
◊code:lisp{
(lambda (args)
  (if (> (length args) 1)
      (invoke (car args) (cdr args))
      (wrong "Incorrect arity" 'funcall) ) )
}

В~◊Lisp-2 ◊ic{funcall} используется для вызова динамически вычисляемых функций.
Во~всех остальных случаях вызываемая функция известна из текста программы,
равно как и то, что это именно функция, а~не~какое-то другое значение.

Обратите внимание на вызов ◊ic{invoke} в~◊ic{funcall}.
Эта функция проверяет, действительно~ли её аргумент является функцией,
в~отличие от ◊ic{evaluate-application}, где эта проверка не~выполняется.
Функций ◊ic{funcall} больше похожа на ◊ic{apply}:
обе принимают первым аргументом функцию, а~затем её аргументы.
Разница между ними лишь в~том, что ◊ic{funcall} знает количество передаваемых аргументов из текста программы.

◊indexE{+@◊ic{+} (в~◊CommonLisp)}
◊indexE{*@◊ic{*} (в~◊CommonLisp)}
◊indexE{REPL!определение}
◊indexR{интерактивная сессия (REPL)}
К~сожалению, есть ещё одна небольшая проблема.
Когда мы пишем ◊ic{(if~◊ii{условие} +~*)}, мы ожидаем получить функцию сложения или умножения.
Но~то, что мы сейчас получаем — это значение глобальной переменной ◊ic{+} или~◊ic{*}!
В~◊CommonLisp значения этих переменных и близко не~связаны с~арифметикой:
они хранят последнее считанное и возвращённое REPL
◊footnote{
  REPL — ◊english{◊term{read–eval–print loop}}, интерактивная сессия.
  В~интерпретаторе из предыдущей главы ей соответствует функция ◊ic{toplevel}.
}
значение!

◊indexC{function}
◊ic{funcall} даёт возможность проводить вычисления с~функциями как со~значениями.
Конечно~же, в~интерпретаторе присутствует и обратный процесс:
◊ic{evaluate-application} работает со~значениями и вызывает их как функции,
но эти преобразования происходят неявно.
В~присутствии ◊ic{funcall} нам необходимо иметь возможность
явно превратить имя функциональной переменной~◊ic{+} в~соответствующую функцию из окружения функций.
Добавим ещё одно приспособление: ◊ic{function}.
Эта специальная форма принимает имя функции и возвращает соответствующее функциональное значение.
Теперь мы можем свободно перемещаться меж~двух~миров:

◊code:lisp{
(if ◊ii{условие} (+ 3 4) (* 3 4)) ≡ (funcall (if ◊ii{условие} (function +) (function *)) 3 4)
}

Для определения ◊ic{function} достаточно добавить соответствующую обработку в~◊ic{f.evaluate}.
Эта форма~◊ic{function} не~имеет ничего общего с~одноимённой
◊seePage{basics/repr-func/dyn-and-lex-bind/src:closure-eval}
формой ◊ic{(function (lambda ◊ii{переменные} ◊ii{тело}))}, создающей замыкания.
Здесь мы определяем ◊ic{(function ◊ii{имя-функции})}, преобразующую имена функций в~их значения.

◊code:lisp{
...
((function)
 (cond ((symbol? (cadr e))
        (lookup (cadr e) fenv) )
       (else (wrong "Incorrect function" (cadr e))) ) ) ...
}

◊indexC{lambda!как метка}
Мы легко можем расширить это определение, чтобы оно принимало и ◊ic{lambda}-формы,
как это сделано в~◊CommonLisp или у~нас на странице~◊pageref{basics/repr-func/dyn-and-lex-bind/src:closure-eval}.
Но в~этом нет особого смысла, так как наша ◊ic{lambda} сразу возвращает нужное значение.
В~◊CommonLisp такое расширение необходимо,
потому что там ◊ic{lambda} — это не~специальная форма, а~лишь ключевое слово — маркер кода функции.
«Специальной форме» ◊ic{lambda} позволено либо находиться на месте функции,
либо быть первым аргументом специальной формы ◊ic{function}.

Функция ◊ic{funcall} позволяет поместить результат вычислений из мира параметров в~переменную из мира функций.
И~наоборот, ◊ic{function} позволяет поместить значение из мира функций в~переменную из мира параметров.
Здесь усматриваются очевидные параллели:
«применение функций — ◊ic{funcall}» и «разыменование переменных — ◊ic{function}».
Разумеется, если два мира хотят общаться, то им необходимы подобные мосты. 

◊indexR{инлайнинг!функций}
◊indexR{функции!встраиваемые}
◊indexR{встраивание!функций}
Заметьте, что сейчас мы не~имеем возможности изменять функциональное окружение;
у~нас нет соответствующей операции присваивания.
Это позволяет компиляторам без опаски задействовать механизм ◊term{инлайн-функций}.
Одной из привлекательных сторон использования отдельных пространств имён
является возможность наделить каждое из них особыми свойствами.
