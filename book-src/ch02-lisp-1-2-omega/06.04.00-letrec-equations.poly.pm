#lang pollen

◊subsubsection*{Уравнения и~◊ic{letrec}}

◊indexC{letrec!и~уравнения}
С~формой~◊ic{letrec} есть ещё одна серьёзная проблема: её синтаксис не~очень строгий.
При текущей трактовке ◊ic{letrec} допускает в~качестве инициализаторов всё что угодно, не~только функции;
тогда как ◊ic{labels} в~◊CommonLisp разрешает определять исключительно функции.
То~есть в~Scheme теоретически разрешено написать следующее:

◊code:lisp{
(letrec ((x (/ (+ x 1) 2))) x)
}

Заметьте, что переменная~◊ic{x} фактически определяется через саму себя.
Это, похоже, обыкновенное уравнение
◊$${x = \frac{x + 1}{2}}
Логично будет считать значением~◊ic{x} корень этого уравнения.
То~есть такое выражение должно вернуть~◊ic{1}.

Но что делать, если уравнение не~имеет корней или если их несколько?

◊code:lisp{
(letrec ((x (+ x 1))) x)            ; ◊${x = x + 1}
(letrec ((x (+ (power x 37) 1))) x) ; ◊${x = x^{37} + 1}
}

Существуют множества, вроде известного вам множества S-выражений,
где достаточно легко убедиться в~том, что уравнение имеет единственное решение ◊cite{ms80}.
Например, следующим образом можно определить бесконечный список, не~используя побочные эффекты —
как корень «списочного» уравнения:

◊code:lisp{
(letrec ((foo (cons 'bar foo))) foo)
}

◊indexR{ленивые вычисления}
Значением этого выражения может быть
или лениво вычисляемый бесконечный список ◊ic{(bar bar bar~...)}, как это сделано в~◊cite{fw76,pj87},
так и закольцованная структура данных (что проще с~вычислительной точки зрения):

◊code:lisp{
(let ((foo (cons 'bar 'wait)))
  (set-cdr! foo foo)
  foo )
}

Вроде~бы одно и то~же, но на самом деле нет.
В~общем, из-за всех этих неоднозначностей стоит ввести правило,
запрещающее использовать переменную, определяемую ◊ic{letrec}, для определения значения этой~же переменной.
В~двух предыдущих примерах необходимо знать значение~◊ic{x} для того чтобы инициализировать~◊ic{x}.
Теперь они, очевидно, являются ошибочными.
Однако мы помним, что порядок инициализации в~Scheme должен быть неопределённым,
а~значит, некоторые конструкции, допускаемые данным правилом, могут быть ошибочными в~одних реализациях, но работать в~других.
Рассмотрим следующий пример:

◊code:lisp{
(letrec ((x (+ y 1))
         (y 2) )
  x )
}

Если ◊ic{y} инициализируется до~◊ic{x}, то всё в~порядке.
В~противном случае возникает ошибка, потому что
мы хотим прибавить единицу к~переменной~◊ic{y}, которая уже существует, но ещё не~имеет значения.
Некоторые компиляторы Scheme и ML анализируют выражения-инициализаторы
и проводят топологическую сортировку для определения подходящего порядка инициализации.
Естественно, такое решение тоже не~всегда срабатывает:
◊footnote{Например, ◊ic{(42~42)} вполне подходит как корень данного уравнения, но почему именно ◊ic{42}?}

◊code:lisp{
(letrec ((x y) (y x)) (list x y))
}

Рассмотренные примеры напоминают рассуждения о~смысле глобального окружения и семантике ◊ic{define}.
Там возникла похожая проблема:
что делать с~неинициализированными привязками и как узнать о~том, что они вообще существуют.
