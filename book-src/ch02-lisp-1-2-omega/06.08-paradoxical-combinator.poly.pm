#lang pollen

◊subsubsection*{Парадоксальный комбинатор}

◊indexR{комбинаторы!неподвижной точки}
◊indexR{комбинаторы!Y@◊comb{Y}}
◊indexE{Y@◊comb{Y}, комбинатор}
◊indexR{теорема о~неподвижной точке}
◊indexR{неподвижная точка}
◊indexR{лямбда-исчисление@◊${\lambda}-исчисление!комбинаторы}
◊; TODO: ◊comb{Y}-комбинатор должен быть в nobr, подобно ◊${\lambda}-исчислению
Если вы имели дело с~◊${\lambda}-исчислением,
то вы наверняка помните, что такое ◊term{комбинаторы неподвижной точки}
и как записывается самый известный из них — ◊emph{парадоксальный} или ◊comb{Y}-комбинатор.
Функция~◊${f} имеет неподвижную точку ◊${x}, если ◊${f(x) = x}.
Комбинатор~◊comb{Y} принимает функцию ◊${\lambda}-исчисления и возвращает её неподвижную точку.
Эта идея выражена в~одной из наиболее прекрасных и содержательных теорем ◊${\lambda}-исчисления:

◊theorem["Теорема о~неподвижной точке"]{
◊${\exists ◊math-comb{Y}\colon \forall F\colon ◊math-comb{Y} F = F(◊math-comb{Y} F)}
}

В~терминах Лиспа, ◊comb{Y} — это значение выражения

◊code:lisp{
(let ((W (lambda (w)
           (lambda (f)
             (f ((w w) f)) ) )))
  (W W) )
}

◊; TODO: здесь нужен особенный кернинг
◊; TODO: а также все формулы должны быть в nobr
Доказать это утверждение весьма просто.
Если предположить, что ◊comb{Y} — это ◊${(W W)}, то какой должна быть ◊${W},
чтобы выражение ◊${(W W)F} было эквивалентным ◊${F ((W W) F)}?
Очевидно, что функция ◊${W} должна быть ничем иным, как ◊${\lambda W.\lambda F.F ((W W) F)}.
Программа выше лишь записывает эту идею на~Лиспе.

◊indexR{комбинаторы!Z@◊comb{Z}}
◊indexE{Z@◊comb{Z}, комбинатор}
◊indexR{эта-конверсия@◊${\eta}-конверсия}
◊; TODO: ◊term{◊${...}-...} не должен трогать шрифт в формуле, только обычный текст
Правда, здесь возникает небольшое затруднений из-за принятой в~Scheme передачи аргументов по~значению.
Терм ◊ic{((w~w)~f)} не~следует вычислять слишком рано,
поэтому мы вынуждены добавить излишнюю (в~◊${\lambda}-исчислении) ◊term{◊${\eta}-конверсию}.
В~итоге получается так называемый ◊comb{Z}-комбинатор,
где ◊nobr{◊ic{(lambda (x) (...~x))}} означает ◊${\eta}-конверсию:

◊indexC{fix}
◊code:lisp{
(define fix
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda (x) (((w w) f) x))) ) )))
    (d d) ) )
}

Самое сложное в~этом определении — понять, как~же оно работает.
Сейчас мы этим и займёмся.
Определим функцию ◊ic{meta-fact}:

◊indexC{meta-fact}
◊code:lisp[#:label "lisp1-2-omega/recursion/y-combinator/code:meta-fact"]{
(define (meta-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n (f (- n 1))) ) ) )
}

◊; TODO: убедись, что вложенный текст в формулу отображается как положено
Подозрительно похоже на факториал.
Действительно, это ◊ic{fact} — ◊ic{(meta-fact fact)} вычисляет факториал,
разве что несколько медленнее.
Теперь предположим, что мы знаем неподвижную точку~◊${f} функции ◊ic{meta-fact}:
◊${f = ◊ic{(meta-fact ◊${f})}}.
Эта неподвижная точка по определению является решением следующего функционального уравнения относительно~◊${f}:

◊code:lisp{
◊ii{f} = (lambda (n)
      (if (= n 0) 1
          (* n (◊ii{f} (- n 1))) ) )
}

Итак, что~же такое~◊${f}?
Конечно~же всем известный факториал!

◊(bigskip)

Если подумать, то у~нас нет ни~единого основания полагать, что уравнение выше имеет решение —
или что единственным решением является факториал.
(Конечно, эти термины надо~бы определить строго математически, но этот вопрос выходит за рамки данной книги.)
Действительно, есть как минимум ещё одно решение:

◊indexC{fact}
◊code:lisp{
(define (another-fact n)
  (cond ((< n 1) (- n))
        ((= n 1) 1)
        (else (* n (another-fact (- n 1)))) ) )
}

◊indexR{неподвижная точка!наименьшая}
Проверьте, пожалуйста, что ◊ic{another-fact} также является неподвижной точкой ◊ic{meta-fact}.
Анализируя все возможные неподвижные точки, можно прийти к~выводу, что
существует такая область определения, на которой значения всех функций совпадают:
для натуральных чисел все они действительно вычисляют факториал.
Их поведение различно только тогда, когда исходный вариант ◊ic{fact} попадает в~бесконечный цикл.
Для отрицательных целых чисел ◊ic{another-fact} возвращает одно значение,
но и любое другое значение в~принципе удовлетворяет исходному функциональному уравнению.
◊footnote{Более подробное объяснение см.~в~◊cite{man74}.}
Если упорядочить функции по некоторой мере их определённости,
то должна существовать наименьшая неподвижная точка —
наименее определённое решение функционального уравнения.

Математический смысл глобальных рекурсивных определений вроде ◊ic{fact} состоит в~том, что
они определяют функции, являющиеся наименьшими неподвижными точками соответствующих функциональных уравнений.
Когда мы пишем:

◊code:lisp{
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )
}

◊; ◊noindent
то фактически записываем уравнение относительно переменной~◊ic{fact}.
Форма ◊ic{define} решает это уравнение и связывает полученное решение с~переменной~◊ic{fact}.
Такая трактовка уводит нас далеко от обсуждения инициализации глобальных переменных
◊seePage{lisp1-2-omega/recusion/ssect:simple}
и превращает ◊ic{define} в~магический решатель уравнений.
На~самом деле ◊ic{define} реализуется именно так, как написано в~нашем интерпретаторе.
Просто рекурсия в~глобальном окружении при нормальном порядке вычислений действительно определяет наименьшую неподвижную точку.

◊(bigskip)

Хорошо, теперь вернёмся к~◊ic{fix}, нашему ◊comb{Z}-комбинатору,
и~проследим, как~же вычисляется ◊nobr{◊ic{((fix meta-fact) 3)}}.
Помните, что эти функции не~имеют побочных эффектов,
а~значит, результаты вычислений можно свободно подставлять друг в~друга,
чем мы и будем пользоваться.

◊; TODO: просто используй ≡ и → напрямую в исходниках
◊; TODO: и используй их последовательно, для пояснения результата вычислений (последняя строка)
◊indexC{fix}
◊code:lisp{
  ((fix meta-fact) 3)
≡ (((d d)◊where{
         | d ≡ (lambda (w)
         |       (lambda (f)
         |         (f (lambda (x)
         |              (((w w) f) x) )) ) )
         }
    meta-fact )
   3 )
}
◊code:lisp{
≡ (((lambda (f)                 ; шаг I
      (f (lambda (x)
           (((w w) f) x) )) )◊where{
                             | w ≡ (lambda (w)
                             |       (lambda (f)
                             |         (f (lambda (x)
                             |              (((w w) f) x) )) ) )
                             }
    meta-fact )
   3 )
}
◊code:lisp{
≡ ((meta-fact (lambda (x)
                (((w w) meta-fact) x) ))◊where{
                                        | w ≡ (lambda (w)
                                        |       (lambda (f)
                                        |         (f (lambda (x)
                                        |              (((w w) f) x) )) ) )
                                        }
   3 )
}
◊code:lisp{
≡ ((lambda (n)
      (if (= n 0) 1
          (* n (f (- n 1))) ) )◊where{
                               | f ≡ (lambda (x)
                               |       (((w w) meta-fact) x) )◊where{
                                                              | w ≡ (lambda (w)
                                                              |       (lambda (f)
                                                              |         (f (lambda (x)
                                                              |              (((w w) f) x) )) ) )
                                                              }
                               }
   3 )
}
◊code:lisp{
≡ (* 3 (f 2))◊where{
             | f ≡ (lambda (x)
             |       (((w w) meta-fact) x) )◊where{
                                            | w ≡ (lambda (w)
                                            |       (lambda (f)
                                            |         (f (lambda (x)
                                            |              (((w w) f) x) )) )  )
                                            }
             }
}
◊code:lisp{
≡ (* 3 (((w w) meta-fact) 2))◊where{
                             | w ≡ (lambda (w)
                             |       (lambda (f)
                             |         (f (lambda (x)
                             |              (((w w) f) x) )) ) )
                             }
}
◊code:lisp{
≡ (* 3 (((lambda (f)            ; шаг II
            (f (lambda (x)
                 (((w w) f) x) )) )◊where{
                                   | w ≡ (lambda (w)
                                   |       (lambda (f)
                                   |         (f (lambda (x)
                                   |              (((w w) f) x) )) ) )
                                   }
         meta-fact )
        2 ) )
}

Остановимся на минутку, чтобы заметить, что на шаге~II мы получили то~же самое выражение, что и на шаге~I.
Естественно, оно появится и в~третий~раз:

◊code:lisp{
  (* 3 (* 2 (((lambda (f)
                (f (lambda (x)
                     (((w w) f) x) )) )◊where{
                                       | w ≡ (lambda (w)
                                       |       (lambda (f)
                                       |         (f (lambda (x)
                                       |              (((w w) f) x) )) ) )
                                       }
              meta-fact )
             1 )))
}
◊code:lisp{
≡ (* 3 (* 2 ((meta-fact (lambda (x)
                           (((w w) meta-fact) x) ))◊where{
                                                   | w ≡ (lambda (w)
                                                   |       (lambda (f)
                                                   |         (f (lambda (x)
                                                   |              (((w w) f) x) )) ) )
                                                   }
             1 )))
}
◊code:lisp{
≡ (* 3 (* 2 ((lambda (n)
                (if (= n 0) 1
                    (* n (f (- n 1))) ) )◊where{
                                         | f ≡ ...
                                         }
             1 )))
}
◊code:lisp{
≡ (* 3 (* 2 (if (= n 0) 1 (* n (f (- n 1))))))◊where{
                                              | n → 1
                                              | f ≡ ...
                                              }
}
◊code:lisp{
≡ (* 3 (* 2 1))
≡ 6
}

Обратите внимание, что в~процессе вычислений мы действительно получаем функцию, вычисляющую факториал.
Это значение выражения:

◊code:lisp{
(lambda (x)
  (((w w) f) x) )◊where{
                 | f ≡ meta-fact
                 | w ≡ (lambda (w)
                 |       (lambda (f)
                 |         (f (lambda (x)
                 |              (((w w) f) x) )) ) )
                 }
}

◊indexR{самоприменение!и рекурсия}
Идея состоит в~том, что благодаря самоприменению мы помним, как создать заново данную функцию,
и~делаем это каждый раз, когда для вычисления факториала требуется рекурсивный вызов.

◊(bigskip)

◊indexC{define!как решатель уравнений}
Таким образом простая рекурсия определяется без использования побочных эффектов, лишь с~помощью~◊ic{fix}, комбинатора неподвижной точки.
Благодаря~◊comb{Y} (или~◊ic{fix}), форму ◊ic{define} можно определить как решатель рекурсивных уравнений:
она принимает уравнение и связывает решение с~переданным именем.
Если мы передадим ◊ic{define} уравнение для факториала,
то~с~◊ic{fact} будет связано следующее значение:

◊code:lisp{
(fix (lambda (fact)
       (lambda (n)
         (if (= n 0) 1
             (* n (fact (- n 1))) ) ) ))
}

Аналогично можно решать системы уравнений, то~есть определять взаимно рекурсивные функции:

◊indexC{odd?}
◊indexC{even?}
◊code:lisp{
(define odd-and-even
  (fix (lambda (f)
         (lambda (which)
           (case which
             ((odd)  (lambda (n) (if (= n 0) #f
                                     ((f 'even) (- n 1)) )))
             ((even) (lambda (n) (if (= n 0) #t
                                     ((f 'odd)  (- n 1)) ))) ) ) )) )
(define odd?  (odd-and-even 'odd))
(define even? (odd-and-even 'even))
}

Недостатком такого способа определения рекурсивных функций является кошмарная неэффективность,
даже по сравнению с~наивной реализацией~◊ic{letrec}.
(Однако,~см.~◊cite{roz92,ser93}.)
Тем не~менее, метод имеет своих приверженцев, особенно когда нужно выработать норму страниц для~книги.
Функциональные языки тоже не~особо жалуют подобный подход, по мнению ◊cite{pj87},
так~как, во-первых, он неэффективен, а~во-вторых, ◊ic{fix} плохо сочетается с~системами вывода типов.
Действительно, ◊ic{fix} принимает функционал,
◊footnote{Терминология Маккарти из~◊cite{mae+62}: функционал — это функция, принимающая функции как аргументы.}
принимающий функцию типа ◊${\alpha \to \beta},
и~возвращает неподвижную точку этого функционала.
То~есть ◊ic{fix} имеет~тип
◊$${
    \big( (\alpha \to \beta) \to (\alpha \to \beta) \big) \to (\alpha \to \beta)
}

◊indexR{самоприменение!типизация}
В~определении ◊ic{fix} есть самоприменение: ◊ic{(d~d)}.
Обозначив его тип ◊${\gamma}, имеем:
◊$${
    \gamma = \gamma \to (\alpha \to \beta)
}

Потребуется или нетривиальная система типов, чтобы в~ней можно было выразить подобный рекурсивный тип,
или~же мы будем вынуждены определить ◊ic{fix} как примитивную функцию,
потому что её нельзя выразить средствами самого языка.
