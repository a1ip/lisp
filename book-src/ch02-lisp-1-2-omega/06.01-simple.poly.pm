#lang pollen

◊subsection[#:label "lisp1-2-omega/recusion/ssect:simple"]{Простая рекурсия}

◊indexR{рекурсия!простая}
Наверное, наиболее известной простой рекурсивной функцией является факториал,
определяемый следующим образом:

◊indexC{fact}
◊code:lisp{
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )
}

Наш интерпретатор пока ещё не~знает, что такое ◊ic{define},
так~что представим, что это макрос:

◊code:lisp{
(set! fact (lambda (n)
             (if (= n 0) 1
                 (* n (fact (- n 1))) ) ))
}

◊indexR{привязки (bindings)!неинициализированные}
Здесь мы видим присваивание переменной ◊ic{fact}, то~есть изменение её значения.
Это операция бессмысленна, если переменная ◊ic{fact} не~существует.
Глобальное окружение можно считать местом, где уже существуют все возможные переменные.
В~этой ◊emph{виртуальной реальности} интерпретатор
(а~точнее, его часть, ответственная за чтение программ)
создаёт глобальную привязку для переменной, когда впервые встречает её~имя,
и~невозмутимо продолжает работу.
Определение переменных теперь сводится к~присваиванию им первоначальных значений.
Такой подход оставляет возможность для ошибок, когда переменная используется до своего определения —
если переменная упоминается в~программе, но никогда не~инициализируется.
Как видите, идея привязок не~так уж и проста, мы займёмся ею подробнее в~четвёртой~главе.
◊seePage{chapter:assignment}

◊indexC{define}
Можно избавиться от проблем с~привязками, которые существуют, но еще не~инициализированы, если принять другую позицию.
Пусть изменять можно только существующие переменные;
иными словами, переменной нет, если она не~была определена явно.
Соответственно, необходим механизм для определения переменных — специальная форма ◊ic{define}.
Обращение к~неопределённой переменной или попытка присваивания неизвестной переменной являются ошибками.
Однако, посмотрим теперь на это с~другой стороны:

◊code:lisp[#:label "lisp1-2-omega/recusion/simple/code:redefine"]{
(define (display-pi)
  (display pi) )
(define pi 2.7182818285)    ; ой, не та константа
(define (print-pi)
  (display pi) )
(define pi 3.1415926536)
}

Допустимо~ли такое определение ◊ic{display-pi}?
Функция ссылается на переменную~◊ic{pi}, которая ещё не~определена.
Четвёртый~◊ic{define} исправляет ошибку во~втором;
но~даже если ◊ic{define} создаёт новую привязку, можно~ли создать ещё одну с~таким~же именем?

Эти вопросы не~имеют однозначного ответа.
Есть как минимум два варианта:
считать глобальные определения лексическими (так поступает~ML)
или~считать их динамическими (как принято в~Лиспе).

◊indexR{окружение!глобальное!гиперстатическое}
◊indexR{глобальное окружение!гиперстатическое}
◊indexR{гиперстатическое окружение}
◊phantomlabel{lisp1-2-omega/recusion/simple/par:hyperstatic}
В~глобальном окружении, которое полностью лексично — будем называть его ◊term{гиперстатическим}, —
мы не~можем использовать переменную (ссылаться на неё, получать или изменять её значение),
если она не~существует.
В~нём определение функции ◊ic{display-pi} будет ошибочным,
так как оно ссылается на переменную~◊ic{pi}, которая не~существует на момент определения.
Любой вызов функции ◊ic{display-pi} привёл~бы к~ошибке «Неизвестная переменная:~◊ic{pi}»
(если это не~случилось ещё при её определении).
С~функцией ◊ic{print-pi} всё в~порядке —
она будет выводить значение, существовавшее на момент её определения
(в~данном случае это ◊ic{2.7182818285}),
и~ничто не~сможет изменить выводимое значение.
Переопределение~◊ic{pi} вполне~допустимо и создаст новую переменную~◊ic{pi},
которая будет использоваться в~последующих выражениях в~пределах своей области видимости.
Предыдущий пример можно понимать примерно таким образом:

◊code:lisp{
(let ((display-pi (lambda () (display pi))))
  (let ((pi 2.7182818285))
    (let ((print-pi (lambda () (display pi))))
      (let ((pi 3.1415926536))
        ... ) ) ) )
}

В~Лиспе, как было сказано, принят динамический подход.
Предполагается, что может существовать не~более одной глобальной переменной с~уникальным именем,
и~эта переменная видна везде, в~том числе в~своём собственном определении.
Лисп поддерживает опережающие ссылки без какого-либо специального синтаксиса.
(Под таким синтаксисом понимаются явные объявления вроде ключевого слова ◊ic{forward} Паскаля
или прототипов ISO~C.~◊seeCite{iso90})

Выбор трактовки переменных — это вопрос не~только философии языка.
Возвращаясь к~факториалу;
в~окружении, где будет вычисляться ◊ic{lambda}-форма, необходимо ответить на вопрос:
«Что здесь означает ◊ic{fact}?»
Если вычисление происходит в~глобальном окружении, где нет привязки для ◊ic{fact},
то~эта функция в~принципе не~может быть рекурсивной.
Тело ◊ic{lambda}-формы ссылается на некую переменную ◊ic{fact},
значение которой следует искать в~окружении, захваченном замыканием
(которое состоит из свободных переменных и параметров функции).
Так как в~момент создания замыкания переменная ◊ic{fact} не~существовала, то~и в~окружении её нет.
Следовательно, для рекурсии её необходимо каким-то образом туда добавить.
Проще всего это сделать, выбрав динамический подход к~глобальному окружению,
который снимает вопрос существования переменных в~принципе.
При гиперстатическом~же подходе надо убедиться в~том, что
◊ic{define} создаёт привязку для ◊ic{fact} перед тем, как вычислять замыкание,
которое станет значением ◊ic{fact}.
Подводя итог: простая рекурсия требует глобального окружения.
