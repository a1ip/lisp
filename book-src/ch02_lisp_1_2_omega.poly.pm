% -*- coding: utf-8 -*-

◊subsection{Вычисляем функции}◊label{lisp1-2-omega/lisp2/ssect:eval-func-term}

Возможности текущего окружения функций ещё далеки от возможностей окружения
переменных (окружения параметров).
В~частности, как вы видели, мы не~можем
вычислить применяемую функцию.
Традиционный трюк, существующий ещё со~времён
Maclisp, заключается в~том, что если ◊ic{evaluate-application} натыкается на
что"~то непонятное, то она передаёт его функции ◊ic{f.evaluate}:

◊indexC{evaluate-application}
◊begin{code:lisp}
(define (evaluate-application2 fn args env fenv)
  (cond ((symbol? fn)
         ((lookup fn fenv) args) )
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv ) )
        [(else (evaluate-application2]
               [(f.evaluate fn env fenv) args env fenv))] ) )
◊end{code:lisp}

Теперь наша проблема решается следующим образом:

◊begin{code:lisp}
(if |◊ii{условие}| (+ 3 4) (* 3 4)) |◊eq| ((if |◊ii{условие}| '+ '*) 3 4)
◊end{code:lisp}

Не~особо элегантно, так как необходимо писать лишние кавычки, но по крайней мере
это работает.
Работает, но, пожалуй, чересчур прилежно; иногда настолько, что
попадает в~бесконечный цикл.

◊begin{code:lisp}
('''''''''''''1789 |◊ii{аргументы}|)
◊end{code:lisp}

Выражение ◊ic{'{}'{}'{}'{}'{}'{}'{}'{}'{}'{}'{}'{}'1789} сначала будет
вычислено тринадцать раз подряд, пока ◊ic{evaluate-application2} не~доберётся до
числа~1789, а затем она попадёт в~бесконечный цикл, так как 1789 — это
не~функция и не~символ, а значит, его надо передать в~◊ic{f.evaluate},
чтобы◊textdots◊ получить опять число~1789! Короче~говоря, надо тщательнее
следить за тем, что передаётся ◊ic{f.evaluate}.
Проблема остаётся даже тогда,
когда мы перепишем интерпретатор следующим образом:

◊begin{code:lisp}
(define (evaluate-application3 fn args env fenv)
  (cond
    ((symbol? fn)
     (let ((fun (lookup fn fenv)))
       (if fun (fun args)
           (evaluate-application3 (lookup fn env) args env fenv) ) ) )
    ...
) )
◊end{code:lisp}

В~этом случае, если символ отсутствует в~функциональном окружении, то поиск
повторяется уже в~окружении переменных.
Ой! Даже если предположить, что
не~существует функции ◊ic{foo}, мы спокойно можем зациклиться при вычислении
значения переменной.
Например:

◊begin{code:lisp}
(let ((foo 'foo))
  (foo |◊ii{аргументы}|) )
◊end{code:lisp}

Нет, можно, конечно, встроить в~◊ic{evaluate-application} защиту от этого,
проверяя, совпадает~ли значение переменной с~её именем.
Но ведь можно написать
и~так:

◊begin{code:lisp}
(let ((flip 'flop)
      (flop 'flip) )
  (flip) )
◊end{code:lisp}

Единственный вариант, который пока не~удалось одурачить — это самый первый на
странице~◊pageref{lisp1-2-omega/lisp2/src:erroneous-eval-application}, поэтому
необходимо найти другой метод вычисления функционального элемента формы.


◊subsection{Двойственность миров}◊label{lisp1-2-omega/lisp2/ssect:duality}

Обобщая данные затруднения, можно сказать, что есть некоторые вычисления,
принадлежащие миру параметров, которые мы хотим перенести в~мир функций,
и~наоборот.
Точнее говоря, мы хотим иметь возможность возвращать функцию как
результат вычислений и передавать её как аргумент вычислений.

◊indexC{funcall}
Если абсолютно необходимо, чтобы на месте функции стояло имя функции, но в~то~же
время мы хотим иметь возможность вычислять необходимую функцию, то будет
достаточно предопределённой функции, которая знает, как применять функции
к~аргументам.
Назовём её ◊ic{funcall} (от~◊term{function call}).
Она применяет
свой первый аргумент (который обязан быть функцией) к~остальным.
С~её помощью
наша проблема решается следующим образом:

◊begin{code:lisp}
(if |◊ii{условие}| (+ 3 4) (* 3 4)) |◊eq| (funcall (if |◊ii{условие}| + *) 3 4)
◊end{code:lisp}

Все аргументы (первый в~том числе) вычисляются обычной ◊ic{f.evaluate}.
Функция~◊ic{funcall} только берёт всё готовое и выполняет вызов.
Мы легко можем
определить ◊ic{funcall} как

◊indexC{funcall}
◊begin{code:lisp}
(define (funcall .
args)
  (if (> (length args) 1)
      (invoke (car args) (cdr args))
      (wrong "Incorrect arity" 'funcall) ) )
◊end{code:lisp}

В~◊Lisp2 ◊ic{funcall} используется для динамического вычисления функций.
Во~всех
остальных случаях функция известна и не~требуется проверять, действительно~ли
это функция.

Обратите внимание на вызов ◊ic{invoke} в~◊ic{funcall}.
Эта функция проверяет,
действительно~ли её аргумент является функцией, в~отличие от
◊ic{evaluate-application}, где эта проверка не~выполняется.
Функций ◊ic{funcall}
больше похожа на ◊ic{apply}: обе принимают первым аргументом функцию, а за ним
— необходимые аргументы.
Разница между ними лишь в~том, что ◊ic{funcall}
статически знает количество передаваемых аргументов.

◊indexE{+@◊ic{+} (в~◊protect◊CommonLisp)}
◊indexE{*@◊ic{*} (в~◊protect◊CommonLisp)}
◊indexE{REPL!определение}
◊indexR{интерактивная сессия (REPL)}
К~сожалению, есть ещё одна небольшая проблема.
Когда мы пишем ◊ic{(if
◊ii{условие} +~*)}, мы ожидаем получить функцию сложения или умножения.
Но то,
что мы сейчас получаем, — это значение переменной ◊ic{+} или~◊ic{*}!
В~{◊CommonLisp} значения этих переменных и близко не~связаны с~арифметикой: они
хранят последнее считанное и последнее возвращённое REPL◊trnote*{REPL —
«◊term{read--eval--print loop}», интерактивная сессия.
В~интерпретаторе из
предыдущей главы ей соответствует функция ◊ic{toplevel}.} значение!

◊indexC{function}
Мы ввели ◊ic{funcall} для того, чтобы получить возможность проводить вычисления
с~функциями как со~значениями.
Конечно~же, в~интерпретаторе присутствует и
обратный процесс: ведь ◊ic{evaluate-application} получает именно такие значения
и вызывает их как функции; но эти преобразования происходят неявно.
В~присутствии ◊ic{funcall} нам необходимо иметь возможность явно превратить имя
функциональной переменной~◊ic{+} в~соответствующую функцию из окружения функций.
Для этого мы введём ещё одно приспособление: ◊ic{function}.
Эта специальная
форма принимает имя функции и возвращает соответствующее функциональное
значение.
Теперь мы можем свободно перемещаться меж двух миров:

◊begin{code:lisp}
(if |◊ii{условие}| (+ 3 4) (* 3 4)) |◊equals|
       |◊equals| (funcall (if |◊ii{условие}| (function +) (function *)) 3 4)
◊end{code:lisp}

Для определения ◊ic{function} достаточно добавить соответствующую обработку
в~◊ic{f.evaluate}.
Эта форма~◊ic{function} не~имеет ничего общего с~одноимённой
◊seePage[basics/repr-func/dyn-and-lex-bind/src:closure-eval] формой
◊ic{(function (lambda ◊ii{переменные} ◊ii{тело}))}, создающей замыкания.
Здесь
мы определяем ◊ic{(function ◊ii{имя-функции})}, преобразующую имена функций
в~их значения.

◊begin{code:lisp}
...
((function)
 (cond ((symbol? (cadr e))
        (lookup (cadr e) fenv) )
       (else (wrong "Incorrect function" (cadr e))) ) ) ...
◊end{code:lisp}

◊indexCS{lambda}{как метка}
Мы легко можем расширить это определение, чтобы оно принимало и
◊ic{lambda}-формы, как это сделано в~{◊CommonLisp} или у~нас на
странице~◊pageref{basics/repr-func/dyn-and-lex-bind/src:closure-eval}.
Но в~этом
нет особого смысла, так как наша ◊ic{lambda} сразу возвращает нужное значение.
В~{◊CommonLisp} такое расширение необходимо, потому что там ◊ic{lambda} лишь
помечает код функции и «специальной форме» ◊ic{lambda} позволено или
находиться на месте функции, или быть первым аргументом специальной формы
◊ic{function}.

Функция ◊ic{funcall} позволяет поместить результат вычислений из мира параметров
в~переменную из мира функций.
И~наоборот, ◊ic{function} позволяет поместить
значение из мира функций в~переменную из мира параметров.
В~них усматриваются
очевидные параллели: «применение функций — ◊ic{funcall}» и «разыменование
переменных — ◊ic{function}».
Одновременное существование двух миров и
возможность общения между ними требуют подобных мостов.

◊indexR{инлайнинг!функций}
◊indexR{функции!встраиваемые}
◊indexR{встраивание!функций}
Заметьте, что сейчас мы не~имеем возможности изменять функциональное окружение;
у~нас нет соответствующего присваивания.
Это позволяет компиляторам без опаски
и в~полную силу задействовать механизм ◊term{инлайн-функций}.
Одной из
привлекательных сторон использования нескольких пространств имён является
возможность наделить каждое из них особыми свойствами.


◊subsection{◊texorpdfstring{Используем ◊protect◊Lisp2}{Используем Lisp₂}}%
◊label{lisp1-2-omega/lisp2/ssect:using}

Чтобы полностью определить наш ◊Lisp2, остаётся указать начальное функциональное
окружение и запустить в~цикле сам интерпретатор, ◊ic{f.evaluate}.
Определение
глобального функционального окружения мало чем отличается от окружения
переменных: надо всего лишь расширять другое начальное окружение.

◊indexC{fenv.global}
◊indexC{definitial-function}
◊indexC{defprimitive}
◊begin{code:lisp}
(define fenv.global '())

(define-syntax definitial-function
  (syntax-rules ()
    ((definitial-function name)
     (begin (set! fenv.global (cons (cons 'name 'void) fenv.global))
            'name) )
    ((definitial-function name value)
     (begin (set! fenv.global (cons (cons 'name value) fenv.global))
            'name) ) ) )

(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial-function name
       (lambda (values)
         (if (= arity (length values))
             (apply value values)
             (wrong "Incorrect arity"
              (list 'name 'values) ) ) ) ) ) ) )

(defprimitive car car 1)
(defprimitive cons cons 2)
◊end{code:lisp}

◊noindent
И~наконец:

◊begin{code:lisp}
(define (|◊fbox{◊ii{бесспорно ◊Lisp2}}|)
  (define (toplevel)
    (display (f.evaluate (read) env.global fenv.global))
    (toplevel) )
  (toplevel) )
◊end{code:lisp}


◊subsection{Расширяем функциональное~окружение}%
◊label{lisp1-2-omega/lisp2/ssect:enriching}

◊indexR{окружение!как тип данных}
Все окружения — это объекты некоторого абстрактного типа данных.
Что мы
ожидаем от этого типа данных? Мы ожидаем, что он будет хранить связи между
именами и сущностями, что мы можем по имени отыскать нужную сущность, и что мы
можем добавлять новые связи.
Ещё мы хотим иметь возможность определять локальные
функции, а для этого необходим механизм локального расширения функционального
окружения.
В~общем, хочется ◊ic{let}, но только для функций.
Сейчас
функциональное окружение неизменяемо, так что было~бы здорово иметь такую
возможность.
Создадим новую специальную форму ◊ic{flet} (◊term{functional let})
со~следующим синтаксисом:

◊indexC{flet}
◊begin{code:lisp}
(flet ((|◊ii{имя◊sub1}| |◊ii{аргументы◊sub1}| |◊ii{тело◊sub1}|)
        ...
       (|◊ii{имя◊sub{n}}| |◊ii{аргументы◊sub{n}}| |◊ii{тело◊sub{n}}|) )
  |◊ii{выражения}|...
)
◊end{code:lisp}

Так как ◊ic{flet} умеет создавать только локальные функции, нет необходимости
писать ◊ic{lambda}, это и так подразумевается.
Специальная форма ◊ic{flet}
вычисляет формы ◊ic{(lambda ◊ii{аргументы◊sub{i}} ◊ii{тело◊sub{i}})} и связывает
получаемые значения с~именами~◊ii{имя◊sub{i}} в~функциональном окружении.
После
этого ◊ii{выражения} вычисляются в~расширенном окружении, где можно ставить
◊ii{имя◊sub{i}} на место функции или передавать его в~◊ic{function}, если
понадобится соответствующее ◊nohyp{замыкание}.

Добавить ◊ic{flet} в~◊ic{f.evaluate} просто:

◊begin{code:lisp}
...
((flet)
 (f.eprogn
  (cddr e)
  env
  (extend fenv
          (map car (cadr e))
          (map (lambda (def)
                 (f.make-function (cadr def) (cddr def) env fenv) )
               (cadr e) ) ) ) ) ...
◊end{code:lisp}

Форма ◊ic{flet} серьёзно расширяет наши возможности: например, она позволяет
◊ic{lambda} замыкать в~себе не~только ◊ic{env}, но и~◊ic{fenv}.
Рассмотрим
пример:

◊begin{code:lisp}
(flet ((square (x) (* x x))
  (lambda (x) (square (square x))) )
◊end{code:lisp}

Значением этого выражения является анонимная функция, возводящая число
в~четвёртую степень.
Это замыкание сохраняет в~себе и использует локальную
функцию~◊ic{square}.


◊section{Другие возможности}◊label{lisp1-2-omega/sect:extensions}

Как только мы заставили вычислитель относиться по-особенному к~функциям, на ум
сразу~же приходят другие варианты использования этой возможности.
Например, мы
могли~бы трактовать числа как функции-аксессоры для списков:

◊begin{code:lisp}
(2 '(foo bar hux wok))  |◊is| hux
(-2 '(foo bar hux wok)) |◊is| (hux wok)
◊end{code:lisp}

Число~$n$ считается синонимом для~◊ic{cad◊sup{$n$}r}, если оно неотрицательно,
или ◊ic{cd◊sup{$-n$}r}, если оно меньше ноля.
Базовым аксессорам ◊ic{car} и
◊ic{cdr} соответствуют числа ◊ic{0} и~◊ic{-1}.
После этого элементарно
реализуются чисто алгебраические преобразования $◊text{◊ic{(-1~(-2~$◊pi$))}}
◊eq ◊text{◊ic{(-3~$◊pi$)}}$ или $◊text{◊ic{(2~(-3~$◊pi$))}} ◊eq
◊text{◊ic{(5~$◊pi$)}}$.

Также можно придать смысл спискам функций на месте функции:

◊begin{code:lisp}
((list + - *) 5 3) |◊is| (8 2 15)
◊end{code:lisp}

Применение списка функций возвращает список из результатов применения каждого
элемента-функции к~соответствующим аргументам.
Фактически, предыдущий пример
— это краткая запись для

◊begin{code:lisp}
(map (lambda (f) (f 5 3))
     (list + - *) )
◊end{code:lisp}

Наконец, мы могли~бы разрешить функции быть вторым элементом аппликации,
эмулируя привычную инфиксную запись: выражение~◊ic{(1 + 2)} вернёт~◊ic{3}.
К~примеру, такое поведение реализовано в~DWIM из~◊cite{tei74,tei76}.

Но, во-первых, подобные инновации опасны, так как они уменьшают количество явно
ошибочных форм, а значит, затрудняют поиск ошибок, которые иначе~бы легко
находились.
Во-вторых, они не~дают какой"~либо существенной экономии и в~конце
концов редко используются.
В"~третьих, они ещё сильнее разделяют функции и
функциональные объекты, которые можно применять как функции.
Списки или числа
становятся вызываемыми, но вовсе не~обязуются быть функциями.
В~итоге становятся
возможными безобразия вроде

◊begin{code:lisp}
(apply (list 2 (list 0 (+ 1 2)))
       '(foo bar hux wok) )
   |◊is| (hux (foo wok))
◊end{code:lisp}

Поэтому не~рекомендуется реализовывать данные инновации как часть базового
языка.
◊seeEx[lisp1-2-omega/ex:innovations]


◊section{◊texorpdfstring{Сравнение ◊protect◊Lisp1~и~◊protect◊Lisp2}%
{Сравнение Lisp₁ и Lisp₂}}%
◊label{lisp1-2-omega/sect:comparison}

Подходя к~окончанию наших исследований ◊Lisp1 и~◊Lisp2, что мы можем сказать
в~итоге об~этих двух подходах?

◊indexR{пространства имён}
◊indexE{Lispn@◊protect◊Lisp{◊protect◊ii{n}}}
◊indexR{Лисп!Lispn@◊protect◊Lisp{◊protect◊ii{n}}}
Scheme является ◊Lisp1, на нём приятно программировать и ему легко обучать, так
как процесс вычислений прост и последователен.
◊Lisp2~же более сложен, потому
что существование двух миров требует использования особых форм для перехода
между ними.
{◊CommonLisp} является не~совсем ◊Lisp2, так как имеет множество
других пространств имён: для меток лексических переходов, для меток форм
◊ic{tagbody} {◊itd} Поэтому иногда его называют~◊Lisp{◊ii{n}}, так как одно и
то~же имя может вести себя различными способами в~зависимости от синтаксической
роли.
Языки со~строгим синтаксисом (или, как говорят, с~деспотичным синтаксисом)
часто имеют множество пространств имён или множество окружений (для переменных,
для функций, для типов {◊itd}).
Каждое из этих окружений имеет свои
особенности.
Например, если функциональное окружение неизменяемо (то~есть
функциям нельзя присваивать новые значения), то становится очень легко
оптимизировать вызовы локальных функций.

В~программах на ◊Lisp2 функции чётко отделены от остальных вычислений.
Это очень
выгодное разграничение, так что, по мнению ◊cite{sen89}, его следует применять
всем хорошим компиляторам Scheme.
Внутри них программы переводятся на
◊Lisp2-язык, который удаётся лучше компилировать.
Компилятор чётко определяет
каждое место, куда необходимо вставить ◊ic{funcall}, — те места, где функции
вычисляются динамически.
Пользователи ◊Lisp2 вынуждены делать часть работы
компилятора вручную, так что в~итоге они лучше понимают стоимость использования
своих конструкций.

◊indexE{Lisp2@◊protect◊Lisp2}
◊indexR{Лисп!Lisp2@◊protect◊Lisp2}
На предыдущих страницах мы разобрали довольно много вариаций, так что сейчас
будет полезным собрать всё воедино и дать ещё одно определение — простейшее
из возможных — очередного ◊Lisp2-языка, похожего на {◊CommonLisp}.
В~этот раз
мы ограничимся только введением функции ◊ic{f.lookup}, которая ищет функцию по
имени в~функциональном окружении, а если не~находит, то вызывает ◊ic{wrong}.
Это
позволит гарантировать конечное время выполнения ◊ic{f.lookup}.
Конечно,
следствием такого похода будет появление своеобразных ошибок замедленного
действия, так как само по себе обращение к~неопределённой функции не~считается
ошибочным.
Проблемы возникают лишь при попытке вызова, которая может произойти
гораздо позже, а то и вовсе никогда.

◊indexC{f.evaluate}
◊indexC{f.evaluate-application}
◊indexC{f.lookup}
◊begin{code:lisp}
(define (f.evaluate e env fenv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (f.evaluate (cadr e) env fenv)
                      (f.evaluate (caddr e) env fenv)
                      (f.evaluate (cadddr e) env fenv) ))
        ((begin)  (f.eprogn (cdr e) env fenv))
        ((set!)   (update! (cadr e)
                           env
                           (f.evaluate (caddr e) env fenv) ))
        ((lambda) (f.make-function (cadr e) (cddr e) env fenv))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (f.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((flet)
         (f.progn (cddr e)
                  env
                  (extend fenv (map car (cadr e))
                          (map (lambda (def)
                                 (f.make-function (cadr def)
                                                  (cddr def)
                                                  env fenv ) )
                               (cadr e) ) ) ) )
        ((labels)
         (let ((new-fenv (extend fenv
                                 (map car (cadr e))
                                 (map (lambda (def) 'void)
                                      (cadr e) ) )))
           (for-each (lambda (def)
                       (update! (car def)
                                new-fenv
                                (f.make-function (cadr def) (cddr def)
                                                 env new-fenv ) ) )
                     (cadr e) )
           (f.eprogn (cddr e) env new-fenv) ) )
        (else (f.evaluate-application (car e)
                                      (f.evlis (cdr e) env fenv)
                                      env
                                      fenv )) ) ) )

(define (f.evaluate-application fn args env fenv)
  (cond ((symbol? fn)
         ((f.lookup fn fenv) args) )
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv ) )
        (else (wrong "Incorrect functional term" fn)) ) )

(define (f.lookup id fenv)
  (if (pair? fenv)
      (if (eq? (caar fenv) id)
          (cdar fenv)
          (f.lookup id (cdr fenv)) )
      (lambda (values)
        (wrong "No such functional binding" id) ) ) )
◊end{code:lisp}

Ещё одно важное, по мнению ◊cite{gp88}, практическое различие между ◊Lisp1 и
◊Lisp2 состоит в~читабельности.
Хотя, конечно, опытные программисты вряд~ли
будут писать что"~то вроде:

◊begin{code:lisp}
(defun foo (list)
  (list list) )
◊end{code:lisp}

◊indexR{самоприменение!в~◊protect◊Lisp1 и~◊protect◊Lisp2}
◊noindent
С~точки зрения ◊Lisp1, ◊ic{(list~list)} — это вполне~допустимое
самоприменение,◊footnote*{Существуют и другие самоприменения, которые имеют
смысл, хотя их и не~особо много.
Например, ◊ic{(number?~number?)}.} но в~◊Lisp2
это выражение имеет совершенно различный смысл.
В~{◊CommonLisp} эти два имени
принадлежат различным окружениям и не~конфликтуют.
Тем не~менее, лучше избегать
подобного стиля именования и не~называть локальные переменные именами известных
глобальных функций; это поможет избежать проблем с~макросами и сделает программы
менее зависимыми от используемого диалекта.

◊indexR{макросы!в~◊protect◊Lisp1 и~◊protect◊Lisp2}
Следующее отличие между ◊Lisp1 и ◊Lisp2 заключается в~собственно макросах.
В~{◊CommonLisp} довольно непросто написать макрос, раскрывающийся
в~◊ic{lambda}-форму, который был~бы полезен, например, при реализации объектной
системы.
Дело в~том, что {◊CommonLisp} ограничивает места, где может появляться
◊ic{lambda}.
Она может стоять только на месте функции, так что конструкция
◊ic{(...
(lambda~...) ...)} вызовет ошибку в~{◊CommonLisp}.
Единственное
исключение — ◊ic{lambda} может быть первым аргументом ◊ic{function}.
Но сама
◊ic{function} может быть только параметром функции, так что ◊ic{((function
(lambda~...)) ...)} — это снова ошибка.
Если макрос не~знает, где именно он
раскроется: как аргумент или как функция, то его нельзя использовать без
некоторого усложнения программ.
Для той~же системы объектов, например, придётся
раскрывать макрос в~◊ic{(function (lambda~...))}, а потом вручную оборачивать
его в~◊ic{funcall} там, где он вызывается как функция.

◊indexR{конфликт имён}
◊indexR{область видимости!конфликт имён}
Наконец, стоит упомянуть радикальное решение, используемое многими языками.
Можно запретить использование одного и того~же имени даже в~различных
окружениях.
Предыдущий пример с~◊ic{list} вызвал~бы ошибку, так как
имя~◊ic{list} уже используется в~функциональном окружении.
Практически все
реализации Лиспа и Scheme запрещают переменной иметь то~же имя, что и функция
или макрос.
Такое правило действительно облегчает жизнь.


◊section{Пространства имён}◊label{lisp1-2-omega/sect:namespaces}

◊indexR{пространства имён}
◊term{Окружения} устанавливают соответствия между именами и объектами.
На данный
момент нам известны два типа окружений: обычное окружение ◊ic{env} и
функциональное ◊ic{fenv}.
Причина, по которой они разделены, состоит в~желании
ускорить вызовы функций и отделить функции от переменных.
Но это разделение
потребовало от нас ввода двух различных вычислителей, а также механизма переноса
сущностей одного окружения в~другое, — и это усложнило язык.
При обсуждении
динамических переменных мы упомянули, что современные диалекты Лиспа (вроде
ILOG~Talk, {◊EuLisp}, {◊ISLisp}) помещают динамические переменные в~отдельное
пространство имён.
Сейчас мы подробнее рассмотрим это решение.
Занимаясь этим,
мы проиллюстрируем саму идею ◊term{пространств имён}.

◊bigskip

◊indexR{привязки (bindings)}
◊indexR{привязки (bindings)|seealso{связывание}}
◊indexR{привязки (bindings)!захват}
◊indexR{объекты!второго класса}
Окружения можно понимать как абстрактный тип данных.
Они содержат
◊term{привязки} (bindings) объектов к~их именам.
Объекты могут быть как
значениями (полноценными объектами первого класса, которые можно передавать,
копировать, присваивать {◊itd}), так и сущностями (объектами второго класса,
которыми можно оперировать лишь посредством их имён и, обычно, только
с~помощью ограниченного числа специальных форм или иных синтаксических
конструкций).
В~данный момент нам известен только один тип подобных сущностей
— сами привязки.
Они существуют лишь потому, что они — это нечто,
захватываемое замыканиями.
Мы рассмотрим их свойства подробнее, когда будем
изучать побочные эффекты.

Есть множество способов использования окружений.
Нас может интересовать,
присутствует~ли какое"~то имя в~окружении; мы можем искать объект по его имени;
мы можем искать саму привязку, чтобы изменить её.
Мы также можем изменять
окружение, добавляя в~него новые привязки, будь это текущее, локальное или
глобальное окружение.
Конечно~же, не~все возможности необходимы для каждого
из окружений.
В~действительности, многие окружения полезны именно благодаря
накладываемым ими ограничениям.
Следующая таблица показывает особенности
окружения переменных Scheme:

◊begin{envtable}
Ссылка      & ◊ii{x}                             ◊◊
Значение    & ◊ii{x}                             ◊◊
Изменение   & ◊ic{(set! ◊ii{x} ...)}             ◊◊
Расширение  & ◊ic{(lambda (...
◊ii{x} ...) ...)} ◊◊
Определение & ◊ic{(define ◊ii{x} ...)}           ◊◊
◊end{envtable}

Мы будем использовать такие таблицы и понятия из них довольно часто при
обсуждении свойств окружений, так что остановимся на них подробнее.
Первая
строка показывает синтаксис, используемый для получения ссылки на переменную,
обращения к~ней.
Вторая строка показывает синтаксис, используемый для получения
значения переменной.
В~данном случае они совпадают, но так бывает отнюдь
не~всегда.
Третья строка показывает, как связать переменную с~другим значением.
Четвёртая строка показывает, как расширить окружение локальных переменных новой
привязкой: с~помощью ◊ic{lambda}-формы или, конечно~же, макросов вроде ◊ic{let}
или ◊ic{let*}, раскрывающихся в~◊ic{lambda}-формы.
Наконец, последняя строка
показывает, как определить глобальную переменную.
Не~волнуйтесь, если эти
различия сейчас для вас кажутся чересчур тонкими и излишними, мы и в~дальнейшем
будем использовать подобные таблицы для пояснения вариантов использования
переменных, а там различия будут более заметными.

Например, пространство имён функций ◊Lisp2, рассмотренного в~начале главы,
описывается следующей таблицей:

◊begin{envtable}
Ссылка      & ◊ic{(◊ii{f} ...)}                      ◊◊
Значение    & ◊ic{(function ◊ii{f})}                 ◊◊
Изменение   & запрещено                              ◊◊
Расширение  & ◊ic{(flet (...
(◊ii{f} ...) ...) ...)} ◊◊
Определение & не~рассматривалось ранее (◊ic{defun})  ◊◊
◊end{envtable}


◊subsection{Динамические переменные}%
◊label{lisp1-2-omega/namespaces/ssect:dyn-vars}

◊indexR{динамические переменные}◊indexR{переменные!динамические}
◊indexR{динамическое окружение}◊indexR{окружение!динамическое}
◊term{Динамические переменные} принципиально отличаются от лексических, поэтому
имеет смысл отличать их также и на уровне окружений.
Следующая таблица
показывает желаемые свойства нашего нового окружения, окружения динамических
переменных:

◊begin{envtable}
Ссылка      & не~может быть получена                        ◊◊
Значение    & ◊ic{(dynamic ◊ii{d})}                         ◊◊
Изменение   & ◊ic{(dynamic-set! ◊ii{d} ...)}                ◊◊
Расширение  & ◊ic{(dynamic-let (...
(◊ii{d} ...) ...) ...)} ◊◊
Определение & здесь не~рассматривается                      ◊◊
◊end{envtable}

Окружение учитывает новые особенности: можно создавать локальные динамические
переменные◊footnote{Название «локальные переменные» не~совсем удачно, так как
поведение динамических переменных кардинально отличается от поведения обычных
(лексических) переменных.} с~помощью формы ◊ic{dynamic-let}, подобной ◊ic{let}
и~◊ic{flet}; значение динамической переменной получается с~помощью ◊ic{dynamic},
а изменяется — с~помощью ◊ic{dynamic-set!}.

◊indexE{Lisp3@◊protect◊Lisp3}
◊indexR{Лисп!Lisp3@◊protect◊Lisp3}
Пока что это три специальные формы, но далее будут рассмотрены другие варианты
реализации.
А~сейчас мы всего лишь добавим в~наш интерпретатор ◊ic{f.evaluate}
поддержку динамического окружения: ◊ic{denv}.
Это окружение будет содержать
только динамические переменные.
Новый интерпретатор, назовём его~◊Lisp3, будет
использовать функции с~префиксом~◊ic{df.}, чтобы не~путать их с~остальными.
Вот
его код.
(Форма ◊ic{flet} не~показана для краткости.)

◊indexC{df.evaluate}
◊indexC{df.evaluate-application}
◊indexC{df.make-function}
◊indexC{df.eprogn}
◊begin{code:lisp}
(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv) ))
        ((begin)  (df.eprogn (cdr e) env fenv denv))
        ((set!)   (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv) ))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv) ) )
        ((dynamic-let)
         (df.eprogn (cddr e)
                    env
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv) )
                                 (map cadr (cadr e)) ) ) ) )
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv )) ) ) )

(define (df.evaluate-application fn args env fenv denv)
  (cond ((symbol? fn) ((f.lookup fn fenv) args denv))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (df.eprogn (cddr fn)
                    (extend env (cadr fn) args)
                    fenv
                    denv ) )
        (else (wrong "Incorrect functional term" fn)) ) )

(define (df.make-function variables body env fenv)
  (lambda (values denv)
    (df.eprogn body (extend env variables values) fenv denv) ) )

(define (df.eprogn e* env fenv denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (begin (df.evaluate (car e*) env fenv denv)
                 (df.eprogn (cdr e*) env fenv denv) )
          (df.evaluate (car e*) env fenv denv) )
      empty-begin ) )
◊end{code:lisp}

Для поддержки нового окружения, ◊ic{denv}, потребовалось изменить прототипы
◊ic{df.evaluate} и ◊ic{df.eprogn}, чтобы не~терять это окружение при
вычислениях.
Далее, ◊ic{df.evaluate} определяет три новые специальные формы
для операций над ◊ic{denv}, динамическим окружением.
Есть и менее заметные
изменения: ◊ic{df.evaluate-application} передаёт в~функции ◊emph{текущее}
динамическое окружение.
Мы уже встречались с~таким поведением
◊seePage[basics/representing-functions/fixing/src:inject-current-env], когда
были вынуждены передавать текущее лексическое окружение в~вызываемую функцию.

◊indexR{динамическое окружение!варианты}
◊indexR{окружение!динамическое!варианты}
При применении функции используются одновременно несколько окружений.
Есть
окружение с~переменными и функциями, захваченными при определении функции.
Есть
также окружение с~динамическими переменными, существующими в~момент вызова.
Это
окружение не~может быть захвачено и сохранено в~замыкании, каждый раз значение
динамической переменной ищется заново в~текущем динамическом окружении.
Оно
может там отсутствовать, что, конечно~же, приводит к~ошибке.
Возможны и другие
варианты реализации: например, сделать единое глобальное окружение динамических
переменных, как в~{◊ISLisp}; или выдать каждому модулю собственное динамическое
окружение, как в~{◊EuLisp}; или даже иметь глобальное окружение лексических
переменных, как в~{◊CommonLisp}.
◊seePage[lisp1-2-omega/namespaces/ssect:dyn-vars-cl]

Одно из преимуществ отдельного окружения: становится чётко видно, какие
переменные динамические, а какие нет.
При всяком обращении к~динамическому
окружению необходимо использовать специальную форму с~префиксом ◊ic{dynamic}.
Явные обращения к~динамическим переменным невозможно не~заметить.
Это очень
важно, так как в~◊Lisp3 поведение функции определяется не~только значениями
локальных переменных, но и текущим состоянием динамического окружения.

◊indexR{привязки (bindings)!динамические}
◊indexR{обработка ошибок!динамические переменные}
Среди традиционных вариантов использования динамических окружений наиболее
полезным является обработка ошибок.
При возникновении ошибки или исключительной
ситуации создаётся некий объект, описывающий, что произошло, и к~этому объекту
применяется соответствующая функция, которая обработает исключительную ситуацию
(и,~возможно, попытается восстановить работоспособность программы).
Этот
обработчик мог~бы быть общей глобальной функцией, но это потребовало~бы кучи
ненужных присваиваний для использования правильного обработчика в~правильное
время.
«Герметичность» лексических окружений плохо сочетается со~сквозным
указанием различных функций-обработчиков.
Хотя мы всегда можем ограничить время
жизни локальных переменных, заключив вычисления в~◊ic{let} или ◊ic{dynamic-let},
но у~◊ic{dynamic-let} есть несколько серьёзных преимуществ:

◊begin{enumerate}
  ◊item создаваемые привязки не~могут быть захвачены;

  ◊item эти привязки доступны только во~время вычислений,
        вложенных в~форму;

  ◊item привязки автоматически уничтожаются после завершения
        вычислений.
◊end{enumerate}

◊noindent
Поэтому ◊ic{dynamic-let} идеально подходит для временной установки
функций-обработчиков ошибок.

Вот ещё один пример разумного использования динамических переменных.
Функции
вывода в~{◊CommonLisp} настраиваются динамическими переменными вроде
◊ic{*print-base*}, ◊ic{*print-circle*} {◊itd} В~них хранится информация
об~основании счисления для вывода чисел, о~том, могут~ли выводимые данные
содержать циклические списки, и~тому подобное.
Конечно, можно передавать всю
эту информацию через аргументы, но только представьте, что вместо ◊ic{(print
◊ii{выражение})} приходилось~бы писать ◊ic{(print ◊ii{выражение}
◊ii{escape-символы?} ◊ii{основание} ◊ii{циклы?} ◊ii{pretty-print?} ◊ii{регистр?}
◊ii{уровень-вложенности}◊ForLayout{display}{◊◊} ◊ii{векторы?}
◊ii{использовать-gensym?})}.
Каждый раз.
Динамические переменные позволяют один
раз установить значения по умолчанию для таких параметров и больше никогда их
не~указывать, если не~требуется особого поведения.

◊indexR{циклические структуры данных}
Scheme использует похожий механизм для указания портов ввода-вывода.
Можно
написать ◊ic{(display ◊ii{выражение})} или◊footnote{Это две различные функции
◊ic{display}, принимающие один и два аргумента соответственно.
В~Scheme нет
поддержки опциональных аргументов и значений по умолчанию на уровне~языка.
Лисп~же поддерживает эту идею, поэтому не~нуждается в~динамических переменных
для реализации подобного поведения.} ◊ic{(display ◊ii{выражение} ◊ii{порт})}.
Первая форма, с~одним аргументом, выводит ◊ii{выражение} в~текущий порт вывода.
Вторая~же использует явно указанный порт.
Функция ◊ic{with-output-to-file}
позволяет указать порт вывода, который будет текущим на время вычисления
выражения.
Узнать текущий порт можно с~помощью ◊ic{current-output-port}.
Вот так
определяется функция,◊footnote*{См.~также реализацию функции ◊ic{list-length} из
{◊CommonLisp}.} которая выводит циклические списки в~текущий порт:

◊indexC{display-cyclic-spine}
◊begin{code:lisp}
(define (display-cyclic-spine list)
  (define (scan l1 l2 flip)
    (cond ((atom? l1)  (unless (null? l1)
                          (display " .
") (display l1) )
                       (display ")") )
          ((eq? l1 l2) (display "...)"))
          (else        (display (car l1))
                       (when (pair? (cdr l1)) (display " "))
                       (scan (cdr l1)
                             (if (and flip (pair? l2))
                                 (cdr l2)
                                 l2 )
                             (not flip) ) ) ) )
  (display "(")
  (scan list (cons 42 list) #f) )

(display-cyclic-spine        ; напечатает ◊ic{(1 2 3 4 1 ...)}
  (let ((l (list 1 2 3 4)))
    (set-cdr! (cdddr l) l)
    l ) )
◊end{code:lisp}

Можно даже составить таблицу характеристик для портов вывода Scheme:

◊begin{envtable}
Ссылка      & автоматически, если не~упоминается явно                  ◊◊
Значение    & ◊ic{(current-output-port)}                               ◊◊
Изменение   & запрещено                                                ◊◊
Расширение  & ◊ic{(with-output-to-file ◊ii{имя-файла} ◊ii{замыкание})} ◊◊
Определение & неприменимо                                              ◊◊
◊end{envtable}

◊indexC*{standard-output}{*standard-output*}
◊indexR{соглашения именования!динамических переменных}
В~{◊CommonLisp} данный механизм явно использует динамические переменные.
По~умолчанию функции вывода вроде ◊ic{print} или ◊ic{write} используют порт,
хранящийся в~переменной ◊ic{*standard-output*}.◊footnote*{По соглашению, имена
динамических переменных окружаются звёздочками, чтобы выделить их.} Мы можем
проэмулировать◊footnote{Разумеется, это не~{◊CommonLisp}.
Это наш ◊Lisp3,
определённый чуть выше.} ◊ic{with-output-to-file} следующим образом:

◊indexC{with-output-to-file}
◊begin{code:lisp}
(define (with-output-to-file filename thunk)
  (dynamic-let ((*standard-output* (open-input-file filename)))
    (thunk) ) )
◊end{code:lisp}


◊subsection{Динамические~переменные в~{◊CommonLisp}}%
◊label{lisp1-2-omega/namespaces/ssect:dyn-vars-cl}

◊indexR{динамические переменные!синтаксис}
◊indexR{синтаксис!динамических переменных}
Хотя {◊CommonLisp} разделяет динамические и лексические переменные с~точки
зрения вычислений, но синтаксис их использования отличается слабо.
В~нём нет
формы ◊ic{dynamic-let}, но её можно легко сымитировать:

{◊def◊E{◊hbox to 0pt{◊kern0.15em$◊equals$}}
◊begin{code:lisp}
(dynamic-let ((x |$◊alpha$|)) |◊E|   (let ((x |$◊alpha$|))
  |$◊beta$| )                     (declare (special x))
                          |$◊beta$| )
◊end{code:lisp}}

Отличие состоит в~том, что для получения значения динамической переменной~◊ic{x}
внутри $◊beta$ нет надобности использовать форму ◊ic{dynamic}, достаточно писать
просто~◊ic{x}.
Причина такого поведения в~том, что выражение ◊ic{(declare
(special~x))} означает сразу две вещи: привязка, устанавливаемая ◊ic{let}
для~◊ic{x} должна быть динамической, а каждая ссылка на~◊ic{x} внутри
тела~◊ic{let} должно пониматься как ◊ic{(dynamic~x)}.

Это не~совсем удобно, так как внутри~$◊beta$ нельзя обращаться к~лексической
переменной~◊ic{x}, нам будет видна только её динамическая тёзка.
Можно было~бы
пойти другим путём, указывая конкретные места, где необходимо использовать
динамическую переменную~◊ic{x} с~помощью конструкции ◊ic{(locally (declare
(special~x)) x)}.
Это в~точности идентично нашей форме~◊ic{dynamic}.

Стратегия {◊CommonLisp} состоит в~указании типа привязки с~помощью конструкций
языка.
Мы можем реализовать этот механизм, сделав следующие изменения
в~интерпретаторе:

◊indexC{df.evaluate}
◊indexC{special-extend}
◊indexC{cl.lookup}
◊begin{code:lisp}
(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (cl.lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv) ))
        ((begin)  (df.eprogn (cdr e) env fenv denv))
        ((set!)   (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv) ))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv) ) )
        ((dynamic-let)
         (df.eprogn (cddr e)
                    [(special-extend env]
                                    [(map car (cadr e)) )]
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv) )
                                 (map cadr (cadr e)) ) ) ) )
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv )) ) ) )

(define (special-extend env variables)
  (append variables env) )

(define (cl.lookup var env denv)
  (let look ((env env))
    (if (pair? env)
        (if (pair? (car env))
            (if (eq? (caar env) var)
                (cdar env)
                (look (cdr env)) )
            (if (eq? (car env) var)
                ;; ищем в~текущем динамическом окружении
                (let lookup-in-denv ((denv denv))
                  (if (pair? denv)
                      (if (eq? (caar denv) var)
                          (cdar denv)
                          (lookup-in-denv (cdr denv)) )
                      ;; если не~находим, ищем в~глобальном лексическом
                      (lookup var env.global) ) )
                (look (cdr env)) ) )
        (wrong "No such binding" var) ) ) )
◊end{code:lisp}

Теперь разберём, как это работает.
Когда ◊ic{dynamic-let} создаёт динамическую
переменная, она не~только связывает её со~значением в~динамическом окружении, но
и помечает её как динамическую в~лексическом окружении, записывая туда её имя.
Для поддержки этих меток изменяется механизм поиска значения по ссылке
(◊ic{cl.lookup}): он должен проанализировать ссылку, чтобы определить тип
привязки (лексическая или динамическая), после чего отыскать значение
в~правильном окружении.
Также, если переменная не~найдена в~текущем динамическом
окружении, то следующим просматривается глобальное лексическое окружение,
которое в~{◊CommonLisp} одновременно является глобальным динамическим.

Приведём пример работы такого ◊Lisp3, имитирующего {◊CommonLisp}:

◊begin{code:lisp}
(dynamic-let ((x 2))
  (+ x                        ; динамический~◊ic{x}
     (let ((x (+              ; лексический
                 x x )))      ; динамические
       (+ x                   ; лексический
          (dynamic x) ) ) ) ) ; динамический
|◊is| 8
◊end{code:lisp}


◊subsection{Динамические~переменные без~специальных~форм}%
◊label{lisp1-2-omega/namespaces/ssect:dyn-vars-no-special}

Сейчас для работы с~динамическими переменными используются целых три специальные
формы.
Так как Scheme исповедует минимализм по отношению к~количеству
специальных форм, стоит подумать о~других вариантах.
Не~будем рассматривать их
все, а остановимся на следующем, так как он использует всего две функции.
Первая
функция динамически связывает два значения; вторая функция может по первому
значению найти второе.
На роль идентификаторов динамических переменных прекрасно
подходят символы.
Кроме них нам потребуется некий изменяемый тип данных вроде
точечных пар, если мы хотим изменять установленные связи.
Так наше решение будет
удовлетворять аскетичным традициям Scheme.

Во~время изучения данного подхода мы будем использовать интерпретатор с~двумя
окружениями: ◊ic{env} и ◊ic{denv}.
Это тот~же предыдущий интерпретатор, только
из него убрано несколько вещей: ненужные специальные формы, поддержка
функциональных окружений и ссылки на переменные как в~{◊CommonLisp}.
Остались
только мы и динамические окружения.
Такой интерпретатор несколько менее полезен,
так как динамическое окружение уже нельзя расширять непосредственно, но, тем
не~менее, это окружение всё ещё передаётся в~каждую функцию — и~этого
достаточно! Чтобы отличать эту вариацию от предыдущих, её функциям выдан
префикс~◊ic{dd}.

◊indexC{dd.evaluate}
◊indexC{dd.make-function}
◊indexC{dd.evlis}
◊indexC{dd.eprogn}
◊begin{code:lisp}
(define (dd.evaluate e env denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (dd.evaluate (cadr e) env denv)
                      (dd.evaluate (caddr e) env denv)
                      (dd.evaluate (cadddr e) env denv) ))
        ((begin)  (dd.eprogn (cdr e) env denv))
        ((set!)   (update! (cadr e) env
                           (dd.evaluate (caddr e) env denv) ))
        ((lambda) (dd.make-function (cadr e) (cddr e) env))
        (else (invoke (dd.evaluate (car e) env denv)
                      (dd.evlis (cdr e) env denv)
                      denv )) ) ) )

(define (dd.make-function variables body env)
  (lambda (values denv)
    (dd.eprogn body (extend env variables values) denv) ) )

(define (dd.evlis e* env denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (cons (dd.evaluate (car e*) env denv)
                (dd.evlis (cdr e*) env denv) )
          (list (dd.evaluate (car e*) env denv)) )
      '() ) )

(define (dd.eprogn e* env denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (begin (dd.evaluate (car e*) env denv)
                 (dd.eprogn (cdr e*) env denv) )
          (dd.evaluate (car e*) env denv) )
      empty-begin ) )
◊end{code:lisp}

Как мы и обещали, теперь определим две функции.
Первую назовём
◊ic{bind-with-dynamic-extent}; это длинное название, так что сократим его до
◊ic{bind/de}.
Первым её аргументом является ключ~◊ic{tag}; вторым —
значение~◊ic{value}, связываемое с~ключом; третьим — замыкание~◊ic{thunk},
функция без аргументов, которая будет вызвана в~расширенном динамическом
окружении.

◊indexC{bind/de}
◊begin{code:lisp}
(definitial bind/de
  (lambda (values denv)
    (if (= 3 (length values))
        (let ((tag   (car values))
              (value (cadr values))
              (thunk (caddr values)) )
          (invoke thunk '()
                  (extend denv (list tag) (list value)) ) )
        (wrong "Incorrect arity" 'bind/de) ) ) )
◊end{code:lisp}

Следующая функция будет использовать динамическое окружение.
Так как нам надо
что"~то делать в~случае, если динамической переменной с~запрошенным именем нет,
то функция ◊ic{assoc/de} первым аргументом принимает ключ, а вторым —
функцию.
Она вызовет полученную функцию и передаст ей ключ, если не~найдёт его
в~динамическом окружении.

◊indexC{assoc/de}
◊begin{code:lisp}
(definitial assoc/de
  (lambda (values current.denv)
    (if (= 2 (length values))
        (let ((tag     (car values))
              (default (cadr values)) )
          (let look ((denv current.denv))
            (if (pair? denv)
                (if (eqv? tag (caar denv))
                    (cdar denv)
                    (look (cdr denv)) )
                (invoke default (list tag) current.denv) ) ) )
        (wrong "Incorrect arity" 'assoc/de) ) ) )
◊end{code:lisp}

Можно реализовать несколько вариантов её поведения в~зависимости от
используемого механизма сравнения (◊ic{eqv?} или ◊ic{equal?}).
◊seeEx[lisp1-2-omega/ex:assoc-with-comparator]

◊ForLayout{display}{◊clearpage}

Перепишем предыдущий пример:

◊begin{code:lisp}
(bind/de 'x 2
  (lambda () (+ (assoc/de 'x error)
                (let ((x (+ (assoc/de 'x error)
                            (assoc/de 'x error) )))
                  (+ x (assoc/de 'x error)) ) )) )
|◊is| 8
◊end{code:lisp}

Таким образом, мы опровергли необходимость использования специальных форм для
реализации механизма динамических переменных.
Заодно мы получили возможность
связывать что угодно с~чем угодно.
Конечно, это преимущество — ничто по
сравнению с~тем, что есть гораздо более эффективные реализации динамических
переменных (даже без учёта многопоточности).
Хотя~бы то~же ближнее связывание,
которое лишь требует, чтобы ключ был символом.◊footnote*{Многие реализации Лиспа
не~считают ключевые слова вроде ◊ic{nil} или ◊ic{if} символами (а~значит, и
легальными именами переменных).} С~другой стороны, в~данном варианте не~потеряна
ссылочная прозрачность.
Но всё равно доступ к~динамическим переменным требует
недешёвых вызовов функций.
Наше решение ещё довольно далеко от органичного
сочетания динамических и лексических переменных в~{◊CommonLisp}.

Среди всех неудобств стоит отметить ещё то, что использование ◊ic{bind/de}
требует использования ◊ic{assoc/de} и написания функции-обработчика.
Хотя,
естественно, с~помощью макросов это можно спрятать.
Другое неудобство возникает
уже для компилятора: ведь ему надо будет генерировать код для создания и
использования динамических переменных.
К~счастью, они помечены вызовами
соответствующих функций, так что дальнейшее отдаётся на откуп компилятору:
генерировать код в~лоб (это легче) или вставить свою, более эффективную
реализацию.


◊subsection{В~заключение о~пространствах~имён}%
◊label{lisp1-2-omega/namespaces/ssect:conclusions}

После отступления к~динамическим переменным, вернёмся к~идее пространств имён
в~общем: специализированные окружения для специализированных объектов.
Мы уже
видели ◊Lisp3 в~деле, а также разобрали механизм динамических переменных
в~{◊CommonLisp}.

◊indexE{Lispn@◊protect◊Lisp{◊protect◊ii{n}}}
◊indexR{Лисп!Lispn@◊protect◊Lisp{◊protect◊ii{n}}}
Тем не~менее, наша последняя реализация — та, что с~двумя функциями вместо
трёх специальных форм, — поднимает каверзный вопрос.
Если это ◊Lisp{$n$}, то
чему равно~$n$? Базируется она на~Scheme, но всё~же явно имеет два окружения:
◊ic{env} и~◊ic{denv}.
В~то~же время, вычислитель у~неё лишь один, что является
отличительной чертой Scheme и класса~◊Lisp1.
Однако, нам пришлось довольно
сильно модифицировать интерпретатор (просто сравните ◊ic{evaluate} и
◊ic{dd.evaluate}), чтобы реализовать функции ◊ic{bind/de} и ◊ic{assoc/de}.
Мы
столкнулись с~примитивными функциями, которые нельзя выразить тем~же языком,
если только они уже не~определены; более того, само существование этих функций
глубоко влияет на процесс вычислений.
В~следующей главе будет такая~же ситуация
с~◊ic{call/cc}.

◊indexR{списки свойств}
◊indexR{символы!списки свойств}
Короче говоря, похоже, что у~нас получился ◊Lisp1, если смотреть на количество
вычислителей, и ◊Lisp2 — если смотреть на пространства имён.
Обобщением этих
парадоксов является мнение, что наличие списка свойств у~символов является
чертой ◊Lisp{$n$}, где $n$ может быть произвольным.
◊seeEx[lisp1-2-omega/ex:write-put/get-prop]
Так как наши пространства имён объективно существуют, а значения соответствующих
переменных вычисляются особым образом (пусть и с~помощью примитивных функций, а
не~специальных форм), то будем считать нашу реализацию представителем
класса~◊Lisp2.

◊bigskip

◊indexC{csetq}
◊indexR{константы}
Остаётся ещё один урок, который можно извлечь из рассмотрения лексических и
динамических переменных.
{◊CommonLisp} старается унифицировать доступ
к~переменным из различных пространств имён, предоставляя одинаковый синтаксис.
Поэтому необходимо знать правила, по которым он определяет, из какого
пространства имён взять переменную.
К~сожалению, они не~всегда однозначны;
например, {◊CommonLisp} не~различает глобальное динамическое и глобальное
лексическое окружения.
Далее, в~◊LISP~1.5 существовала концепция констант,
определяемых специальной формой~◊ic{csetq} (◊ic{setq} для констант).

◊begin{envtable}
Ссылка      & ◊ii{x}                         ◊◊
Значение    & ◊ii{x}                         ◊◊
Изменение   & ◊ic{(csetq ◊ii{x} ◊ii{форма})} ◊◊
Расширение  & запрещено                      ◊◊
Определение & ◊ic{(csetq ◊ii{x} ◊ii{форма})} ◊◊
◊end{envtable}

Введение констант тоже делает синтаксис неоднозначным.
Когда мы пишем ◊ic{foo}
— это может быть как константа, так и переменная.
Правило разрешения
противоречий в~◊LISP~1.5 было таково: если существует константа с~именем
◊ic{foo}, то вернуть её значение; иначе искать одноимённую переменную
в~лексическом пространстве имён.
Но: «константы» можно изменять (представьте
себе!) с~помощью той~же формы ◊ic{csetq}, что используется для их создания.
Таким образом, константы ◊LISP~1.5 соответствуют глобальным переменным Scheme,
только с~обратным приоритетом: в~Scheme сначала ищется локальная лексическая
переменная, а глобальная переменная является лишь значением по умолчанию на
случай, если локальная переменная не~будет найдена.

Проблема имеет довольно общий характер.
Если для доступа к~нескольким
пространствам имён используется одинаковый синтаксис, то необходимы чётко
прописанные правила разрешения неоднозначностей.


◊section{Рекурсия}◊label{lisp1-2-omega/sect:recursion}

◊indexR{рекурсия}
◊indexR{рекурсия|seealso{рекурсия}}
◊indexR{рекурсия|◊protect◊indexR{рекурсия}}
Рекурсия естественна для Лиспа, но мы пока так ничего и не~сказали о~том, как~же
она реализуется.
Далее мы проанализируем различные типы рекурсии и вызываемые
ими проблемы.


◊subsection{Простая рекурсия}◊label{lisp1-2-omega/recusion/ssect:simple}

◊indexR{рекурсия!простая}
Наверное, наиболее известной простой рекурсивной функцией является факториал,
определяемый следующим образом:

◊indexC{fact}
◊begin{code:lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )
◊end{code:lisp}

Язык, который был определён в~предыдущей главе, не~знает, что такое ◊ic{define},
так что давайте представим, что это макрос, который раскрывается в~следующий
код:

◊begin{code:lisp}
(set! fact (lambda (n)
             (if (= n 0) 1
                 (* n (fact (- n 1))) ) ))
◊end{code:lisp}

◊indexR{привязки (bindings)!неинициализированные}
Здесь мы видим присваивание, изменение значения переменной ◊ic{fact}.
Это
изменение бессмысленно, если переменная ◊ic{fact} не~существует.
Глобальное
окружение можно считать местом, где уже существуют все возможные переменные.
В~этой ◊emph{виртуальной реальности} интерпретатор (а~точнее, его часть,
ответственная за чтение программ) должен создать привязку для переменной, когда
впервые видит её имя, после чего невозмутимо продолжить работу, будто~бы эта
переменная уже сто лет как здесь.
Каждая переменная уже существует до своего
первого использования, а~значит, её определение — это лишь изменение значения
существующей переменной.
Но при таком подходе возникает проблема с~получением
значения переменной, которой ещё ничего не~было присвоено.
Интерпретатор должен
отловить эту ошибку, когда переменная вроде как есть, но значения у~неё ещё нет.
Как видите, идея привязок не~так уж и проста, мы рассмотрим её подробнее
в~четвёртой главе.
◊seePage[chapter:assignment]

◊indexC{define}
Можно избавиться от проблем с~привязками, которые существуют, но еще
не~инициализированы, если принять другую позицию.
Пусть изменять можно только
существующие переменные; иными словами, переменной нет, если она не~была
определена явно.
Для этого используется специальная форма ◊ic{define},
создающая переменные.
Без неё у~нас не~получится ни~обратиться к~переменной,
ни~установить её значение.
Однако, посмотрим теперь на это с~другой стороны:

◊begin{code:lisp}[label=lisp1-2-omega/recusion/simple/code:redefine]
(define (display-pi)
  (display pi) )
(define pi 2.7182818285)    ; ой, не~та константа
(define (print-pi)
  (display pi) )
(define pi 3.1415926536)
◊end{code:lisp}

Допустимо~ли такое определение ◊ic{display-pi}? Её тело ссылается на ◊ic{pi},
которая ещё не~определена.
Четвёртый~◊ic{define} исправляет ошибку во~втором; но
даже если ◊ic{define} создаёт новую привязку, можно~ли создать ещё одну
с~таким~же именем?

Эти вопросы не~имеют однозначного ответа.
Есть как минимум два варианта: считать
глобальные определения лексическими (как это делает~ML) или считать их
динамическими (как это принято в~Лиспе).

◊indexR{окружение!глобальное!гиперстатическое}
◊indexR{глобальное окружение!гиперстатическое}
◊indexR{гиперстатическое окружение}
◊phantomlabel{lisp1-2-omega/recusion/simple/par:hyperstatic}
В~глобальном окружении, которое ◊emph{полностью лексично} — будем называть
его ◊term{гиперстатическим}, — мы не~можем использовать переменную (ссылаться
на неё, получать или изменять её значение), если она не~существует.
В~нём
определение функции ◊ic{display-pi} будет ошибочным, так как оно ссылается на
переменную~◊ic{pi}, которая не~существует на момент определения.
Любой вызов
функции ◊ic{display-pi} привёл~бы к~ошибке «Неизвестная переменная:~◊ic{pi}»
(если~бы это не~случилось ещё при её определении).
Но с~функцией ◊ic{print-pi}
всё в~порядке, она будет выводить значение, существовавшее на момент её
определения (в~данном случае это ◊ic{2.7182818285}), и ничто не~сможет изменить
выводимое значение.
Здесь переопределение~◊ic{pi} вполне~допустимо и создаст
новую переменную~◊ic{pi}, которая будет использоваться в~последующих выражениях
в~пределах своей области видимости.
Предыдущий пример можно представить примерно
таким образом:

◊begin{code:lisp}
(let ((display-pi (lambda () (display pi))))
  (let ((pi 2.7182818285))
    (let ((print-pi (lambda () (display pi))))
      (let ((pi 3.1415926536))
        ...
) ) ) )
◊end{code:lisp}

В~Лиспе, как было сказано, принят динамический подход.
Предполагается, что может
существовать максимум одна глобальная переменная с~уникальным именем, и эта
переменная видна везде, в~том числе в~своём собственном определении.
Лисп
поддерживает опережающие ссылки без какого-либо специального синтаксиса.
(Под
таким синтаксисом понимаются явные объявления вроде ключевого слова ◊ic{forward}
Паскаля или прототипов ISO~C~◊cite{iso90}.)

Выбор отнюдь не~так прост.
Возвращаясь к~факториалу; в~окружении, где будет
вычисляться ◊ic{lambda}-форма, необходимо ответить на вопрос: «Чему здесь равно
значение ◊ic{fact}?» Если вычисление происходит в~глобальном окружении, где нет
привязки для ◊ic{fact}, то эта функция в~принципе не~может быть рекурсивной.
Причина: функция ссылается на некую переменную ◊ic{fact}, значение которой
следует искать в~окружении, захваченном замыканием (в~том, которое состоит из
свободных переменных и параметров функции).
Так как в~момент создания замыкания
переменная ◊ic{fact} не~существовала, то и в~окружении её нет.
Следовательно,
для рекурсии её необходимо каким"~то образом туда добавить.
Проще всего это
сделать, выбрав динамический подход к~глобальному окружению, который снимает
вопрос существования переменных в~принципе.
При гиперстатическом~же подходе надо
убедиться в~том, что ◊ic{define} создаёт привязку для ◊ic{fact} перед тем, как
вычислять замыкание, которое станет значением ◊ic{fact}.
Резюмируя: простая
рекурсия требует глобального окружения.


◊subsection{Взаимная рекурсия}◊label{lisp1-2-omega/recusion/ssect:mutual}

◊indexR{рекурсия!взаимная}
Теперь предположим, что мы хотим определить две взаимно рекурсивные функции.
Возьмём для примера ◊ic{odd?} и ◊ic{even?}, реализующие (весьма медленную)
проверку натуральных чисел на чётность.
Они определяются следующим образом:

◊indexC{even?}◊indexC{odd?}
◊indexE{even?@◊protect◊ic{even?}|seealso{◊protect◊ic{odd?}}}
◊indexE{odd?@◊protect◊ic{odd?}|seealso{◊protect◊ic{even?}}}
◊begin{code:lisp}
(define (even? n)
  (if (= n 0) #t (odd? (- n 1))) )
(define (odd? n)
  (if (= n 0) #f (even? (- n 1))) )
◊end{code:lisp}

Можно менять их местами, но в~любом случае первое определение не~будет знать
о~втором; в~данном случае ◊ic{even?} не~знает в~момент определения про
◊ic{odd?}.
И~опять, кажется, решением будет глобальное окружение с~заранее
созданными переменными: оба замыкания захватывают глобальное окружение,
в~котором есть все возможные переменные, среди них, в~частности, и необходимые
◊ic{odd?} и~◊ic{even?}.
Конечно, мы пока оставим в~стороне вопрос, как именно
реализуется захват только необходимых привязок.

Довольно непросто перенести это поведение в~мир с~гиперстатическим глобальным
окружением, так как здесь уж точно первое определение никогда не~сможет узнать
о~втором.
Одно из решений состоит в~том, чтобы определять эти две функции
одновременно, тогда не~будет никаких первых и вторых, и обе функции смогут
ссылаться друг на друга без проблем.
(Мы вернёмся к~этому вопросу чуть позже,
после изучения локальной рекурсии.) Например, когда"~то в~◊LISP~1.5 имелась
форма ◊ic{define} с~подобной возможностью:

◊indexCS{define}{параллельные объявления}
◊begin{code:lisp}
(define ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))) ))
◊end{code:lisp}

Таким образом, с~помощью глобального окружения и некоторых ухищрений можно
выразить и взаимную рекурсию.

Но что случится, если нам понадобятся локальные рекурсивные функции?


◊subsection{◊texorpdfstring{Локальная~рекурсия в~◊Lisp2}%
{Локальная рекурсия в Lisp₂}}%
◊label{lisp1-2-omega/recusion/ssect:local-lisp2}

◊indexR{рекурсия!локальная}
Некоторые проблемы, с~которыми мы столкнулись при попытках определить~◊ic{fact}
в~глобальном окружении, возвращаются при попытках определить~◊ic{fact} локально.
Нам надо сделать что"~то, чтобы вызов ◊ic{fact} из тела ◊ic{fact} был
рекурсивным.
Чтобы ◊ic{fact} из функционального окружения была связана
с~функцией вычисления факториала даже внутри самой функции вычисления
факториала.
И~вот здесь как раз проявляется отличие между локальным и
глобальным окружениями: вспомните, что происходит, если искомая локальная
переменная не~существует.
Рассмотрим следующую программу на~◊Lisp2:

◊indexC{fact}
◊begin{code:lisp}
(flet ((fact (n) (if (= n 0) 1
                     (* n (fact (- n 1))) )))
  (fact 6) )
◊end{code:lisp}

Форма ◊ic{flet} связывает функцию вычисления факториала с~именем~◊ic{fact}
в~своём внутреннем функциональном окружении.
Замыкание захватывает
функциональное и параметрическое окружения, локальные для формы~◊ic{flet}.
Таким
образом, ◊ic{fact} внутри ◊ic{fact} ссылается не~на функцию ◊ic{fact}, локальную
для тела~◊ic{flet}, а на какую"~то другую функцию ◊ic{fact} из окружения всей
формы~◊ic{flet}.
Эта функция не~обязана вычислять факториал (а~то и вовсе
не~существует), так что рекурсию мы не~получаем.

◊indexC{label}
◊indexR{специальные формы!label@◊protect◊ic{label}}
Эта проблема была очевидна ещё во~времена ◊LISP~1.5.
Для её решения была введена
специальная форма~◊ic{label}, позволявшая определять локальные рекурсивные
функции.
Пример с~факториалом тогда записывается так:

◊begin{code:lisp}
(label fact (lambda (n) (if (= n 0) 1
                            (* n (fact (- n 1))) )))
◊end{code:lisp}

Эта форма возвращает анонимную функцию, вычисляющую факториал.
Более того, это
именно та функция, которая связана с~◊ic{fact} в~своём~же теле.

◊indexC{labels}
◊indexR{специальные формы!labels@◊protect◊ic{labels}}
К~сожалению, нельзя сказать, что ◊LISP~1.5 был~◊Lisp2, а ◊ic{label}, какой~бы
удобной она не~была, не~может легко справиться со~взаимной рекурсией.
Поэтому
гораздо позже, судя по~◊cite{hs75}, был изобретён её $n$"~арный аналог:
◊ic{labels}.
Эта форма имеет тот~же синтаксис, что и~◊ic{flet}, но гарантирует,
что замыкания будут создаваться в~окружении, где можно ссылаться на локальные
функции.
С~её помощью можно определить и~◊ic{fact}, и~взаимно рекурсивные
◊ic{odd?} и~◊ic{even?}:

◊begin{code:lisp}
(labels ((fact (n) (if (= n 0) 1
                       (* n (fact (- n 1))) )))
  (fact 6) ) |◊is| 720

(funcall (labels ((even? (n) (if (= n 0) #t (odd? (- n 1))))
                  (odd? (n) (if (= n 0) #f (even? (- n 1)))) )
           (function even?) )
         4 ) |◊is| #t
◊end{code:lisp}

Так что в~◊Lisp2 мы имеем две формы для расширения локального функционального
окружения: ◊ic{flet} и~◊ic{labels}.


◊subsection{◊texorpdfstring{Локальная~рекурсия в~◊Lisp1}%
{Локальная рекурсия в Lisp₁}}%
◊label{lisp1-2-omega/recusion/ssect:local-lisp1}

◊indexR{рекурсия!локальная}
Проблема определения локальных рекурсивных функций существует и в~◊Lisp1;
решается она похожим способом.
Форма~◊ic{letrec} (рекурсивная~◊ic{let}) очень
похожа по~смыслу на~◊ic{labels}.

В~Scheme ◊ic{let} имеет следующий синтаксис:

◊begin{code:lisp}
(let ((|◊ii{переменная◊sub{1}}| |◊ii{выражение◊sub{1}}|)
      (|◊ii{переменная◊sub{2}}| |◊ii{выражение◊sub{2}}|)
       ...
      (|◊ii{переменная◊sub{n}}| |◊ii{выражение◊sub{n}}|) )
  |◊ii{выражения}|...
)
◊end{code:lisp}

◊indexC{let}
◊noindent
И~она эквивалентна такому выражению:

◊begin{code:lisp}
((lambda (|◊ii{переменная◊sub{1}}| |◊ii{переменная◊sub{2}}| ...
|◊ii{переменная◊sub{n}}|) |◊ii{выражения}|...)
 |◊ii{выражение◊sub{1}}| |◊ii{выражение◊sub{2}}| ...
|◊ii{выражение◊sub{n}}| )
◊end{code:lisp}

Поясним, что здесь происходит.
Сперва вычисляются все аргументы аппликации:
◊ii{выражение◊sub{1}}, ◊ii{выражение◊sub{2}}, ◊dots, ◊ii{выражение◊sub{n}};
затем переменные ◊ii{перемен◊-ная◊sub{1}}, ◊ii{перемен◊-ная◊sub{2}}, ◊dots,
◊ii{перемен◊-ная◊sub{n}} связываются с~только что полученными значениями;
наконец, ◊ii{выражения}, составляющие тело~◊ic{let}, вычисляются в~расширенном
окружении внутри неявной формы~◊ic{begin}, а её значение становится значением
всей формы~◊ic{let}.

Как видим, в~принципе нет необходимости делать ◊ic{let} специальной формой, так
как её полностью заменяет ◊ic{lambda}; следовательно, ◊ic{let} может быть всего
лишь макросом.
(Именно так и поступили в~Scheme: ◊ic{let} — это встроенный
макрос.) Тем~не~менее, ◊ic{let} хороша с~точки зрения стиля кодирования, потому
что позволяет не~разделять имя переменной и её начальное значение большим куском
кода.
Теперь самое время заметить, что начальные значения локальных переменных
формы ◊ic{let} вычисляются в~текущем окружении; в~расширенном вычисляется только
её тело.

◊indexC{letrec}
По тем~же причинам, с~которыми мы столкнулись в~◊Lisp2, это значительно
усложняет написание взаимно рекурсивных функций.
Поэтому вводится форма
◊ic{letrec}, аналог~◊ic{labels}.

Синтаксис~◊ic{letrec} такой~же, как и у~◊ic{let}.
Например:

◊begin{code:lisp}
(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))) )
  (even? 4) )
◊end{code:lisp}

◊indexCS{letrec}{как макрос}
Отличается ◊ic{letrec} от ◊ic{let} тем, что выражения"=инициализаторы
вычисляются в~том~же окружении, что и тело~◊ic{letrec}.
Операции, которые
выполняет~◊ic{letrec}, те~же, что и у~◊ic{let}, но их порядок несколько иной.
Сначала локальное окружение расширяется переменными ◊ic{letrec}.
Затем в~этом
расширенном окружении вычисляются начальные значения переменных.
Наконец,
в~том~же расширенном окружении вычисляется тело~◊ic{letrec}.
По~этому описанию
довольно легко понять, как реализовать такое поведение.
Действительно,
достаточно написать следующее:

◊indexC{even"?}◊indexC{odd"?}◊indexC*{void}{'void}
◊begin{code:lisp}
(let ((even? 'void) (odd? 'void))
  (set! even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
  (set! odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
  (even? 4) )
◊end{code:lisp}

Сначала создаются привязки для ◊ic{even?} и~◊ic{odd?}.
(Их начальные значения
не~важны, просто ◊ic{let} и ◊ic{lambda} требуют какое"~то значение.) Затем эти
переменные инициализируются значениями, вычисленными в~окружении, где известны
переменные ◊ic{even?} и~◊ic{odd?}.
Мы говорим «известны», потому что хотя для
этих переменных и созданы привязки, их значения не~имеют смысла, так как они
ещё не~были правильно инициализированы.
Про ◊ic{even?} и ◊ic{odd?} известно
достаточно, чтобы ссылаться на них, но пока ещё недостаточно, чтобы они
участвовали в~вычислениях.

◊indexR{порядок вычислений!неопределённый}
Однако, такое преобразование не~совсем корректно из"~за порядка вычислений:
действительно, ◊ic{let} раскрывается в~применение функции, следовательно,
◊ic{letrec}, по~идее, должна вести себя так~же, а это значит, что начальные
значения переменных должны вычисляться как аргументы функции — то~есть
в~неопределённом порядке.
К~сожалению, подобный вариант всегда вычисляет их
слева направо.
◊seeEx[lisp1-2-omega/ex:orderless-letrec]


◊subsubsection{◊texorpdfstring{Уравнения и~◊protect◊ic{letrec}}%
{Уравнения и letrec}}

◊indexCS{letrec}{и~уравнения}
С~формой~◊ic{letrec} есть ещё одна серьёзная проблема: её синтаксис не~является
строгим.
При текущей трактовке ◊ic{letrec} допускает в~качестве инициализаторов
всё что угодно, не~только функции; тогда как ◊ic{labels} в~{◊CommonLisp}
разрешает определять исключительно функции.
То~есть в~Scheme теоретически можно
будет написать следующее:

◊begin{code:lisp}
(letrec ((x (/ (+ x 1) 2))) x)
◊end{code:lisp}

Заметьте, что переменная~◊ic{x} фактически определяется через саму себя.
Это,
похоже, обыкновенное уравнение
%
◊[  x = ◊frac{x + 1}{2}  ◊]
%
Логично будет сделать значением~◊ic{x} корень этого уравнения.
То~есть такое
выражение должно вернуть~◊ic{1}.

Но что делать, если у~уравнения нет корней или если их несколько?

◊begin{code:lisp}
(letrec ((x (+ x 1))) x)            ; $x = x + 1$
(letrec ((x (+ (power x 37) 1))) x) ; $x = x^{37} + 1$
◊end{code:lisp}

Однако, существуют множества, вроде известного вам множества S"=выражений, где
достаточно легко убедиться в~том, что уравнение имеет единственное решение
◊cite{ms80}.
Например, следующим образом можно без побочных эффектов определить
бесконечный список — как корень данного «списочного» уравнения:

◊begin{code:lisp}
(letrec ((foo (cons 'bar foo))) foo)
◊end{code:lisp}

◊indexR{ленивые вычисления}
Значением этого выражения может быть или лениво вычисляемый бесконечный
список ◊ic{(bar bar bar ...)}, как это сделано в~◊cite{fw76,pj87}, так и
закольцованная структура данных (менее дорогая с~вычислительной точки зрения):

◊begin{code:lisp}
(let ((foo (cons 'bar 'wait)))
  (set-cdr! foo foo)
  foo )
◊end{code:lisp}

Эффективно это одно и то~же, но на самом деле нет.
В~общем, из"~за всех этих
неоднозначностей стоит ввести правило, запрещающее использовать переменную,
определяемую ◊ic{letrec}, для определения значения этой~же переменной.
В~двух
предыдущих примерах необходимо было знать значение~◊ic{x} для того чтобы
инициализировать~◊ic{x}.
Теперь они, очевидно, являются ошибочными.
Однако мы
помним, что порядок инициализации в~Scheme должен быть неопределённым, а значит,
некоторые конструкции, допускаемые данным правилом, могут быть ошибочными
в~одних реализациях, но работать в~других.
Рассмотрим следующий пример:

◊begin{code:lisp}
(letrec ((x (+ y 1))
         (y 2) )
  x )
◊end{code:lisp}

Если ◊ic{y} инициализируется до~◊ic{x}, то всё в~порядке.
В~противном случае
возникает ошибка, потому что мы хотим увеличить значение переменной~◊ic{y},
которая уже существует, но ещё не~имеет значения.
Некоторые компиляторы Scheme
и ML анализируют выражения"=инициализаторы и проводят топологическую сортировку
для определения подходящего порядка инициализации.
Естественно, такое решение
тоже не~всегда срабатывает; в~частности, при взаимной зависимости◊footnote{Ведь
◊ic{(42~42)} вполне подходит как корень данного уравнения, но почему
именно~◊ic{42}?} вроде такой:

◊begin{code:lisp}
(letrec ((x y) (y x)) (list x y))
◊end{code:lisp}

Рассмотренные примеры напоминают о~нашей дискуссии вокруг глобального окружения
и семантики ◊ic{define}.
Там возникла похожая проблема: что делать
с~неинициализированными привязками и как узнать о~том, что они вообще
существуют.


◊subsection{Объявление неинициализированных~привязок}%
◊label{lisp1-2-omega/recusion/ssect:uninitialized}

◊indexR{привязки (bindings)!неинициализированные}
Официально семантика Scheme считает ◊ic{letrec} производной формой; то есть
удобным, но отнюдь не~обязательным сокращением.
Соответственно, любую
◊ic{letrec}-форму можно переписать с~помощью примитивных форм Scheme.
Чуть
раньше мы попробовали это сделать, временно связывая переменные ◊ic{letrec}
со~значением ◊ic{void}.
К~сожалению, это тоже инициализация, так что обращения
к~неинициализированным переменным подобным образом отловить нельзя.
Наша
ситуация усугубляется тем, что ни~одна из четырёх специальных форм Scheme
не~позволяет создавать «родные» неинициализированные привязки.

◊indexC*{UFO}{◊#<UFO>}
В~первом приближении можно было~бы решить проблему, используя некий объект
◊ic{◊#<UFO>} ◊seePage[basics/s:env/ufo] вместо ◊ic{void}.
С~ним ничего нельзя
сделать: ни~прибавить к~нему число, ни~взять его~◊ic{car}; однако, это всё~же
полноценный объект, так что его можно передать как аргумент в~◊ic{cons}, а
значит, следующая программа не~будет ошибочной и вернёт ◊ic{◊#<UFO>}:

◊begin{code:lisp}
(letrec ((foo (cons 'foo foo))) (cdr foo))
◊end{code:lisp}

Причина такого поведения в~том, что неинициализированность — это свойство
самой привязки, а не~её значения.
Следовательно, мы не~сможем решить проблему,
используя объекты первого класса.

◊ForLayout{display}{◊medskip}

◊indexC*{uninitialized}{◊#<uninitialized>}
И~всё~же, многие реализации дают неинициализированным переменным специальное
значение.
Давайте назовём его ◊ic{◊#<uninitialized>} и предположим, что это
полноценный объект.
Любая переменная с~таким значением считается
неинициализированной.
Следовательно, используя вместо ◊ic{void} значение
◊ic{◊#<uninitialized>}, мы получаем желаемую возможность обнаружить ошибку.
Однако, эта возможность чересчур явная: ничто не~запрещает передавать
◊ic{◊#<uninitialized>} в~функцию как аргумент, а значит, больше нельзя
предполагать, что все аргументы функции имеют значения.
Мы будем вынуждены
каждый раз проверять, действительно~ли это так:

◊begin{code:lisp}
(define (fact n)
  (if (eq? n '#<uninitialized>)
      (wrong "Uninitialized n")
      (if (= n 0) 1
          (* n (fact (- n 1))) ) ) )
◊end{code:lisp}

Делать так со~всеми переменными — это слишком большая плата за ◊ic{letrec}.
Так что ◊ic{◊#<uninitialized>} нельзя делать полноценным объектом, это должно
быть особое внутреннее значение интерпретатора, которое нельзя использовать
в~программах.
Для того, чтобы им можно было пользоваться безопасно, необходим
специальный синтаксис.

◊ForLayout{display}{◊medskip}

Третий вариант решения состоит во~введении специальной формы, создающей
неинициализированные привязки.
Например, перенесём синтаксис ◊ic{let} из
{◊CommonLisp}, выполняющей данное действие, в~Scheme:

◊begin{code:lisp}
(let (|◊ii{переменная}| ...)
  ...
)
◊end{code:lisp}

Если имя переменной указано само по себе, без начального значения, то привязка
к~этому имени не~будет инициализирована.
Если нам понадобится её значение, то мы
будем вынуждены проверять, была~ли инициализирована данная переменная или нет.
Теперь можно будет написать нормальную реализацию ◊ic{letrec}.
В~следующем коде
переменные ◊ii{temp◊sub{i}} являются «гигиеничными»: им выдаются специальные
имена, гарантированно не~конфликтующие с~именами переменных ◊ic{letrec} или
свободными переменными её тела.

◊ForLayout{display}{◊clearpage}

{◊def◊N#1{◊ii{имя◊sub{#1}}}
◊def◊T#1{◊ii{temp◊sub{#1}}}
◊def◊E#1{◊ii{выражение◊sub{#1}}}
◊def◊Q{◊hbox to 0pt{◊kern0.3em$◊equals$}}
◊begin{code:lisp}
(letrec ((|◊N 1| |◊E 1|)       (let (|◊N 1| ...
|◊N n|)
         ...
                       (let ((|◊T 1| |◊E 1|)
         (|◊N n| |◊E n|) )  |◊Q|           ...
  |◊ii{тело}| )                                  (|◊T n| |◊E n|) )
                                      (set! |◊N 1| |◊T 1|)
                                      ...
                                      (set! |◊N n| |◊T n|)
                                      |◊ii{тело}| ) )
◊end{code:lisp}}

◊indexCS{let}{специальная форма}
Итого, проблема решена с~приемлемой эффективностью: лишь неинициализированные
переменные вызывают накладные расходы, потому что за особенности надо платить.
Но теперь форма~◊ic{let} не~является просто синтаксическим сахаром, теперь это
полноценная специальная форма, которую должен обрабатывать лично интерпретатор.
Добавляем соответствующий код в~◊ic{evaluate}:

◊begin{code:lisp}
...
((let)
 (eprogn (cddr e)
         (extend env
                 (map (lambda (binding)
                        (if (symbol? binding) binding
                            (car binding) ) )
                      (cadr e) )
                 (map (lambda (binding)
                        (if (symbol? binding) the-uninitialized-marker
                            (evaluate (cadr binding) env) ) )
                      (cadr e) ) ) ) ) ...
◊end{code:lisp}

Переменная ◊ic{the-uninitialized-marker} принадлежит языку определения.
Зададим
её, например, так:

◊indexC{the-uninitialized-marker}
◊begin{code:lisp}
(define the-uninitialized-marker (cons 'not 'initialized))
◊end{code:lisp}

Конечно, теперь необходимо встроить поддержку этого внутреннего значения
в~функцию ◊ic{lookup}.
Функция ◊ic{update!} в~изменениях не~нуждается по
очевидным причинам.
Обращения к~◊ic{wrong} отвечают за два различных типа
ошибок: несуществующую привязку и неинициализированную привязку.

◊indexC{lookup}
◊begin{code:lisp}
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (let ((value (cdar env)))
            (if (eq? value the-uninitialized-marker)
                (wrong "Uninitialized binding" id)
                value ) )
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )
◊end{code:lisp}

После блужданий по пустыне~семантики и синтаксиса, у~нас наконец"~то получилась
форма ◊ic{letrec}, позволяющая определять локальные взаимно рекурсивные функции.


◊subsection{Рекурсия без~присваивания}%
◊label{lisp1-2-omega/recusion/ssect:no-assignment}

◊indexR{язык!чисто функциональный}
◊indexR{рекурсия!без присваивания}
Форма ◊ic{letrec}, которую мы рассматривали, использует присваивания для
обеспечения правильного вычисления начальных значений.
Языки, называемые
◊emph{чисто функциональными}, не~имеют в~своём распоряжении операторов
присваивания; в~них принципиально нет побочных эффектов, а чем, как
не~побочным эффектом вычислений, является изменение значения переменной?

В~качестве парадигмы программирования запрет на присваивание имеет свои
преимущества: он гарантирует сохранение ссылочной прозрачности и этим
развязывает руки множеству оптимизаций, позволяя перемещать и распараллеливать
части программ, использовать ленивые вычисления {◊itd} Однако, если нет
возможности использовать присваивания, то некоторые алгоритмы становятся
не~такими простыми, а также несколько усложняется перенос программ на реальные
компьютеры, так как побочные эффекты являются неотъемлемой частью их работы.

◊indexC{letrec}
Первое, что приходит в~голову, это сделать ◊ic{letrec} ещё одной специальной
формой, как это и сделано в~ML и подобных ему языках.
Модифицируем ◊ic{evaluate}
для обработки этого случая:

◊begin{code:lisp}
...
((letrec)
 (let ((new-env (extend env
                        (map car (cadr e))
                        (map (lambda (binding) the-uninitialized-marker)
                             (cadr e) ) )))
      (map (lambda (binding)         ; ◊ic{map} во~имя беспорядка!
             (update! (car binding)
                      new-env
                      (evaluate (cadr binding) new-env) ) )
           (cadr e) )
      (eprogn (cddr e) new-env) ) ) ...
◊end{code:lisp}

В~этом случае побочные эффекты всё равно присутствуют, но на уровне
интерпретатора, внутри ◊ic{update!}; с~точки зрения определяемого языка побочных
эффектов нет.
Стоит заметить, что мы намеренно не~указываем порядок вычислений,
используя ◊ic{map}, которая, в~отличие от~◊ic{for-each}, вольна обрабатывать
список в~любом удобном порядке.◊footnote*{Правда, расплачиваясь за это
необходимостью собирать бесполезный список, который тут~же удаляется после
создания.}


◊subsubsection{◊texorpdfstring%
{◊protect◊ic{letrec} и~полностью~лексическое глобальное~окружение}%
{letrec и полностью лексическое глобальное окружение}}

В~гиперстатическом глобальном окружении переменную можно использовать только
после того, как она была определена.
С~такими ограничениями мы не~можем легко
определять ни~взаимно, ни даже просто рекурсивные функции.
Форма ◊ic{letrec}
решает эту проблему, а заодно служит индикатором рекурсивных определений.

◊begin{code:lisp}
(letrec ((fact (lambda (n)
                 (if (= n 0) 1 (* n (fact (- n 1)))) )))
  (letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
           (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
    ...
) )
◊end{code:lisp}

◊noindent
В~данном случае ◊ic{letrec} создаёт опережающие ссылки на ◊ic{fact}, ◊ic{odd?}
и~◊ic{even?}, так что определения будут работать и в~гиперстатическом окружении.


◊subsubsection{Парадоксальный комбинатор}

◊indexR{комбинаторы!неподвижной точки}
◊indexR{комбинаторы!Y@◊protect◊comb{Y}}
◊indexE{Y@◊protect◊comb{Y}, комбинатор}
◊indexR{теорема о~неподвижной точке}
◊indexR{неподвижная точка}
◊indexR{лямбда-исчисление@$◊lambda$-исчисление!комбинаторы}
Если вы имели дело с~$◊lambda$"=исчислением, то вы наверняка помните, что
такое ◊emph{комбинаторы неподвижной точки} и как записывается самый известный
из них — ◊emph{парадоксальный} или Y-комбинатор.
Функция~$f$ имеет
неподвижную точку, если в~её области определения существует элемент~$x$ такой,
что $f(x) = x$.
Комбинатор~◊comb{Y} принимает любую функцию
$◊lambda$"=исчисления и возвращает её неподвижную точку.
Эта идея выражена
в~одной из наиболее прекрасных и содержательных теорем $◊lambda$"=исчисления:

◊begin{theorem}{Теорема о~неподвижной точке}
$◊exists ◊comb{Y}◊colon ◊forall F◊colon ◊comb{Y} F = F(◊comb{Y} F)$
◊end{theorem}

В~терминах Лиспа, ◊comb{Y} — это значение выражения

◊begin{code:lisp}
(let ((W (lambda (w)
           (lambda (f)
             (f ((w w) f)) ) )))
  (W W) )
◊end{code:lisp}

Доказать это весьма просто.
Если предположить, что ◊comb{Y} равен $(W W)$,
то какой должна быть $W$◊!, чтобы $(W W)F$ равнялось $F ((W W) F)$?
Очевидно, что функция $W$◊! должна быть ничем иным, как $◊lambda W.
◊lambda F.
F ((W W) F)$.
Приведённое выражение лишь записывает эту идею на~Лиспе.

◊indexR{комбинаторы!Z@◊protect◊comb{Z}}
◊indexE{Z@◊protect◊comb{Z}, комбинатор}
◊indexR{эта-конверсия@$◊eta$-конверсия}
Правда, здесь возникает небольшое затруднений из"~за принятой в~Scheme передачи
аргументов по~значению.
Терм ◊ic{((w~w)~f)} не~следует вычислять слишком рано,
поэтому мы вынуждены добавить излишнюю (в~$◊lambda$"~исчислении)
$◊eta$"=конверсию, чтобы избежать проблем.
В~итоге мы приходим к~так называемому
Z-комбинатору, где ◊ic{(lambda (x) (...
x))} означает $◊eta$"=конверсию:

◊ForLayout{display}{◊clearpage}

◊indexC{fix}
◊begin{code:lisp}
(define fix
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda (x) (((w w) f) x))) ) )))
  (d d) ) )
◊end{code:lisp}

Самое сложное в~этом определении — понять, как оно работает.
Сейчас мы этим
и займёмся.
Определим функцию ◊ic{meta-fact}:

◊indexC{meta-fact}
◊begin{code:lisp}[label=lisp1-2-omega/recursion/y-combinator/code:meta-fact]
(define (meta-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n (f (- n 1))) ) ) )
◊end{code:lisp}

Эта функция подозрительно похожа на факториал.
Проверив, мы убеждаемся, что
◊ic{(meta-fact fact)} вычисляет факториал с~таким~же успехом, что и ◊ic{fact},
разве что несколько медленнее.
Теперь предположим, что мы знаем неподвижную
точку~$f$ функции ◊ic{meta-fact}: $f = ◊text{◊ic{(meta-fact $f$)}}$.
Эта
неподвижная точка по определению является решением следующего функционального
уравнения относительно~$f$:

◊begin{code:lisp}
|◊ii{f}| = (lambda (n)
      (if (= n 0) 1
          (* n (|◊ii{f}| (- n 1))) ) )
◊end{code:lisp}

Итак, что~же такое~$f$? Не~что иное, как всем известный факториал!

Вообще"~то говоря, нет ни~единого основания полагать, что уравнение выше имеет
решение и что оно единственно.
(Конечно, эти термины надо~бы определить строго
математически, но это выходит за рамки данной книги.) Действительно, есть как
минимум ещё одно решение:

◊indexC{fact}
◊begin{code:lisp}
(define (another-fact n)
  (cond ((< n 1) (- n))
        ((= n 1) 1)
        (else (* n (another-fact (- n 1)))) ) )
◊end{code:lisp}

◊indexR{неподвижная точка!наименьшая}
Проверьте, пожалуйста, что ◊ic{another-fact} также является неподвижной точкой
◊ic{meta-fact}.
Анализируя возможные неподвижные точки, можно прийти к~выводу,
что есть такая область определения, на которой их значения совпадают: все они
вычисляют факториал натуральных чисел.
Их поведение различно только тогда, когда
исходный вариант ◊ic{fact} попадает в~бесконечный цикл.
Для отрицательных целых
чисел ◊ic{another-fact} возвращает одно значение, хотя вполне могла~бы вернуть
какое-нибудь другое, потому что исходное функциональное уравнение не~указывает,%
◊footnote*{Более подробное объяснение см.~в~◊cite{man74}.} что делать в~таком
случае.
Если упорядочить функции по некоторой мере их определённости, то должна
существовать наименьшая неподвижная точка — наименее определённое решение
функционального уравнения.

Математический смысл глобальных рекурсивных определений вроде ◊ic{fact} состоит
в~том, что они определяют функции, являющиеся наименьшими неподвижными точками
соответствующих функциональных уравнений.
Когда мы пишем:

◊begin{code:lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )
◊end{code:lisp}

◊noindent
то фактически записываем уравнение относительно переменной~◊ic{fact}.
Форма
◊ic{define} решает это уравнение и связывает полученное решение
с~переменной~◊ic{fact}.
Такая трактовка уводит нас далеко от обсуждения
инициализации глобальных переменных
◊seePage[lisp1-2-omega/recusion/ssect:simple]
и превращает ◊ic{define} в~магический решатель уравнений.
В~действительности,
◊ic{define} реализована именно так, как предложено ранее.
Просто рекурсия
в~глобальном окружении вместе с~нормальным порядком вычислений действительно
способны находить наименьшие неподвижные точки.

А~теперь вернёмся к~◊ic{fix}, нашему Z-комбинатору, и проследим, как~же
вычисляется ◊ic{((fix~meta-fact)~3)}.
Помните, что здесь функции не~имеют
побочных эффектов, а значит, результаты вычислений можно свободно подставлять
друг в~друга, чем мы и будем пользоваться.

◊indexC{fix}
◊begin{code:lisp}
((fix meta-fact) 3)
|◊Equals|   (((d d)|◊begin{where}
                    ◊- d {◊eq} ◊begin{complex}
                              ◊-(lambda (w)
                              ◊-  (lambda (f)
                              ◊-   (f (lambda (x)
                              ◊-        (((w w) f) x) )) ) )
                              ◊end{complex}
                    ◊end{where}|
     meta-fact )
    3 )

|◊Equals|   (((lambda (f)               ; ◊term{шаг I}
       (f (lambda (x)
            (((w w) f) x) )) )|◊begin{where}
                               ◊- w {◊eq} ◊begin{complex}
                                         ◊-(lambda (w)
                                         ◊-  (lambda (f)
                                         ◊-   (f (lambda (x)
                                         ◊-        (((w w) f) x) )) ) )
                                         ◊end{complex}
                              ◊end{where}|
     meta-fact )
    3 )

|◊Equals|   ((meta-fact (lambda (x)
                 (((w w) f) x) ))|◊begin{where}
                                  ◊- w {◊eq} ◊begin{complex}
                                            ◊-(lambda (w)
                                            ◊-  (lambda (f)
                                            ◊-    (f (lambda (x)
                                            ◊-         (((w w) f) x) )) ) )
                                            ◊end{complex}
                                  ◊end{where}|
    3 )
|◊Equals|   ((lambda (n)
      (if (= n 0) 1
          (* n (f (- n 1))) ) )|◊begin{where}
                                ◊- f {◊eq} ◊begin{complex}
                                          ◊-(lambda (x)
                                          ◊-  (((w w) meta-fact) x) )◊begin{where}
                                                         ◊- w {◊eq} ◊begin{complex*}{6.2cm}
                                                                   ◊-(lambda (w)
                                                                   ◊-  (lambda (f)
                                                                   ◊-    (f (lambda (x)
                                                                   ◊-         (((w w) f) x) )) ) )
                                                                   ◊end{complex*}
                                                         ◊end{where}
                                                  ◊end{complex}
                                ◊end{where}|
    3 )
|◊Equals|   (* 3 (f 2))|◊begin{where}
                        ◊- f {◊eq} ◊begin{complex}
                                  ◊-(lambda (x)
                                  ◊-  (((w w) meta-fact) x) )◊begin{where}
                                                             ◊- w {◊eq} ◊begin{complex*}{4.8cm}
                                                                       ◊-(lambda (w)
                                                                       ◊-  (lambda (f)
                                                                       ◊-    (f (lambda (x)
                                                                       ◊-         (((w w) f) x) )) )  )
                                                                       ◊end{complex*}
                                                                      ◊end{where}
                                  ◊end{complex}
                        ◊end{where}|
|◊Equals|   (* 3 (((w w) meta-fact) 2))|◊begin{where}
                                        ◊- w {◊eq} ◊begin{complex}
                                                  ◊-(lambda (w)
                                                  ◊-  (lambda (f)
                                                  ◊-    (f (lambda (x)
                                                  ◊-         (((w w) f) x) )) ) )
                                                  ◊end{complex}
                                        ◊end{where}|
|◊Equals|   (* 3 (((lambda (f)           ; ◊term{шаг II}
            (f (lambda (x)
                 (((w w) f) x) )) )|◊begin{where}
                                    ◊- w {◊eq} ◊begin{complex}
                                              ◊-(lambda (w)
                                              ◊-  (lambda (f)
                                              ◊-    (f (lambda (x)
                                              ◊-         (((w w) f) x) )) ) )
                                              ◊end{complex}
                                    ◊end{where}|
          meta-fact )
         2 ) )
◊end{code:lisp}

Остановимся на минутку, чтобы заметить, что на шаге~II мы получили то~же самое
выражение, что и на шаге~I.
Естественно, оно появится и в~третий~раз:

◊begin{code:lisp}
(* 3 (* 2 (((lambda (f)
              (f (lambda (x)
                   (((w w) f) x) )) )|◊begin{where}
                                      ◊- w {◊eq} ◊begin{complex}
                                                ◊-(lambda (w)
                                                ◊-  (lambda (f)
                                                ◊-    (f (lambda (x)
                                                ◊-         (((w w) f) x) )) ) )
                                                ◊end{complex}
                                      ◊end{where}|
            meta-fact )
           1 )))
|◊Equals|   (* 3 (* 2 ((meta-fact (lambda (x)
                           (((w w) meta-fact) x) ))|◊begin{where}
                                                    ◊- w {◊eq} ◊begin{complex*}{4.5cm}
                                                              ◊-(lambda (w)
                                                              ◊-  (lambda (f)
                                                              ◊-    (f (lambda (x)
                                                              ◊-         (((w w) f) x) )) ) )
                                                              ◊end{complex*}
                                                    ◊end{where}|
              1 )))
|◊Equals|   (* 3 (* 2 ((lambda (n)
                (if (= n 0) 1
                    (* n (f (- n 1))) ) )|◊begin{where}
                                          ◊- f {◊is} ...
                                          ◊end{where}|
              1 )))
|◊Equals|   (* 3 (* 2 (if (= n 0) 1 (* n (f (- n 1))))))|◊begin{where}
                                                         ◊- n {◊is} 1
                                                         ◊- f {◊is} ...
                                                         ◊end{where}|
|◊Equals|   (* 3 (* 2 1))

|◊is| 6
◊end{code:lisp}

Обратите внимание, что в~процессе вычислений мы действительно используем
функцию, вычисляющую факториал.
Это значение выражения:

◊begin{code:lisp}
(lambda (x)
  (((w w) f) x) )|◊begin{where}
                  ◊- f {◊eq} meta-fact
                  ◊- w {◊is} ◊begin{complex}
                            ◊-(lambda (w)
                            ◊-  (lambda (f)
                            ◊-    (f (lambda (x)
                            ◊-         (((w w) f) x) )) ) )
                            ◊end{complex}
                  ◊end{where}|
◊end{code:lisp}

◊indexR{самоприменение!и рекурсия}
Идея состоит в~том, что благодаря самоприменению мы помним, как создать заново
данную функцию, и делаем это каждый раз, когда для вычислений требуется
рекурсивный вызов.

◊indexCS{define}{как решатель уравнений}
Таким образом можно получить простую рекурсию без использования побочных
эффектов, только с~помощью~◊ic{fix}, комбинатора неподвижной точки.
Благодаря
◊comb{Y} (или ◊ic{fix}), ◊ic{define} можно определить как решатель рекурсивных
уравнений; она принимает уравнение и связывает решение с~переданным именем.
В~итоге, если мы передадим ◊ic{define} уравнение для факториала, то с~◊ic{fact}
будет связано следующее значение:

◊begin{code:lisp}
(fix (lambda (fact)
       (lambda (n)
         (if (= n 0) 1
             (* n (fact (- n 1))) ) ) ))
◊end{code:lisp}

Аналогично можно решать системы уравнений, а значит, и задавать взаимно
рекурсивные функции, собирая их уравнения воедино:

◊indexC{odd"?}◊indexC{even"?}
◊begin{code:lisp}
(define odd-and-even
  (fix (lambda (f)
         (lambda (which)
           (case which
             ((odd) (lambda (n) (if (= n 0) #f
                                    ((f 'even) (- n 1)) )))
             ((even) (lambda (n) (if (= n 0) #t
                                     ((f 'odd) (- n 1)) ))) ) ) )) )
(define odd? (odd-and-even 'odd))
(define even? (odd-and-even 'even))
◊end{code:lisp}

У~этого метода есть один большой недостаток: неэффективность, даже по сравнению
с~наивной реализацией~◊ic{letrec}.
(И~всё~же, см.~◊cite{roz92,ser93}.) Тем
не~менее, он используется, особенно в~качестве книжного примера.
Функциональные
языки, по мнению ◊cite{pj87}, тоже особо не~жалуют данный метод, так как,
во-первых, он неэффективен, а во-вторых, ◊ic{fix} плохо сочетается с~системами
вывода типов.
Действительно, ◊ic{fix} принимает функционал,%
◊footnote*{Терминология Маккарти из~◊cite{mae+62}: функционал — это функция,
принимающая другие функции как аргументы.} принимающий функцию типа $◊alpha ◊to
◊beta$, и возвращает неподвижную точку этого функционала.
То~есть типом~◊ic{fix}
является
%
◊[ ◊big((◊alpha ◊to ◊beta) ◊to (◊alpha ◊to ◊beta)◊big) ◊to (◊alpha ◊to ◊beta) ◊]

◊indexR{самоприменение!типизация}
Но в~определении ◊ic{fix} есть самоприменение: ◊ic{(d~d)}.
Обозначив его тип
$◊gamma$, имеем:
%
◊[ ◊gamma = ◊gamma ◊to (◊alpha ◊to ◊beta) ◊]

Потребуется или нетривиальная система типов, чтобы в~ней можно было выразить
подобный рекурсивный тип, или~же мы будем вынуждены реализовать ◊ic{fix}
в~интерпретаторе как примитивную функцию, так как её нельзя выразить средствами
самого языка.


◊section{Заключение}◊label{lisp1-2-omega/sect:conclusions}

В~этой главе мы прошлись по наиболее заметным из вопросов, на которые сообщество
Лиспа за последние несколько десятков лет так и не~смогло дать однозначного
ответа.
Рассмотрев причины данных разногласий, мы поняли, что они вовсе не~такие
серьёзные по своей сути.
Большая часть из них связана с~неоднозначностью
толкования смысла формы ◊ic{lambda} и различными способами применения функций.
Хотя идея функции достаточно хорошо проработана в~математике, но
в~функциональных~(!) языках вроде Лиспа это отнюдь не~так.
Различные мнения по
таким вопросам — это часть истории Лиспа.
Подобно изучению истории родного
народа, их знание облегчает понимание причин тех или иных решений в~дизайне
языка, а также улучшает стиль программирования в~общем.

Также данная глава демонстрирует существенную важность понятия связывания.
В~◊Lisp1 переменная (имя) ассоциируется с~уникальной привязкой (возможно
глобальной), которая в~свою очередь ассоциируется с~каким-либо значением.
Так
как привязка уникальна, то мы говорим о~значении переменной, а не~о~значении
привязки этой переменной.
Если рассматривать привязки как абстрактный тип
данных, то можно сказать, что объекты этого типа создаются связывающими формами,
их значение определяется вычислением, изменяются они присваиванием, и могут быть
захвачены при создании замыкания, если тело замыкания ссылается на переменную,
которая ассоциирована с~данной привязкой.

Привязки не~являются полноценными объектами.
Они не~существуют в~отрыве от
переменных и могут быть изменены только косвенно.
Собственно, привязки полезны
именно потому, что они крепко-накрепко связаны со~своими переменными.

◊indexR{форма!связывающая}
◊indexR{связывающие формы}
◊indexR{область видимости!лексическая}
Бок~о~бок со~связывающими формами следует идея областей видимости.
Область
видимости переменной — это пространство в~тексте программы, где можно
обращаться к~данной переменной.
Область видимости переменных, создаваемых
формой ◊ic{lambda}, ограничена телом данной формы.
Поэтому она называется
текстуальной или лексической.

Присваивание вносит множество неоднозначностей в~идею связывания, мы изучим этот
вопрос подробнее в~следующих главах.


◊section{Упражнения}◊label{lisp1-2-omega/sect:exercises}

◊begin{exercise}◊label{lisp1-2-omega/ex:funcall}
Следующее выражение записано на {◊CommonLisp}.
Как бы вы его перевели на~Scheme?

◊begin{code:lisp}
(funcall (function funcall) (function funcall) (function cons) 1 2)
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:lexical}
Что вернёт данная программа на псевдо-{◊CommonLisp} из этой главы?
О~чём она вам напоминает?

◊begin{code:lisp}
(defun test (p)
  (function bar) )

(let ((f (test #f)))
  (defun bar (x) (cdr x))
  (funcall f '(1 .
2)) )
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:innovations}
Реализуйте в~вашем интерпретаторе первые две инновации из
раздела~◊ref{lisp1-2-omega/sect:extensions}
◊seePage[lisp1-2-omega/sect:extensions].
Речь идёт о~трактовке чисел и
списков как функций.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:assoc-with-comparator}
Можно научить функцию ◊ic{assoc/de} явно принимать компаратор (вроде ◊ic{eq?},
◊ic{equal?} {◊itp}) через аргумент, а не~задавать его внутри.
Сделайте это.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:dynamic}
Используя ◊ic{bind/de} и ◊ic{assoc/de}, напишите макросы, эмулирующие
специальные формы ◊ic{dynamic-let}, ◊ic{dynamic} и~◊ic{dynamic-set!}.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:write-put/get-prop}
◊indexC{putprop}◊indexC{getprop}
Напишите функции ◊ic{getprop} и ◊ic{putprop}, которые реализуют списки свойств.
Любой символ имеет личный список свойств в~виде пар «ключ — значение»;
добавление в~этот список осуществляет функция~◊ic{putprop}, поиск значения по
ключу осуществляет функция~◊ic{getprop}.
Также, естественно, должно выполняться
утверждение

◊begin{code:lisp}
(begin (putprop 'symbol 'key 'value)
       (getprop 'symbol 'key) )      |◊is| value
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:label}
Определите специальную форму ◊ic{label} на ◊Lisp1.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:labels}
Определите специальную форму ◊ic{labels} на ◊Lisp2.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:orderless-letrec}
◊indexC{letrec}
Придумайте, как реализовать ◊ic{letrec} с~помощью ◊ic{let} и ◊ic{set!} так,
чтобы порядок вычисления значений"=инициализаторов был неопределённым.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:fixn}
◊indexR{комбинаторы!неподвижной точки!универсальный}
У~нашего комбинатора неподвижной точки на Scheme обнаружился недостаток: он
поддерживает только унарные функции.
Реализуйте ◊ic{fix2}, работающий
с~бинарными функциями.
Затем ◊ic{fixN}, поддерживающий функции любой арности.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:nfixn}
Далее напишите функцию ◊ic{NfixN}, возвращающую неподвижные точки для списка
функционалов произвольной арности.
Её можно использовать, например, следующим
образом:

◊begin{code:lisp}
(let ((odd-and-even
       (NfixN (list (lambda (odd? even?)    ; ◊ic{odd?}
                      (lambda (n)
                        (if (= n 0) #f (even? (- n 1))) ) )
                    (lambda (odd? even?)    ; ◊ic{even?}
                      (lambda (n)
                        (if (= n 0) #t (odd? (- n 1))) ) ) )) ))
  (set! odd? (car odd-and-even))
  (set! even? (cadr odd-and-even)) )
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:klop}
Рассмотрим функцию ◊ic{klop}.
Является~ли она комбинатором неподвижной точки?
Попробуйте доказать или опровергнуть, что ◊ic{(klop $f$)} тоже возвращает
неподвижную точку~$f$ подобно~◊ic{fix}.

◊indexC{klop}
◊begin{code:lisp}
(define klop
  (let ((r (lambda (s c h e m)
             (lambda (f)
               (f (lambda (n)
                    (((m e c h e s) f) n) )) ) )))
    (r r r r r r) ) )
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:hyper-fact}
◊indexC{fact}
Если функция ◊ic{hyper-fact} определена так:

◊begin{code:lisp}
(define (hyper-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n ((f f) (- n 1))) ) ) )
◊end{code:lisp}

◊noindent
то что вернёт ◊ic{((hyper-fact hyper-fact)~5)}?
◊end{exercise}

◊section*{Рекомендуемая литература}%
◊label{lisp1-2-omega/sect:recommended-reading}

Кроме упомянутой ранее работы по $◊lambda$"=исчислению ◊cite{ss78a} также имеет
смысл почитать про анализ функций в~◊cite{mos70} и сравнительный анализ ◊Lisp1
и ◊Lisp2 в~◊cite{gp88}.

В~◊cite{gor88} есть интересное введение в~$◊lambda$"=исчисление.

Комбинатор ◊comb{Y} разбирается подробнее в~◊cite{gab88}.
