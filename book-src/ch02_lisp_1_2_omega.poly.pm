% -*- coding: utf-8 -*-

◊subsection{Динамические~переменные в~{◊CommonLisp}}%
◊label{lisp1-2-omega/namespaces/ssect:dyn-vars-cl}

◊indexR{динамические переменные!синтаксис}
◊indexR{синтаксис!динамических переменных}
Хотя {◊CommonLisp} разделяет динамические и лексические переменные с~точки
зрения вычислений, но синтаксис их использования отличается слабо.
В~нём нет
формы ◊ic{dynamic-let}, но её можно легко сымитировать:

{◊def◊E{◊hbox to 0pt{◊kern0.15em$◊equals$}}
◊begin{code:lisp}
(dynamic-let ((x |$◊alpha$|)) |◊E|   (let ((x |$◊alpha$|))
  |$◊beta$| )                     (declare (special x))
                          |$◊beta$| )
◊end{code:lisp}}

Отличие состоит в~том, что для получения значения динамической переменной~◊ic{x}
внутри $◊beta$ нет надобности использовать форму ◊ic{dynamic}, достаточно писать
просто~◊ic{x}.
Причина такого поведения в~том, что выражение ◊ic{(declare
(special~x))} означает сразу две вещи: привязка, устанавливаемая ◊ic{let}
для~◊ic{x} должна быть динамической, а каждая ссылка на~◊ic{x} внутри
тела~◊ic{let} должно пониматься как ◊ic{(dynamic~x)}.

Это не~совсем удобно, так как внутри~$◊beta$ нельзя обращаться к~лексической
переменной~◊ic{x}, нам будет видна только её динамическая тёзка.
Можно было~бы
пойти другим путём, указывая конкретные места, где необходимо использовать
динамическую переменную~◊ic{x} с~помощью конструкции ◊ic{(locally (declare
(special~x)) x)}.
Это в~точности идентично нашей форме~◊ic{dynamic}.

Стратегия {◊CommonLisp} состоит в~указании типа привязки с~помощью конструкций
языка.
Мы можем реализовать этот механизм, сделав следующие изменения
в~интерпретаторе:

◊indexC{df.evaluate}
◊indexC{special-extend}
◊indexC{cl.lookup}
◊begin{code:lisp}
(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (cl.lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv) ))
        ((begin)  (df.eprogn (cdr e) env fenv denv))
        ((set!)   (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv) ))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv) ) )
        ((dynamic-let)
         (df.eprogn (cddr e)
                    [(special-extend env]
                                    [(map car (cadr e)) )]
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv) )
                                 (map cadr (cadr e)) ) ) ) )
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv )) ) ) )

(define (special-extend env variables)
  (append variables env) )

(define (cl.lookup var env denv)
  (let look ((env env))
    (if (pair? env)
        (if (pair? (car env))
            (if (eq? (caar env) var)
                (cdar env)
                (look (cdr env)) )
            (if (eq? (car env) var)
                ;; ищем в~текущем динамическом окружении
                (let lookup-in-denv ((denv denv))
                  (if (pair? denv)
                      (if (eq? (caar denv) var)
                          (cdar denv)
                          (lookup-in-denv (cdr denv)) )
                      ;; если не~находим, ищем в~глобальном лексическом
                      (lookup var env.global) ) )
                (look (cdr env)) ) )
        (wrong "No such binding" var) ) ) )
◊end{code:lisp}

Теперь разберём, как это работает.
Когда ◊ic{dynamic-let} создаёт динамическую
переменная, она не~только связывает её со~значением в~динамическом окружении, но
и помечает её как динамическую в~лексическом окружении, записывая туда её имя.
Для поддержки этих меток изменяется механизм поиска значения по ссылке
(◊ic{cl.lookup}): он должен проанализировать ссылку, чтобы определить тип
привязки (лексическая или динамическая), после чего отыскать значение
в~правильном окружении.
Также, если переменная не~найдена в~текущем динамическом
окружении, то следующим просматривается глобальное лексическое окружение,
которое в~{◊CommonLisp} одновременно является глобальным динамическим.

Приведём пример работы такого ◊Lisp3, имитирующего {◊CommonLisp}:

◊begin{code:lisp}
(dynamic-let ((x 2))
  (+ x                        ; динамический~◊ic{x}
     (let ((x (+              ; лексический
                 x x )))      ; динамические
       (+ x                   ; лексический
          (dynamic x) ) ) ) ) ; динамический
|◊is| 8
◊end{code:lisp}


◊subsection{Динамические~переменные без~специальных~форм}%
◊label{lisp1-2-omega/namespaces/ssect:dyn-vars-no-special}

Сейчас для работы с~динамическими переменными используются целых три специальные
формы.
Так как Scheme исповедует минимализм по отношению к~количеству
специальных форм, стоит подумать о~других вариантах.
Не~будем рассматривать их
все, а остановимся на следующем, так как он использует всего две функции.
Первая
функция динамически связывает два значения; вторая функция может по первому
значению найти второе.
На роль идентификаторов динамических переменных прекрасно
подходят символы.
Кроме них нам потребуется некий изменяемый тип данных вроде
точечных пар, если мы хотим изменять установленные связи.
Так наше решение будет
удовлетворять аскетичным традициям Scheme.

Во~время изучения данного подхода мы будем использовать интерпретатор с~двумя
окружениями: ◊ic{env} и ◊ic{denv}.
Это тот~же предыдущий интерпретатор, только
из него убрано несколько вещей: ненужные специальные формы, поддержка
функциональных окружений и ссылки на переменные как в~{◊CommonLisp}.
Остались
только мы и динамические окружения.
Такой интерпретатор несколько менее полезен,
так как динамическое окружение уже нельзя расширять непосредственно, но, тем
не~менее, это окружение всё ещё передаётся в~каждую функцию — и~этого
достаточно! Чтобы отличать эту вариацию от предыдущих, её функциям выдан
префикс~◊ic{dd}.

◊indexC{dd.evaluate}
◊indexC{dd.make-function}
◊indexC{dd.evlis}
◊indexC{dd.eprogn}
◊begin{code:lisp}
(define (dd.evaluate e env denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (dd.evaluate (cadr e) env denv)
                      (dd.evaluate (caddr e) env denv)
                      (dd.evaluate (cadddr e) env denv) ))
        ((begin)  (dd.eprogn (cdr e) env denv))
        ((set!)   (update! (cadr e) env
                           (dd.evaluate (caddr e) env denv) ))
        ((lambda) (dd.make-function (cadr e) (cddr e) env))
        (else (invoke (dd.evaluate (car e) env denv)
                      (dd.evlis (cdr e) env denv)
                      denv )) ) ) )

(define (dd.make-function variables body env)
  (lambda (values denv)
    (dd.eprogn body (extend env variables values) denv) ) )

(define (dd.evlis e* env denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (cons (dd.evaluate (car e*) env denv)
                (dd.evlis (cdr e*) env denv) )
          (list (dd.evaluate (car e*) env denv)) )
      '() ) )

(define (dd.eprogn e* env denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (begin (dd.evaluate (car e*) env denv)
                 (dd.eprogn (cdr e*) env denv) )
          (dd.evaluate (car e*) env denv) )
      empty-begin ) )
◊end{code:lisp}

Как мы и обещали, теперь определим две функции.
Первую назовём
◊ic{bind-with-dynamic-extent}; это длинное название, так что сократим его до
◊ic{bind/de}.
Первым её аргументом является ключ~◊ic{tag}; вторым —
значение~◊ic{value}, связываемое с~ключом; третьим — замыкание~◊ic{thunk},
функция без аргументов, которая будет вызвана в~расширенном динамическом
окружении.

◊indexC{bind/de}
◊begin{code:lisp}
(definitial bind/de
  (lambda (values denv)
    (if (= 3 (length values))
        (let ((tag   (car values))
              (value (cadr values))
              (thunk (caddr values)) )
          (invoke thunk '()
                  (extend denv (list tag) (list value)) ) )
        (wrong "Incorrect arity" 'bind/de) ) ) )
◊end{code:lisp}

Следующая функция будет использовать динамическое окружение.
Так как нам надо
что"~то делать в~случае, если динамической переменной с~запрошенным именем нет,
то функция ◊ic{assoc/de} первым аргументом принимает ключ, а вторым —
функцию.
Она вызовет полученную функцию и передаст ей ключ, если не~найдёт его
в~динамическом окружении.

◊indexC{assoc/de}
◊begin{code:lisp}
(definitial assoc/de
  (lambda (values current.denv)
    (if (= 2 (length values))
        (let ((tag     (car values))
              (default (cadr values)) )
          (let look ((denv current.denv))
            (if (pair? denv)
                (if (eqv? tag (caar denv))
                    (cdar denv)
                    (look (cdr denv)) )
                (invoke default (list tag) current.denv) ) ) )
        (wrong "Incorrect arity" 'assoc/de) ) ) )
◊end{code:lisp}

Можно реализовать несколько вариантов её поведения в~зависимости от
используемого механизма сравнения (◊ic{eqv?} или ◊ic{equal?}).
◊seeEx[lisp1-2-omega/ex:assoc-with-comparator]

◊ForLayout{display}{◊clearpage}

Перепишем предыдущий пример:

◊begin{code:lisp}
(bind/de 'x 2
  (lambda () (+ (assoc/de 'x error)
                (let ((x (+ (assoc/de 'x error)
                            (assoc/de 'x error) )))
                  (+ x (assoc/de 'x error)) ) )) )
|◊is| 8
◊end{code:lisp}

Таким образом, мы опровергли необходимость использования специальных форм для
реализации механизма динамических переменных.
Заодно мы получили возможность
связывать что угодно с~чем угодно.
Конечно, это преимущество — ничто по
сравнению с~тем, что есть гораздо более эффективные реализации динамических
переменных (даже без учёта многопоточности).
Хотя~бы то~же ближнее связывание,
которое лишь требует, чтобы ключ был символом.◊footnote*{Многие реализации Лиспа
не~считают ключевые слова вроде ◊ic{nil} или ◊ic{if} символами (а~значит, и
легальными именами переменных).} С~другой стороны, в~данном варианте не~потеряна
ссылочная прозрачность.
Но всё равно доступ к~динамическим переменным требует
недешёвых вызовов функций.
Наше решение ещё довольно далеко от органичного
сочетания динамических и лексических переменных в~{◊CommonLisp}.

Среди всех неудобств стоит отметить ещё то, что использование ◊ic{bind/de}
требует использования ◊ic{assoc/de} и написания функции-обработчика.
Хотя,
естественно, с~помощью макросов это можно спрятать.
Другое неудобство возникает
уже для компилятора: ведь ему надо будет генерировать код для создания и
использования динамических переменных.
К~счастью, они помечены вызовами
соответствующих функций, так что дальнейшее отдаётся на откуп компилятору:
генерировать код в~лоб (это легче) или вставить свою, более эффективную
реализацию.


◊subsection{В~заключение о~пространствах~имён}%
◊label{lisp1-2-omega/namespaces/ssect:conclusions}

После отступления к~динамическим переменным, вернёмся к~идее пространств имён
в~общем: специализированные окружения для специализированных объектов.
Мы уже
видели ◊Lisp3 в~деле, а также разобрали механизм динамических переменных
в~{◊CommonLisp}.

◊indexE{Lispn@◊protect◊Lisp{◊protect◊ii{n}}}
◊indexR{Лисп!Lispn@◊protect◊Lisp{◊protect◊ii{n}}}
Тем не~менее, наша последняя реализация — та, что с~двумя функциями вместо
трёх специальных форм, — поднимает каверзный вопрос.
Если это ◊Lisp{$n$}, то
чему равно~$n$? Базируется она на~Scheme, но всё~же явно имеет два окружения:
◊ic{env} и~◊ic{denv}.
В~то~же время, вычислитель у~неё лишь один, что является
отличительной чертой Scheme и класса~◊Lisp1.
Однако, нам пришлось довольно
сильно модифицировать интерпретатор (просто сравните ◊ic{evaluate} и
◊ic{dd.evaluate}), чтобы реализовать функции ◊ic{bind/de} и ◊ic{assoc/de}.
Мы
столкнулись с~примитивными функциями, которые нельзя выразить тем~же языком,
если только они уже не~определены; более того, само существование этих функций
глубоко влияет на процесс вычислений.
В~следующей главе будет такая~же ситуация
с~◊ic{call/cc}.

◊indexR{списки свойств}
◊indexR{символы!списки свойств}
Короче говоря, похоже, что у~нас получился ◊Lisp1, если смотреть на количество
вычислителей, и ◊Lisp2 — если смотреть на пространства имён.
Обобщением этих
парадоксов является мнение, что наличие списка свойств у~символов является
чертой ◊Lisp{$n$}, где $n$ может быть произвольным.
◊seeEx[lisp1-2-omega/ex:write-put/get-prop]
Так как наши пространства имён объективно существуют, а значения соответствующих
переменных вычисляются особым образом (пусть и с~помощью примитивных функций, а
не~специальных форм), то будем считать нашу реализацию представителем
класса~◊Lisp2.

◊bigskip

◊indexC{csetq}
◊indexR{константы}
Остаётся ещё один урок, который можно извлечь из рассмотрения лексических и
динамических переменных.
{◊CommonLisp} старается унифицировать доступ
к~переменным из различных пространств имён, предоставляя одинаковый синтаксис.
Поэтому необходимо знать правила, по которым он определяет, из какого
пространства имён взять переменную.
К~сожалению, они не~всегда однозначны;
например, {◊CommonLisp} не~различает глобальное динамическое и глобальное
лексическое окружения.
Далее, в~◊LISP~1.5 существовала концепция констант,
определяемых специальной формой~◊ic{csetq} (◊ic{setq} для констант).

◊begin{envtable}
Ссылка      & ◊ii{x}                         ◊◊
Значение    & ◊ii{x}                         ◊◊
Изменение   & ◊ic{(csetq ◊ii{x} ◊ii{форма})} ◊◊
Расширение  & запрещено                      ◊◊
Определение & ◊ic{(csetq ◊ii{x} ◊ii{форма})} ◊◊
◊end{envtable}

Введение констант тоже делает синтаксис неоднозначным.
Когда мы пишем ◊ic{foo}
— это может быть как константа, так и переменная.
Правило разрешения
противоречий в~◊LISP~1.5 было таково: если существует константа с~именем
◊ic{foo}, то вернуть её значение; иначе искать одноимённую переменную
в~лексическом пространстве имён.
Но: «константы» можно изменять (представьте
себе!) с~помощью той~же формы ◊ic{csetq}, что используется для их создания.
Таким образом, константы ◊LISP~1.5 соответствуют глобальным переменным Scheme,
только с~обратным приоритетом: в~Scheme сначала ищется локальная лексическая
переменная, а глобальная переменная является лишь значением по умолчанию на
случай, если локальная переменная не~будет найдена.

Проблема имеет довольно общий характер.
Если для доступа к~нескольким
пространствам имён используется одинаковый синтаксис, то необходимы чётко
прописанные правила разрешения неоднозначностей.


◊section{Рекурсия}◊label{lisp1-2-omega/sect:recursion}

◊indexR{рекурсия}
◊indexR{рекурсия|seealso{рекурсия}}
◊indexR{рекурсия|◊protect◊indexR{рекурсия}}
Рекурсия естественна для Лиспа, но мы пока так ничего и не~сказали о~том, как~же
она реализуется.
Далее мы проанализируем различные типы рекурсии и вызываемые
ими проблемы.


◊subsection{Простая рекурсия}◊label{lisp1-2-omega/recusion/ssect:simple}

◊indexR{рекурсия!простая}
Наверное, наиболее известной простой рекурсивной функцией является факториал,
определяемый следующим образом:

◊indexC{fact}
◊begin{code:lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )
◊end{code:lisp}

Язык, который был определён в~предыдущей главе, не~знает, что такое ◊ic{define},
так что давайте представим, что это макрос, который раскрывается в~следующий
код:

◊begin{code:lisp}
(set! fact (lambda (n)
             (if (= n 0) 1
                 (* n (fact (- n 1))) ) ))
◊end{code:lisp}

◊indexR{привязки (bindings)!неинициализированные}
Здесь мы видим присваивание, изменение значения переменной ◊ic{fact}.
Это
изменение бессмысленно, если переменная ◊ic{fact} не~существует.
Глобальное
окружение можно считать местом, где уже существуют все возможные переменные.
В~этой ◊emph{виртуальной реальности} интерпретатор (а~точнее, его часть,
ответственная за чтение программ) должен создать привязку для переменной, когда
впервые видит её имя, после чего невозмутимо продолжить работу, будто~бы эта
переменная уже сто лет как здесь.
Каждая переменная уже существует до своего
первого использования, а~значит, её определение — это лишь изменение значения
существующей переменной.
Но при таком подходе возникает проблема с~получением
значения переменной, которой ещё ничего не~было присвоено.
Интерпретатор должен
отловить эту ошибку, когда переменная вроде как есть, но значения у~неё ещё нет.
Как видите, идея привязок не~так уж и проста, мы рассмотрим её подробнее
в~четвёртой главе.
◊seePage[chapter:assignment]

◊indexC{define}
Можно избавиться от проблем с~привязками, которые существуют, но еще
не~инициализированы, если принять другую позицию.
Пусть изменять можно только
существующие переменные; иными словами, переменной нет, если она не~была
определена явно.
Для этого используется специальная форма ◊ic{define},
создающая переменные.
Без неё у~нас не~получится ни~обратиться к~переменной,
ни~установить её значение.
Однако, посмотрим теперь на это с~другой стороны:

◊begin{code:lisp}[label=lisp1-2-omega/recusion/simple/code:redefine]
(define (display-pi)
  (display pi) )
(define pi 2.7182818285)    ; ой, не~та константа
(define (print-pi)
  (display pi) )
(define pi 3.1415926536)
◊end{code:lisp}

Допустимо~ли такое определение ◊ic{display-pi}? Её тело ссылается на ◊ic{pi},
которая ещё не~определена.
Четвёртый~◊ic{define} исправляет ошибку во~втором; но
даже если ◊ic{define} создаёт новую привязку, можно~ли создать ещё одну
с~таким~же именем?

Эти вопросы не~имеют однозначного ответа.
Есть как минимум два варианта: считать
глобальные определения лексическими (как это делает~ML) или считать их
динамическими (как это принято в~Лиспе).

◊indexR{окружение!глобальное!гиперстатическое}
◊indexR{глобальное окружение!гиперстатическое}
◊indexR{гиперстатическое окружение}
◊phantomlabel{lisp1-2-omega/recusion/simple/par:hyperstatic}
В~глобальном окружении, которое ◊emph{полностью лексично} — будем называть
его ◊term{гиперстатическим}, — мы не~можем использовать переменную (ссылаться
на неё, получать или изменять её значение), если она не~существует.
В~нём
определение функции ◊ic{display-pi} будет ошибочным, так как оно ссылается на
переменную~◊ic{pi}, которая не~существует на момент определения.
Любой вызов
функции ◊ic{display-pi} привёл~бы к~ошибке «Неизвестная переменная:~◊ic{pi}»
(если~бы это не~случилось ещё при её определении).
Но с~функцией ◊ic{print-pi}
всё в~порядке, она будет выводить значение, существовавшее на момент её
определения (в~данном случае это ◊ic{2.7182818285}), и ничто не~сможет изменить
выводимое значение.
Здесь переопределение~◊ic{pi} вполне~допустимо и создаст
новую переменную~◊ic{pi}, которая будет использоваться в~последующих выражениях
в~пределах своей области видимости.
Предыдущий пример можно представить примерно
таким образом:

◊begin{code:lisp}
(let ((display-pi (lambda () (display pi))))
  (let ((pi 2.7182818285))
    (let ((print-pi (lambda () (display pi))))
      (let ((pi 3.1415926536))
        ...
) ) ) )
◊end{code:lisp}

В~Лиспе, как было сказано, принят динамический подход.
Предполагается, что может
существовать максимум одна глобальная переменная с~уникальным именем, и эта
переменная видна везде, в~том числе в~своём собственном определении.
Лисп
поддерживает опережающие ссылки без какого-либо специального синтаксиса.
(Под
таким синтаксисом понимаются явные объявления вроде ключевого слова ◊ic{forward}
Паскаля или прототипов ISO~C~◊cite{iso90}.)

Выбор отнюдь не~так прост.
Возвращаясь к~факториалу; в~окружении, где будет
вычисляться ◊ic{lambda}-форма, необходимо ответить на вопрос: «Чему здесь равно
значение ◊ic{fact}?» Если вычисление происходит в~глобальном окружении, где нет
привязки для ◊ic{fact}, то эта функция в~принципе не~может быть рекурсивной.
Причина: функция ссылается на некую переменную ◊ic{fact}, значение которой
следует искать в~окружении, захваченном замыканием (в~том, которое состоит из
свободных переменных и параметров функции).
Так как в~момент создания замыкания
переменная ◊ic{fact} не~существовала, то и в~окружении её нет.
Следовательно,
для рекурсии её необходимо каким"~то образом туда добавить.
Проще всего это
сделать, выбрав динамический подход к~глобальному окружению, который снимает
вопрос существования переменных в~принципе.
При гиперстатическом~же подходе надо
убедиться в~том, что ◊ic{define} создаёт привязку для ◊ic{fact} перед тем, как
вычислять замыкание, которое станет значением ◊ic{fact}.
Резюмируя: простая
рекурсия требует глобального окружения.


◊subsection{Взаимная рекурсия}◊label{lisp1-2-omega/recusion/ssect:mutual}

◊indexR{рекурсия!взаимная}
Теперь предположим, что мы хотим определить две взаимно рекурсивные функции.
Возьмём для примера ◊ic{odd?} и ◊ic{even?}, реализующие (весьма медленную)
проверку натуральных чисел на чётность.
Они определяются следующим образом:

◊indexC{even?}◊indexC{odd?}
◊indexE{even?@◊protect◊ic{even?}|seealso{◊protect◊ic{odd?}}}
◊indexE{odd?@◊protect◊ic{odd?}|seealso{◊protect◊ic{even?}}}
◊begin{code:lisp}
(define (even? n)
  (if (= n 0) #t (odd? (- n 1))) )
(define (odd? n)
  (if (= n 0) #f (even? (- n 1))) )
◊end{code:lisp}

Можно менять их местами, но в~любом случае первое определение не~будет знать
о~втором; в~данном случае ◊ic{even?} не~знает в~момент определения про
◊ic{odd?}.
И~опять, кажется, решением будет глобальное окружение с~заранее
созданными переменными: оба замыкания захватывают глобальное окружение,
в~котором есть все возможные переменные, среди них, в~частности, и необходимые
◊ic{odd?} и~◊ic{even?}.
Конечно, мы пока оставим в~стороне вопрос, как именно
реализуется захват только необходимых привязок.

Довольно непросто перенести это поведение в~мир с~гиперстатическим глобальным
окружением, так как здесь уж точно первое определение никогда не~сможет узнать
о~втором.
Одно из решений состоит в~том, чтобы определять эти две функции
одновременно, тогда не~будет никаких первых и вторых, и обе функции смогут
ссылаться друг на друга без проблем.
(Мы вернёмся к~этому вопросу чуть позже,
после изучения локальной рекурсии.) Например, когда"~то в~◊LISP~1.5 имелась
форма ◊ic{define} с~подобной возможностью:

◊indexCS{define}{параллельные объявления}
◊begin{code:lisp}
(define ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))) ))
◊end{code:lisp}

Таким образом, с~помощью глобального окружения и некоторых ухищрений можно
выразить и взаимную рекурсию.

Но что случится, если нам понадобятся локальные рекурсивные функции?


◊subsection{◊texorpdfstring{Локальная~рекурсия в~◊Lisp2}%
{Локальная рекурсия в Lisp₂}}%
◊label{lisp1-2-omega/recusion/ssect:local-lisp2}

◊indexR{рекурсия!локальная}
Некоторые проблемы, с~которыми мы столкнулись при попытках определить~◊ic{fact}
в~глобальном окружении, возвращаются при попытках определить~◊ic{fact} локально.
Нам надо сделать что"~то, чтобы вызов ◊ic{fact} из тела ◊ic{fact} был
рекурсивным.
Чтобы ◊ic{fact} из функционального окружения была связана
с~функцией вычисления факториала даже внутри самой функции вычисления
факториала.
И~вот здесь как раз проявляется отличие между локальным и
глобальным окружениями: вспомните, что происходит, если искомая локальная
переменная не~существует.
Рассмотрим следующую программу на~◊Lisp2:

◊indexC{fact}
◊begin{code:lisp}
(flet ((fact (n) (if (= n 0) 1
                     (* n (fact (- n 1))) )))
  (fact 6) )
◊end{code:lisp}

Форма ◊ic{flet} связывает функцию вычисления факториала с~именем~◊ic{fact}
в~своём внутреннем функциональном окружении.
Замыкание захватывает
функциональное и параметрическое окружения, локальные для формы~◊ic{flet}.
Таким
образом, ◊ic{fact} внутри ◊ic{fact} ссылается не~на функцию ◊ic{fact}, локальную
для тела~◊ic{flet}, а на какую"~то другую функцию ◊ic{fact} из окружения всей
формы~◊ic{flet}.
Эта функция не~обязана вычислять факториал (а~то и вовсе
не~существует), так что рекурсию мы не~получаем.

◊indexC{label}
◊indexR{специальные формы!label@◊protect◊ic{label}}
Эта проблема была очевидна ещё во~времена ◊LISP~1.5.
Для её решения была введена
специальная форма~◊ic{label}, позволявшая определять локальные рекурсивные
функции.
Пример с~факториалом тогда записывается так:

◊begin{code:lisp}
(label fact (lambda (n) (if (= n 0) 1
                            (* n (fact (- n 1))) )))
◊end{code:lisp}

Эта форма возвращает анонимную функцию, вычисляющую факториал.
Более того, это
именно та функция, которая связана с~◊ic{fact} в~своём~же теле.

◊indexC{labels}
◊indexR{специальные формы!labels@◊protect◊ic{labels}}
К~сожалению, нельзя сказать, что ◊LISP~1.5 был~◊Lisp2, а ◊ic{label}, какой~бы
удобной она не~была, не~может легко справиться со~взаимной рекурсией.
Поэтому
гораздо позже, судя по~◊cite{hs75}, был изобретён её $n$"~арный аналог:
◊ic{labels}.
Эта форма имеет тот~же синтаксис, что и~◊ic{flet}, но гарантирует,
что замыкания будут создаваться в~окружении, где можно ссылаться на локальные
функции.
С~её помощью можно определить и~◊ic{fact}, и~взаимно рекурсивные
◊ic{odd?} и~◊ic{even?}:

◊begin{code:lisp}
(labels ((fact (n) (if (= n 0) 1
                       (* n (fact (- n 1))) )))
  (fact 6) ) |◊is| 720

(funcall (labels ((even? (n) (if (= n 0) #t (odd? (- n 1))))
                  (odd? (n) (if (= n 0) #f (even? (- n 1)))) )
           (function even?) )
         4 ) |◊is| #t
◊end{code:lisp}

Так что в~◊Lisp2 мы имеем две формы для расширения локального функционального
окружения: ◊ic{flet} и~◊ic{labels}.


◊subsection{◊texorpdfstring{Локальная~рекурсия в~◊Lisp1}%
{Локальная рекурсия в Lisp₁}}%
◊label{lisp1-2-omega/recusion/ssect:local-lisp1}

◊indexR{рекурсия!локальная}
Проблема определения локальных рекурсивных функций существует и в~◊Lisp1;
решается она похожим способом.
Форма~◊ic{letrec} (рекурсивная~◊ic{let}) очень
похожа по~смыслу на~◊ic{labels}.

В~Scheme ◊ic{let} имеет следующий синтаксис:

◊begin{code:lisp}
(let ((|◊ii{переменная◊sub{1}}| |◊ii{выражение◊sub{1}}|)
      (|◊ii{переменная◊sub{2}}| |◊ii{выражение◊sub{2}}|)
       ...
      (|◊ii{переменная◊sub{n}}| |◊ii{выражение◊sub{n}}|) )
  |◊ii{выражения}|...
)
◊end{code:lisp}

◊indexC{let}
◊noindent
И~она эквивалентна такому выражению:

◊begin{code:lisp}
((lambda (|◊ii{переменная◊sub{1}}| |◊ii{переменная◊sub{2}}| ...
|◊ii{переменная◊sub{n}}|) |◊ii{выражения}|...)
 |◊ii{выражение◊sub{1}}| |◊ii{выражение◊sub{2}}| ...
|◊ii{выражение◊sub{n}}| )
◊end{code:lisp}

Поясним, что здесь происходит.
Сперва вычисляются все аргументы аппликации:
◊ii{выражение◊sub{1}}, ◊ii{выражение◊sub{2}}, ◊dots, ◊ii{выражение◊sub{n}};
затем переменные ◊ii{перемен◊-ная◊sub{1}}, ◊ii{перемен◊-ная◊sub{2}}, ◊dots,
◊ii{перемен◊-ная◊sub{n}} связываются с~только что полученными значениями;
наконец, ◊ii{выражения}, составляющие тело~◊ic{let}, вычисляются в~расширенном
окружении внутри неявной формы~◊ic{begin}, а её значение становится значением
всей формы~◊ic{let}.

Как видим, в~принципе нет необходимости делать ◊ic{let} специальной формой, так
как её полностью заменяет ◊ic{lambda}; следовательно, ◊ic{let} может быть всего
лишь макросом.
(Именно так и поступили в~Scheme: ◊ic{let} — это встроенный
макрос.) Тем~не~менее, ◊ic{let} хороша с~точки зрения стиля кодирования, потому
что позволяет не~разделять имя переменной и её начальное значение большим куском
кода.
Теперь самое время заметить, что начальные значения локальных переменных
формы ◊ic{let} вычисляются в~текущем окружении; в~расширенном вычисляется только
её тело.

◊indexC{letrec}
По тем~же причинам, с~которыми мы столкнулись в~◊Lisp2, это значительно
усложняет написание взаимно рекурсивных функций.
Поэтому вводится форма
◊ic{letrec}, аналог~◊ic{labels}.

Синтаксис~◊ic{letrec} такой~же, как и у~◊ic{let}.
Например:

◊begin{code:lisp}
(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))) )
  (even? 4) )
◊end{code:lisp}

◊indexCS{letrec}{как макрос}
Отличается ◊ic{letrec} от ◊ic{let} тем, что выражения"=инициализаторы
вычисляются в~том~же окружении, что и тело~◊ic{letrec}.
Операции, которые
выполняет~◊ic{letrec}, те~же, что и у~◊ic{let}, но их порядок несколько иной.
Сначала локальное окружение расширяется переменными ◊ic{letrec}.
Затем в~этом
расширенном окружении вычисляются начальные значения переменных.
Наконец,
в~том~же расширенном окружении вычисляется тело~◊ic{letrec}.
По~этому описанию
довольно легко понять, как реализовать такое поведение.
Действительно,
достаточно написать следующее:

◊indexC{even"?}◊indexC{odd"?}◊indexC*{void}{'void}
◊begin{code:lisp}
(let ((even? 'void) (odd? 'void))
  (set! even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
  (set! odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
  (even? 4) )
◊end{code:lisp}

Сначала создаются привязки для ◊ic{even?} и~◊ic{odd?}.
(Их начальные значения
не~важны, просто ◊ic{let} и ◊ic{lambda} требуют какое"~то значение.) Затем эти
переменные инициализируются значениями, вычисленными в~окружении, где известны
переменные ◊ic{even?} и~◊ic{odd?}.
Мы говорим «известны», потому что хотя для
этих переменных и созданы привязки, их значения не~имеют смысла, так как они
ещё не~были правильно инициализированы.
Про ◊ic{even?} и ◊ic{odd?} известно
достаточно, чтобы ссылаться на них, но пока ещё недостаточно, чтобы они
участвовали в~вычислениях.

◊indexR{порядок вычислений!неопределённый}
Однако, такое преобразование не~совсем корректно из"~за порядка вычислений:
действительно, ◊ic{let} раскрывается в~применение функции, следовательно,
◊ic{letrec}, по~идее, должна вести себя так~же, а это значит, что начальные
значения переменных должны вычисляться как аргументы функции — то~есть
в~неопределённом порядке.
К~сожалению, подобный вариант всегда вычисляет их
слева направо.
◊seeEx[lisp1-2-omega/ex:orderless-letrec]


◊subsubsection{◊texorpdfstring{Уравнения и~◊protect◊ic{letrec}}%
{Уравнения и letrec}}

◊indexCS{letrec}{и~уравнения}
С~формой~◊ic{letrec} есть ещё одна серьёзная проблема: её синтаксис не~является
строгим.
При текущей трактовке ◊ic{letrec} допускает в~качестве инициализаторов
всё что угодно, не~только функции; тогда как ◊ic{labels} в~{◊CommonLisp}
разрешает определять исключительно функции.
То~есть в~Scheme теоретически можно
будет написать следующее:

◊begin{code:lisp}
(letrec ((x (/ (+ x 1) 2))) x)
◊end{code:lisp}

Заметьте, что переменная~◊ic{x} фактически определяется через саму себя.
Это,
похоже, обыкновенное уравнение
%
◊[  x = ◊frac{x + 1}{2}  ◊]
%
Логично будет сделать значением~◊ic{x} корень этого уравнения.
То~есть такое
выражение должно вернуть~◊ic{1}.

Но что делать, если у~уравнения нет корней или если их несколько?

◊begin{code:lisp}
(letrec ((x (+ x 1))) x)            ; $x = x + 1$
(letrec ((x (+ (power x 37) 1))) x) ; $x = x^{37} + 1$
◊end{code:lisp}

Однако, существуют множества, вроде известного вам множества S"=выражений, где
достаточно легко убедиться в~том, что уравнение имеет единственное решение
◊cite{ms80}.
Например, следующим образом можно без побочных эффектов определить
бесконечный список — как корень данного «списочного» уравнения:

◊begin{code:lisp}
(letrec ((foo (cons 'bar foo))) foo)
◊end{code:lisp}

◊indexR{ленивые вычисления}
Значением этого выражения может быть или лениво вычисляемый бесконечный
список ◊ic{(bar bar bar ...)}, как это сделано в~◊cite{fw76,pj87}, так и
закольцованная структура данных (менее дорогая с~вычислительной точки зрения):

◊begin{code:lisp}
(let ((foo (cons 'bar 'wait)))
  (set-cdr! foo foo)
  foo )
◊end{code:lisp}

Эффективно это одно и то~же, но на самом деле нет.
В~общем, из"~за всех этих
неоднозначностей стоит ввести правило, запрещающее использовать переменную,
определяемую ◊ic{letrec}, для определения значения этой~же переменной.
В~двух
предыдущих примерах необходимо было знать значение~◊ic{x} для того чтобы
инициализировать~◊ic{x}.
Теперь они, очевидно, являются ошибочными.
Однако мы
помним, что порядок инициализации в~Scheme должен быть неопределённым, а значит,
некоторые конструкции, допускаемые данным правилом, могут быть ошибочными
в~одних реализациях, но работать в~других.
Рассмотрим следующий пример:

◊begin{code:lisp}
(letrec ((x (+ y 1))
         (y 2) )
  x )
◊end{code:lisp}

Если ◊ic{y} инициализируется до~◊ic{x}, то всё в~порядке.
В~противном случае
возникает ошибка, потому что мы хотим увеличить значение переменной~◊ic{y},
которая уже существует, но ещё не~имеет значения.
Некоторые компиляторы Scheme
и ML анализируют выражения"=инициализаторы и проводят топологическую сортировку
для определения подходящего порядка инициализации.
Естественно, такое решение
тоже не~всегда срабатывает; в~частности, при взаимной зависимости◊footnote{Ведь
◊ic{(42~42)} вполне подходит как корень данного уравнения, но почему
именно~◊ic{42}?} вроде такой:

◊begin{code:lisp}
(letrec ((x y) (y x)) (list x y))
◊end{code:lisp}

Рассмотренные примеры напоминают о~нашей дискуссии вокруг глобального окружения
и семантики ◊ic{define}.
Там возникла похожая проблема: что делать
с~неинициализированными привязками и как узнать о~том, что они вообще
существуют.


◊subsection{Объявление неинициализированных~привязок}%
◊label{lisp1-2-omega/recusion/ssect:uninitialized}

◊indexR{привязки (bindings)!неинициализированные}
Официально семантика Scheme считает ◊ic{letrec} производной формой; то есть
удобным, но отнюдь не~обязательным сокращением.
Соответственно, любую
◊ic{letrec}-форму можно переписать с~помощью примитивных форм Scheme.
Чуть
раньше мы попробовали это сделать, временно связывая переменные ◊ic{letrec}
со~значением ◊ic{void}.
К~сожалению, это тоже инициализация, так что обращения
к~неинициализированным переменным подобным образом отловить нельзя.
Наша
ситуация усугубляется тем, что ни~одна из четырёх специальных форм Scheme
не~позволяет создавать «родные» неинициализированные привязки.

◊indexC*{UFO}{◊#<UFO>}
В~первом приближении можно было~бы решить проблему, используя некий объект
◊ic{◊#<UFO>} ◊seePage[basics/s:env/ufo] вместо ◊ic{void}.
С~ним ничего нельзя
сделать: ни~прибавить к~нему число, ни~взять его~◊ic{car}; однако, это всё~же
полноценный объект, так что его можно передать как аргумент в~◊ic{cons}, а
значит, следующая программа не~будет ошибочной и вернёт ◊ic{◊#<UFO>}:

◊begin{code:lisp}
(letrec ((foo (cons 'foo foo))) (cdr foo))
◊end{code:lisp}

Причина такого поведения в~том, что неинициализированность — это свойство
самой привязки, а не~её значения.
Следовательно, мы не~сможем решить проблему,
используя объекты первого класса.

◊ForLayout{display}{◊medskip}

◊indexC*{uninitialized}{◊#<uninitialized>}
И~всё~же, многие реализации дают неинициализированным переменным специальное
значение.
Давайте назовём его ◊ic{◊#<uninitialized>} и предположим, что это
полноценный объект.
Любая переменная с~таким значением считается
неинициализированной.
Следовательно, используя вместо ◊ic{void} значение
◊ic{◊#<uninitialized>}, мы получаем желаемую возможность обнаружить ошибку.
Однако, эта возможность чересчур явная: ничто не~запрещает передавать
◊ic{◊#<uninitialized>} в~функцию как аргумент, а значит, больше нельзя
предполагать, что все аргументы функции имеют значения.
Мы будем вынуждены
каждый раз проверять, действительно~ли это так:

◊begin{code:lisp}
(define (fact n)
  (if (eq? n '#<uninitialized>)
      (wrong "Uninitialized n")
      (if (= n 0) 1
          (* n (fact (- n 1))) ) ) )
◊end{code:lisp}

Делать так со~всеми переменными — это слишком большая плата за ◊ic{letrec}.
Так что ◊ic{◊#<uninitialized>} нельзя делать полноценным объектом, это должно
быть особое внутреннее значение интерпретатора, которое нельзя использовать
в~программах.
Для того, чтобы им можно было пользоваться безопасно, необходим
специальный синтаксис.

◊ForLayout{display}{◊medskip}

Третий вариант решения состоит во~введении специальной формы, создающей
неинициализированные привязки.
Например, перенесём синтаксис ◊ic{let} из
{◊CommonLisp}, выполняющей данное действие, в~Scheme:

◊begin{code:lisp}
(let (|◊ii{переменная}| ...)
  ...
)
◊end{code:lisp}

Если имя переменной указано само по себе, без начального значения, то привязка
к~этому имени не~будет инициализирована.
Если нам понадобится её значение, то мы
будем вынуждены проверять, была~ли инициализирована данная переменная или нет.
Теперь можно будет написать нормальную реализацию ◊ic{letrec}.
В~следующем коде
переменные ◊ii{temp◊sub{i}} являются «гигиеничными»: им выдаются специальные
имена, гарантированно не~конфликтующие с~именами переменных ◊ic{letrec} или
свободными переменными её тела.

◊ForLayout{display}{◊clearpage}

{◊def◊N#1{◊ii{имя◊sub{#1}}}
◊def◊T#1{◊ii{temp◊sub{#1}}}
◊def◊E#1{◊ii{выражение◊sub{#1}}}
◊def◊Q{◊hbox to 0pt{◊kern0.3em$◊equals$}}
◊begin{code:lisp}
(letrec ((|◊N 1| |◊E 1|)       (let (|◊N 1| ...
|◊N n|)
         ...
                       (let ((|◊T 1| |◊E 1|)
         (|◊N n| |◊E n|) )  |◊Q|           ...
  |◊ii{тело}| )                                  (|◊T n| |◊E n|) )
                                      (set! |◊N 1| |◊T 1|)
                                      ...
                                      (set! |◊N n| |◊T n|)
                                      |◊ii{тело}| ) )
◊end{code:lisp}}

◊indexCS{let}{специальная форма}
Итого, проблема решена с~приемлемой эффективностью: лишь неинициализированные
переменные вызывают накладные расходы, потому что за особенности надо платить.
Но теперь форма~◊ic{let} не~является просто синтаксическим сахаром, теперь это
полноценная специальная форма, которую должен обрабатывать лично интерпретатор.
Добавляем соответствующий код в~◊ic{evaluate}:

◊begin{code:lisp}
...
((let)
 (eprogn (cddr e)
         (extend env
                 (map (lambda (binding)
                        (if (symbol? binding) binding
                            (car binding) ) )
                      (cadr e) )
                 (map (lambda (binding)
                        (if (symbol? binding) the-uninitialized-marker
                            (evaluate (cadr binding) env) ) )
                      (cadr e) ) ) ) ) ...
◊end{code:lisp}

Переменная ◊ic{the-uninitialized-marker} принадлежит языку определения.
Зададим
её, например, так:

◊indexC{the-uninitialized-marker}
◊begin{code:lisp}
(define the-uninitialized-marker (cons 'not 'initialized))
◊end{code:lisp}

Конечно, теперь необходимо встроить поддержку этого внутреннего значения
в~функцию ◊ic{lookup}.
Функция ◊ic{update!} в~изменениях не~нуждается по
очевидным причинам.
Обращения к~◊ic{wrong} отвечают за два различных типа
ошибок: несуществующую привязку и неинициализированную привязку.

◊indexC{lookup}
◊begin{code:lisp}
(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (let ((value (cdar env)))
            (if (eq? value the-uninitialized-marker)
                (wrong "Uninitialized binding" id)
                value ) )
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )
◊end{code:lisp}

После блужданий по пустыне~семантики и синтаксиса, у~нас наконец"~то получилась
форма ◊ic{letrec}, позволяющая определять локальные взаимно рекурсивные функции.


◊subsection{Рекурсия без~присваивания}%
◊label{lisp1-2-omega/recusion/ssect:no-assignment}

◊indexR{язык!чисто функциональный}
◊indexR{рекурсия!без присваивания}
Форма ◊ic{letrec}, которую мы рассматривали, использует присваивания для
обеспечения правильного вычисления начальных значений.
Языки, называемые
◊emph{чисто функциональными}, не~имеют в~своём распоряжении операторов
присваивания; в~них принципиально нет побочных эффектов, а чем, как
не~побочным эффектом вычислений, является изменение значения переменной?

В~качестве парадигмы программирования запрет на присваивание имеет свои
преимущества: он гарантирует сохранение ссылочной прозрачности и этим
развязывает руки множеству оптимизаций, позволяя перемещать и распараллеливать
части программ, использовать ленивые вычисления {◊itd} Однако, если нет
возможности использовать присваивания, то некоторые алгоритмы становятся
не~такими простыми, а также несколько усложняется перенос программ на реальные
компьютеры, так как побочные эффекты являются неотъемлемой частью их работы.

◊indexC{letrec}
Первое, что приходит в~голову, это сделать ◊ic{letrec} ещё одной специальной
формой, как это и сделано в~ML и подобных ему языках.
Модифицируем ◊ic{evaluate}
для обработки этого случая:

◊begin{code:lisp}
...
((letrec)
 (let ((new-env (extend env
                        (map car (cadr e))
                        (map (lambda (binding) the-uninitialized-marker)
                             (cadr e) ) )))
      (map (lambda (binding)         ; ◊ic{map} во~имя беспорядка!
             (update! (car binding)
                      new-env
                      (evaluate (cadr binding) new-env) ) )
           (cadr e) )
      (eprogn (cddr e) new-env) ) ) ...
◊end{code:lisp}

В~этом случае побочные эффекты всё равно присутствуют, но на уровне
интерпретатора, внутри ◊ic{update!}; с~точки зрения определяемого языка побочных
эффектов нет.
Стоит заметить, что мы намеренно не~указываем порядок вычислений,
используя ◊ic{map}, которая, в~отличие от~◊ic{for-each}, вольна обрабатывать
список в~любом удобном порядке.◊footnote*{Правда, расплачиваясь за это
необходимостью собирать бесполезный список, который тут~же удаляется после
создания.}


◊subsubsection{◊texorpdfstring%
{◊protect◊ic{letrec} и~полностью~лексическое глобальное~окружение}%
{letrec и полностью лексическое глобальное окружение}}

В~гиперстатическом глобальном окружении переменную можно использовать только
после того, как она была определена.
С~такими ограничениями мы не~можем легко
определять ни~взаимно, ни даже просто рекурсивные функции.
Форма ◊ic{letrec}
решает эту проблему, а заодно служит индикатором рекурсивных определений.

◊begin{code:lisp}
(letrec ((fact (lambda (n)
                 (if (= n 0) 1 (* n (fact (- n 1)))) )))
  (letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
           (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
    ...
) )
◊end{code:lisp}

◊noindent
В~данном случае ◊ic{letrec} создаёт опережающие ссылки на ◊ic{fact}, ◊ic{odd?}
и~◊ic{even?}, так что определения будут работать и в~гиперстатическом окружении.


◊subsubsection{Парадоксальный комбинатор}

◊indexR{комбинаторы!неподвижной точки}
◊indexR{комбинаторы!Y@◊protect◊comb{Y}}
◊indexE{Y@◊protect◊comb{Y}, комбинатор}
◊indexR{теорема о~неподвижной точке}
◊indexR{неподвижная точка}
◊indexR{лямбда-исчисление@$◊lambda$-исчисление!комбинаторы}
Если вы имели дело с~$◊lambda$"=исчислением, то вы наверняка помните, что
такое ◊emph{комбинаторы неподвижной точки} и как записывается самый известный
из них — ◊emph{парадоксальный} или Y-комбинатор.
Функция~$f$ имеет
неподвижную точку, если в~её области определения существует элемент~$x$ такой,
что $f(x) = x$.
Комбинатор~◊comb{Y} принимает любую функцию
$◊lambda$"=исчисления и возвращает её неподвижную точку.
Эта идея выражена
в~одной из наиболее прекрасных и содержательных теорем $◊lambda$"=исчисления:

◊begin{theorem}{Теорема о~неподвижной точке}
$◊exists ◊comb{Y}◊colon ◊forall F◊colon ◊comb{Y} F = F(◊comb{Y} F)$
◊end{theorem}

В~терминах Лиспа, ◊comb{Y} — это значение выражения

◊begin{code:lisp}
(let ((W (lambda (w)
           (lambda (f)
             (f ((w w) f)) ) )))
  (W W) )
◊end{code:lisp}

Доказать это весьма просто.
Если предположить, что ◊comb{Y} равен $(W W)$,
то какой должна быть $W$◊!, чтобы $(W W)F$ равнялось $F ((W W) F)$?
Очевидно, что функция $W$◊! должна быть ничем иным, как $◊lambda W.
◊lambda F.
F ((W W) F)$.
Приведённое выражение лишь записывает эту идею на~Лиспе.

◊indexR{комбинаторы!Z@◊protect◊comb{Z}}
◊indexE{Z@◊protect◊comb{Z}, комбинатор}
◊indexR{эта-конверсия@$◊eta$-конверсия}
Правда, здесь возникает небольшое затруднений из"~за принятой в~Scheme передачи
аргументов по~значению.
Терм ◊ic{((w~w)~f)} не~следует вычислять слишком рано,
поэтому мы вынуждены добавить излишнюю (в~$◊lambda$"~исчислении)
$◊eta$"=конверсию, чтобы избежать проблем.
В~итоге мы приходим к~так называемому
Z-комбинатору, где ◊ic{(lambda (x) (...
x))} означает $◊eta$"=конверсию:

◊ForLayout{display}{◊clearpage}

◊indexC{fix}
◊begin{code:lisp}
(define fix
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda (x) (((w w) f) x))) ) )))
  (d d) ) )
◊end{code:lisp}

Самое сложное в~этом определении — понять, как оно работает.
Сейчас мы этим
и займёмся.
Определим функцию ◊ic{meta-fact}:

◊indexC{meta-fact}
◊begin{code:lisp}[label=lisp1-2-omega/recursion/y-combinator/code:meta-fact]
(define (meta-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n (f (- n 1))) ) ) )
◊end{code:lisp}

Эта функция подозрительно похожа на факториал.
Проверив, мы убеждаемся, что
◊ic{(meta-fact fact)} вычисляет факториал с~таким~же успехом, что и ◊ic{fact},
разве что несколько медленнее.
Теперь предположим, что мы знаем неподвижную
точку~$f$ функции ◊ic{meta-fact}: $f = ◊text{◊ic{(meta-fact $f$)}}$.
Эта
неподвижная точка по определению является решением следующего функционального
уравнения относительно~$f$:

◊begin{code:lisp}
|◊ii{f}| = (lambda (n)
      (if (= n 0) 1
          (* n (|◊ii{f}| (- n 1))) ) )
◊end{code:lisp}

Итак, что~же такое~$f$? Не~что иное, как всем известный факториал!

Вообще"~то говоря, нет ни~единого основания полагать, что уравнение выше имеет
решение и что оно единственно.
(Конечно, эти термины надо~бы определить строго
математически, но это выходит за рамки данной книги.) Действительно, есть как
минимум ещё одно решение:

◊indexC{fact}
◊begin{code:lisp}
(define (another-fact n)
  (cond ((< n 1) (- n))
        ((= n 1) 1)
        (else (* n (another-fact (- n 1)))) ) )
◊end{code:lisp}

◊indexR{неподвижная точка!наименьшая}
Проверьте, пожалуйста, что ◊ic{another-fact} также является неподвижной точкой
◊ic{meta-fact}.
Анализируя возможные неподвижные точки, можно прийти к~выводу,
что есть такая область определения, на которой их значения совпадают: все они
вычисляют факториал натуральных чисел.
Их поведение различно только тогда, когда
исходный вариант ◊ic{fact} попадает в~бесконечный цикл.
Для отрицательных целых
чисел ◊ic{another-fact} возвращает одно значение, хотя вполне могла~бы вернуть
какое-нибудь другое, потому что исходное функциональное уравнение не~указывает,%
◊footnote*{Более подробное объяснение см.~в~◊cite{man74}.} что делать в~таком
случае.
Если упорядочить функции по некоторой мере их определённости, то должна
существовать наименьшая неподвижная точка — наименее определённое решение
функционального уравнения.

Математический смысл глобальных рекурсивных определений вроде ◊ic{fact} состоит
в~том, что они определяют функции, являющиеся наименьшими неподвижными точками
соответствующих функциональных уравнений.
Когда мы пишем:

◊begin{code:lisp}
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )
◊end{code:lisp}

◊noindent
то фактически записываем уравнение относительно переменной~◊ic{fact}.
Форма
◊ic{define} решает это уравнение и связывает полученное решение
с~переменной~◊ic{fact}.
Такая трактовка уводит нас далеко от обсуждения
инициализации глобальных переменных
◊seePage[lisp1-2-omega/recusion/ssect:simple]
и превращает ◊ic{define} в~магический решатель уравнений.
В~действительности,
◊ic{define} реализована именно так, как предложено ранее.
Просто рекурсия
в~глобальном окружении вместе с~нормальным порядком вычислений действительно
способны находить наименьшие неподвижные точки.

А~теперь вернёмся к~◊ic{fix}, нашему Z-комбинатору, и проследим, как~же
вычисляется ◊ic{((fix~meta-fact)~3)}.
Помните, что здесь функции не~имеют
побочных эффектов, а значит, результаты вычислений можно свободно подставлять
друг в~друга, чем мы и будем пользоваться.

◊indexC{fix}
◊begin{code:lisp}
((fix meta-fact) 3)
|◊Equals|   (((d d)|◊begin{where}
                    ◊- d {◊eq} ◊begin{complex}
                              ◊-(lambda (w)
                              ◊-  (lambda (f)
                              ◊-   (f (lambda (x)
                              ◊-        (((w w) f) x) )) ) )
                              ◊end{complex}
                    ◊end{where}|
     meta-fact )
    3 )

|◊Equals|   (((lambda (f)               ; ◊term{шаг I}
       (f (lambda (x)
            (((w w) f) x) )) )|◊begin{where}
                               ◊- w {◊eq} ◊begin{complex}
                                         ◊-(lambda (w)
                                         ◊-  (lambda (f)
                                         ◊-   (f (lambda (x)
                                         ◊-        (((w w) f) x) )) ) )
                                         ◊end{complex}
                              ◊end{where}|
     meta-fact )
    3 )

|◊Equals|   ((meta-fact (lambda (x)
                 (((w w) f) x) ))|◊begin{where}
                                  ◊- w {◊eq} ◊begin{complex}
                                            ◊-(lambda (w)
                                            ◊-  (lambda (f)
                                            ◊-    (f (lambda (x)
                                            ◊-         (((w w) f) x) )) ) )
                                            ◊end{complex}
                                  ◊end{where}|
    3 )
|◊Equals|   ((lambda (n)
      (if (= n 0) 1
          (* n (f (- n 1))) ) )|◊begin{where}
                                ◊- f {◊eq} ◊begin{complex}
                                          ◊-(lambda (x)
                                          ◊-  (((w w) meta-fact) x) )◊begin{where}
                                                         ◊- w {◊eq} ◊begin{complex*}{6.2cm}
                                                                   ◊-(lambda (w)
                                                                   ◊-  (lambda (f)
                                                                   ◊-    (f (lambda (x)
                                                                   ◊-         (((w w) f) x) )) ) )
                                                                   ◊end{complex*}
                                                         ◊end{where}
                                                  ◊end{complex}
                                ◊end{where}|
    3 )
|◊Equals|   (* 3 (f 2))|◊begin{where}
                        ◊- f {◊eq} ◊begin{complex}
                                  ◊-(lambda (x)
                                  ◊-  (((w w) meta-fact) x) )◊begin{where}
                                                             ◊- w {◊eq} ◊begin{complex*}{4.8cm}
                                                                       ◊-(lambda (w)
                                                                       ◊-  (lambda (f)
                                                                       ◊-    (f (lambda (x)
                                                                       ◊-         (((w w) f) x) )) )  )
                                                                       ◊end{complex*}
                                                                      ◊end{where}
                                  ◊end{complex}
                        ◊end{where}|
|◊Equals|   (* 3 (((w w) meta-fact) 2))|◊begin{where}
                                        ◊- w {◊eq} ◊begin{complex}
                                                  ◊-(lambda (w)
                                                  ◊-  (lambda (f)
                                                  ◊-    (f (lambda (x)
                                                  ◊-         (((w w) f) x) )) ) )
                                                  ◊end{complex}
                                        ◊end{where}|
|◊Equals|   (* 3 (((lambda (f)           ; ◊term{шаг II}
            (f (lambda (x)
                 (((w w) f) x) )) )|◊begin{where}
                                    ◊- w {◊eq} ◊begin{complex}
                                              ◊-(lambda (w)
                                              ◊-  (lambda (f)
                                              ◊-    (f (lambda (x)
                                              ◊-         (((w w) f) x) )) ) )
                                              ◊end{complex}
                                    ◊end{where}|
          meta-fact )
         2 ) )
◊end{code:lisp}

Остановимся на минутку, чтобы заметить, что на шаге~II мы получили то~же самое
выражение, что и на шаге~I.
Естественно, оно появится и в~третий~раз:

◊begin{code:lisp}
(* 3 (* 2 (((lambda (f)
              (f (lambda (x)
                   (((w w) f) x) )) )|◊begin{where}
                                      ◊- w {◊eq} ◊begin{complex}
                                                ◊-(lambda (w)
                                                ◊-  (lambda (f)
                                                ◊-    (f (lambda (x)
                                                ◊-         (((w w) f) x) )) ) )
                                                ◊end{complex}
                                      ◊end{where}|
            meta-fact )
           1 )))
|◊Equals|   (* 3 (* 2 ((meta-fact (lambda (x)
                           (((w w) meta-fact) x) ))|◊begin{where}
                                                    ◊- w {◊eq} ◊begin{complex*}{4.5cm}
                                                              ◊-(lambda (w)
                                                              ◊-  (lambda (f)
                                                              ◊-    (f (lambda (x)
                                                              ◊-         (((w w) f) x) )) ) )
                                                              ◊end{complex*}
                                                    ◊end{where}|
              1 )))
|◊Equals|   (* 3 (* 2 ((lambda (n)
                (if (= n 0) 1
                    (* n (f (- n 1))) ) )|◊begin{where}
                                          ◊- f {◊is} ...
                                          ◊end{where}|
              1 )))
|◊Equals|   (* 3 (* 2 (if (= n 0) 1 (* n (f (- n 1))))))|◊begin{where}
                                                         ◊- n {◊is} 1
                                                         ◊- f {◊is} ...
                                                         ◊end{where}|
|◊Equals|   (* 3 (* 2 1))

|◊is| 6
◊end{code:lisp}

Обратите внимание, что в~процессе вычислений мы действительно используем
функцию, вычисляющую факториал.
Это значение выражения:

◊begin{code:lisp}
(lambda (x)
  (((w w) f) x) )|◊begin{where}
                  ◊- f {◊eq} meta-fact
                  ◊- w {◊is} ◊begin{complex}
                            ◊-(lambda (w)
                            ◊-  (lambda (f)
                            ◊-    (f (lambda (x)
                            ◊-         (((w w) f) x) )) ) )
                            ◊end{complex}
                  ◊end{where}|
◊end{code:lisp}

◊indexR{самоприменение!и рекурсия}
Идея состоит в~том, что благодаря самоприменению мы помним, как создать заново
данную функцию, и делаем это каждый раз, когда для вычислений требуется
рекурсивный вызов.

◊indexCS{define}{как решатель уравнений}
Таким образом можно получить простую рекурсию без использования побочных
эффектов, только с~помощью~◊ic{fix}, комбинатора неподвижной точки.
Благодаря
◊comb{Y} (или ◊ic{fix}), ◊ic{define} можно определить как решатель рекурсивных
уравнений; она принимает уравнение и связывает решение с~переданным именем.
В~итоге, если мы передадим ◊ic{define} уравнение для факториала, то с~◊ic{fact}
будет связано следующее значение:

◊begin{code:lisp}
(fix (lambda (fact)
       (lambda (n)
         (if (= n 0) 1
             (* n (fact (- n 1))) ) ) ))
◊end{code:lisp}

Аналогично можно решать системы уравнений, а значит, и задавать взаимно
рекурсивные функции, собирая их уравнения воедино:

◊indexC{odd"?}◊indexC{even"?}
◊begin{code:lisp}
(define odd-and-even
  (fix (lambda (f)
         (lambda (which)
           (case which
             ((odd) (lambda (n) (if (= n 0) #f
                                    ((f 'even) (- n 1)) )))
             ((even) (lambda (n) (if (= n 0) #t
                                     ((f 'odd) (- n 1)) ))) ) ) )) )
(define odd? (odd-and-even 'odd))
(define even? (odd-and-even 'even))
◊end{code:lisp}

У~этого метода есть один большой недостаток: неэффективность, даже по сравнению
с~наивной реализацией~◊ic{letrec}.
(И~всё~же, см.~◊cite{roz92,ser93}.) Тем
не~менее, он используется, особенно в~качестве книжного примера.
Функциональные
языки, по мнению ◊cite{pj87}, тоже особо не~жалуют данный метод, так как,
во-первых, он неэффективен, а во-вторых, ◊ic{fix} плохо сочетается с~системами
вывода типов.
Действительно, ◊ic{fix} принимает функционал,%
◊footnote*{Терминология Маккарти из~◊cite{mae+62}: функционал — это функция,
принимающая другие функции как аргументы.} принимающий функцию типа $◊alpha ◊to
◊beta$, и возвращает неподвижную точку этого функционала.
То~есть типом~◊ic{fix}
является
%
◊[ ◊big((◊alpha ◊to ◊beta) ◊to (◊alpha ◊to ◊beta)◊big) ◊to (◊alpha ◊to ◊beta) ◊]

◊indexR{самоприменение!типизация}
Но в~определении ◊ic{fix} есть самоприменение: ◊ic{(d~d)}.
Обозначив его тип
$◊gamma$, имеем:
%
◊[ ◊gamma = ◊gamma ◊to (◊alpha ◊to ◊beta) ◊]

Потребуется или нетривиальная система типов, чтобы в~ней можно было выразить
подобный рекурсивный тип, или~же мы будем вынуждены реализовать ◊ic{fix}
в~интерпретаторе как примитивную функцию, так как её нельзя выразить средствами
самого языка.


◊section{Заключение}◊label{lisp1-2-omega/sect:conclusions}

В~этой главе мы прошлись по наиболее заметным из вопросов, на которые сообщество
Лиспа за последние несколько десятков лет так и не~смогло дать однозначного
ответа.
Рассмотрев причины данных разногласий, мы поняли, что они вовсе не~такие
серьёзные по своей сути.
Большая часть из них связана с~неоднозначностью
толкования смысла формы ◊ic{lambda} и различными способами применения функций.
Хотя идея функции достаточно хорошо проработана в~математике, но
в~функциональных~(!) языках вроде Лиспа это отнюдь не~так.
Различные мнения по
таким вопросам — это часть истории Лиспа.
Подобно изучению истории родного
народа, их знание облегчает понимание причин тех или иных решений в~дизайне
языка, а также улучшает стиль программирования в~общем.

Также данная глава демонстрирует существенную важность понятия связывания.
В~◊Lisp1 переменная (имя) ассоциируется с~уникальной привязкой (возможно
глобальной), которая в~свою очередь ассоциируется с~каким-либо значением.
Так
как привязка уникальна, то мы говорим о~значении переменной, а не~о~значении
привязки этой переменной.
Если рассматривать привязки как абстрактный тип
данных, то можно сказать, что объекты этого типа создаются связывающими формами,
их значение определяется вычислением, изменяются они присваиванием, и могут быть
захвачены при создании замыкания, если тело замыкания ссылается на переменную,
которая ассоциирована с~данной привязкой.

Привязки не~являются полноценными объектами.
Они не~существуют в~отрыве от
переменных и могут быть изменены только косвенно.
Собственно, привязки полезны
именно потому, что они крепко-накрепко связаны со~своими переменными.

◊indexR{форма!связывающая}
◊indexR{связывающие формы}
◊indexR{область видимости!лексическая}
Бок~о~бок со~связывающими формами следует идея областей видимости.
Область
видимости переменной — это пространство в~тексте программы, где можно
обращаться к~данной переменной.
Область видимости переменных, создаваемых
формой ◊ic{lambda}, ограничена телом данной формы.
Поэтому она называется
текстуальной или лексической.

Присваивание вносит множество неоднозначностей в~идею связывания, мы изучим этот
вопрос подробнее в~следующих главах.


◊section{Упражнения}◊label{lisp1-2-omega/sect:exercises}

◊begin{exercise}◊label{lisp1-2-omega/ex:funcall}
Следующее выражение записано на {◊CommonLisp}.
Как бы вы его перевели на~Scheme?

◊begin{code:lisp}
(funcall (function funcall) (function funcall) (function cons) 1 2)
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:lexical}
Что вернёт данная программа на псевдо-{◊CommonLisp} из этой главы?
О~чём она вам напоминает?

◊begin{code:lisp}
(defun test (p)
  (function bar) )

(let ((f (test #f)))
  (defun bar (x) (cdr x))
  (funcall f '(1 .
2)) )
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:innovations}
Реализуйте в~вашем интерпретаторе первые две инновации из
раздела~◊ref{lisp1-2-omega/sect:extensions}
◊seePage[lisp1-2-omega/sect:extensions].
Речь идёт о~трактовке чисел и
списков как функций.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:assoc-with-comparator}
Можно научить функцию ◊ic{assoc/de} явно принимать компаратор (вроде ◊ic{eq?},
◊ic{equal?} {◊itp}) через аргумент, а не~задавать его внутри.
Сделайте это.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:dynamic}
Используя ◊ic{bind/de} и ◊ic{assoc/de}, напишите макросы, эмулирующие
специальные формы ◊ic{dynamic-let}, ◊ic{dynamic} и~◊ic{dynamic-set!}.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:write-put/get-prop}
◊indexC{putprop}◊indexC{getprop}
Напишите функции ◊ic{getprop} и ◊ic{putprop}, которые реализуют списки свойств.
Любой символ имеет личный список свойств в~виде пар «ключ — значение»;
добавление в~этот список осуществляет функция~◊ic{putprop}, поиск значения по
ключу осуществляет функция~◊ic{getprop}.
Также, естественно, должно выполняться
утверждение

◊begin{code:lisp}
(begin (putprop 'symbol 'key 'value)
       (getprop 'symbol 'key) )      |◊is| value
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:label}
Определите специальную форму ◊ic{label} на ◊Lisp1.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:labels}
Определите специальную форму ◊ic{labels} на ◊Lisp2.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:orderless-letrec}
◊indexC{letrec}
Придумайте, как реализовать ◊ic{letrec} с~помощью ◊ic{let} и ◊ic{set!} так,
чтобы порядок вычисления значений"=инициализаторов был неопределённым.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:fixn}
◊indexR{комбинаторы!неподвижной точки!универсальный}
У~нашего комбинатора неподвижной точки на Scheme обнаружился недостаток: он
поддерживает только унарные функции.
Реализуйте ◊ic{fix2}, работающий
с~бинарными функциями.
Затем ◊ic{fixN}, поддерживающий функции любой арности.
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:nfixn}
Далее напишите функцию ◊ic{NfixN}, возвращающую неподвижные точки для списка
функционалов произвольной арности.
Её можно использовать, например, следующим
образом:

◊begin{code:lisp}
(let ((odd-and-even
       (NfixN (list (lambda (odd? even?)    ; ◊ic{odd?}
                      (lambda (n)
                        (if (= n 0) #f (even? (- n 1))) ) )
                    (lambda (odd? even?)    ; ◊ic{even?}
                      (lambda (n)
                        (if (= n 0) #t (odd? (- n 1))) ) ) )) ))
  (set! odd? (car odd-and-even))
  (set! even? (cadr odd-and-even)) )
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:klop}
Рассмотрим функцию ◊ic{klop}.
Является~ли она комбинатором неподвижной точки?
Попробуйте доказать или опровергнуть, что ◊ic{(klop $f$)} тоже возвращает
неподвижную точку~$f$ подобно~◊ic{fix}.

◊indexC{klop}
◊begin{code:lisp}
(define klop
  (let ((r (lambda (s c h e m)
             (lambda (f)
               (f (lambda (n)
                    (((m e c h e s) f) n) )) ) )))
    (r r r r r r) ) )
◊end{code:lisp}
◊end{exercise}

◊begin{exercise}◊label{lisp1-2-omega/ex:hyper-fact}
◊indexC{fact}
Если функция ◊ic{hyper-fact} определена так:

◊begin{code:lisp}
(define (hyper-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n ((f f) (- n 1))) ) ) )
◊end{code:lisp}

◊noindent
то что вернёт ◊ic{((hyper-fact hyper-fact)~5)}?
◊end{exercise}

◊section*{Рекомендуемая литература}%
◊label{lisp1-2-omega/sect:recommended-reading}

Кроме упомянутой ранее работы по $◊lambda$"=исчислению ◊cite{ss78a} также имеет
смысл почитать про анализ функций в~◊cite{mos70} и сравнительный анализ ◊Lisp1
и ◊Lisp2 в~◊cite{gp88}.

В~◊cite{gor88} есть интересное введение в~$◊lambda$"=исчисление.

Комбинатор ◊comb{Y} разбирается подробнее в~◊cite{gab88}.
